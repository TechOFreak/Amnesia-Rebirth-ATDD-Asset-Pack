//----------------------------------------------------------------------

////////////////////////////////
// GHOUL                      //
////////////////////////////////

//----------------------------------------------------------------------

#include "agents/Agent_Humanoid.hps"
#include "helper/helper_audio.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_player.hps"
#include "custom/helpers/helper_player_custom.hps"
#include "helpers/helper_effects.hps"
#include "custom/player/PlayerTypes_Custom.hps"
#include "helper_modules_custom.hps"
#include "base/Base_Types.hps"
#include "custom/agents/agent_types_custom.hps"
#include "custom/components/ComponentInterfaces_Custom.hps"
#include "custom/helpers/helper_areas_custom.hps"
#include "helpers/helper_props.hps"
#include "helpers/helper_flashlight.hps"
#include "helpers/helper_items.hps"
#include "modules/TerrorHandler.hps"

#include "helpers/helper_effects_custom.hps"


//----------------------------------------------------------------------

class cGhoulThrowInfo
{
	int mlId = -1;
	float mfDownDist = 0.f;
	cVector3f mvEnd = 0.f;
	cVector3f mvThrowTarget = 0;
}

//----------------------------------------------------------------------

class cGhoulThrowCandidate
{
	int mlId = -1;
	float mfDist = 0;
	cVector3f mvDownRaycast = 0;
	float mfDownDist = -1;
	
	int opCmp(const cGhoulThrowCandidate &in pOther)
	{
		if (mfDist > pOther.mfDist) return 1;
		if (mfDist < pOther.mfDist) return -1;
		return 0;
	}
}

//----------------------------------------------------------------------

/////////////////////////////////////////
// SOUND
//{//////////////////////////////////////

//----------------------------------------------------------------------

tString sFootstep_SoundPath = "ptest/enemy/suitor/";
tString sFootstep_RunSound = "metal_run.snt";
tString sFootstep_WalkSound = "metal_walk.snt";

tString msGhoulMusic_Hunt = "ui_terror_meter.ogg";

tString gsGhoulSound_PlayerDetected = "none";
tString gsGhoulSound_PlayerSpotted = "none";
tString gsGhoulSound_Attack = "none";
tString gsGhoulSound_AttackHitPlayer = "ptest/enemy/suitor/attack_claw_hit.snt";
tString gsGhoulSound_StartSearch = "none";
tString gsGhoulSound_Searching = "none";
tString gsGhoulSound_LookAround = "none";
tString gsGhoulSound_SoundHeard = "none";
tString gsGhoulSound_GiveUp = "none";
tString gsGhoulSound_Frustration = "none";
tString gsGhoulSound_Threaten = "none";
tString gsGhoulSound_AngryShout = "none";
tString gsGhoulSound_BeHit = "none";
tString gsGhoulSound_CrawlThroughTunnels = "creatures/vocalisations/creature/ghoul/ghoul_idle";
tString gsGhoulSound_CrawlOut = "creatures/vocalisations/creature/ghoul/ghoul_exit_hole";
tString gsGhoulSound_CrawlIn = "creatures/vocalisations/creature/ghoul/ghoul_enter_hole";
tString gsGhoulSound_CrawlOutFoley = "creatures/foley/creature/ghoul/ghoul_hole/ghoul_exit_hole";
tString gsGhoulSound_CrawlInFoley = "creatures/foley/creature/ghoul/ghoul_hole/ghoul_enter_hole";
tString gsGhoulSound_EnterSuperHunt = "none";
tString gsGhoulSound_StartHunt = "none";
tString gsGhoulSound_CallOutBackup = "none";
tString gsGhoulSound_CallOutHunt = "none";
tString gsGhoulSound_ConversationStart = "none";
tString gsGhoulSound_ConversationReply = "none";
tString gsGhoulSound_RequestHelp = "none";
tString gsGhoulSound_Agree = "none";
tString gsGhoulSound_SearchGround = "none";
tString gsGhoulSound_InteractWithFetish = "none";
tString gsGhoulSound_EatQuick = "none";
tString gsGhoulSound_Scream = "none";
tString gsGhoulSound_Enthralled = "none";
tString gsGhoulSound_LostTrackSmall = "none";

tString gsGhoulSound_Smell = "creatures/vocalisations/creature/ghoul/ghoul_smell_notice";
tString gsGhoulSound_SmellStartTracking = "creatures/vocalisations/creature/ghoul/ghoul_smell_notice";
tString gsGhoulSound_SmellTrackingLoop = "creatures/vocalisations/creature/ghoul/ghoul_smell_notice";
tString gsGhoulSound_SmellTrackingLoop_ParamIntensity = "intensity";
tString gsGhoulSound_SmellLostTrack = "creatures/vocalisations/creature/ghoul/ghoul_smell_notice";

tString gsGhoulSound_GrowlLoop = "none";
tString gsGhoulSound_EatLoop = "none";

tString gsGhoulSound_EmergeAlert = "creatures/vocalisations/creature/ghoul/ghoul_pre_exit_warning";
tString gsGhoulSound_WallMoveStart = "creatures/foley/creature/ghoul/ghoul_hole/inside_wall_start";
tString gsGhoulSound_WallMoveLoop = "creatures/foley/creature/ghoul/ghoul_hole/inside_wall_loop";
tString gsGhoulSound_HoleArrived = "creatures/foley/creature/ghoul/ghoul_hole/ghoul_hole_near";
tString gsGhoulSound_HoleActiveLoop = "creatures/foley/creature/ghoul/ghoul_hole/ghoul_tunnel_approach";

//----------------------------------------------------------------------

//} END SOUND

//----------------------------------------------------------------------

/////////////////////////////////////////
// ANIMATION
//{//////////////////////////////////////

//----------------------------------------------------------------------

tString gsGhoulAnim_PlayerDetected = "glimpse_player_straight_ahead";
tString gsGhoulAnim_PlayerDetected_45_Left = "glimpse_player_45_left";
tString gsGhoulAnim_PlayerDetected_45_Right = "glimpse_player_45_right";
tString gsGhoulAnim_PlayerDetected_90_Left = "glimpse_player_90_left";
tString gsGhoulAnim_PlayerDetected_90_Right = "glimpse_player_90_right";

tString gsGhoulAnim_Alert = "alert";
tString gsGhoulAnim_Alert2 = "alert_var1";
tString gsGhoulAnim_CrawlExit = "crawl_to_idle";
tString gsGhoulAnim_CrawlEnter = "idle_to_crawl";
tString gsGhoulAnim_CrawlLoop = "crawl";
tString gsGhoulAnim_CrawlIn50cm = "crawl_into_hole_at_50cm";
tString gsGhoulAnim_EatLoop = "eat_ground";
tString gsGhoulAnim_EatStop = "eat_ground_tr_idle_stand";

tString gsGhoulAnim_AttackClose1 = "attack_close_1";
tString gsGhoulAnim_AttackClose2 = "attack_close_2";

//////////////////////
// TODO: add actual animations
array<tString> mvGhoulAnim_LookAroundLong = { "look_around_long_1", "look_around_long_2" };
tString gsGhoulAnim_LookAroundShort = "look_around_short";
array<tString> mvGhoulAnim_Sniff = { "sniff_long_1", "sniff_long_2" };
tString gsGhoulAnim_BeHit = "flinch"; // used when hit by an object and stunned
tString gsGhoulAnim_Threaten = "alert";
array<tString> gvGhoulAnim_AngryGesture = { "angry_1", "angry_2", "angry_3" };
tString gsGhoulAnim_Frustration = "frustration"; // used after losing the player and when having to retreat from the player
tString gsGhoulAnim_TurnToPlayer = "none"; // used when the ghoul detects the player behind it or is hit, quickly turns to the player
tString gsGhoulAnim_StartHunt = "none";
tString gsGhoulAnim_CallOut = "none";
tString gsGhoulAnim_SpeakVariation1 = "alert";
tString gsGhoulAnim_SpeakVariation2 = "alert";
tString gsGhoulAnim_Celebrate = "alert";
tString gsGhoulAnim_Agree = "alert";
tString gsGhoulAnim_SearchGround = "alert";
tString gsGhoulAnim_InteractWithFetish = "attack_close_1";
tString gsGhoulAnim_EatQuick = "eat_loop";
array<tString> mvGhoulAnim_Scream = { "scream_1", "scream_2" };
array<tString> mvGhoulAnim_BreakDoor = { "break_down_door_b" };
array<tString> mvGhoulAnim_HitDoor = { "break_down_door_a", "break_down_door_c" };
array<tString> mvGhoulAnim_HitObstacle = { "attack_close_1", "attack_close_2" };
tString gsGhoulAnim_Enthralled = "alert";
tString gsGhoulAnim_LostTrackSmall = "angry_2";
tString gsGhoulAnim_ShrugOff = "shrug_off_d";

tString gsGhoulAnim_Move_IdleAggressive = "aggressive_idle_stand";
tString gsGhoulAnim_Move_WalkSearch = "walk_search";
tString gsGhoulAnim_Move_WalkThreatening = "walk_slow_threatening_c";
array<tString> gvGhoulAnim_Move_Threaten = { "walk_slow_taunt_a", "walk_slow_taunt_b" };

//----------------------------------------------------------------------

//} END ANIMATION

//----------------------------------------------------------------------

/////////////////////////////////////////
// SETTINGS
//{//////////////////////////////////////

//----------------------------------------------------------------------

bool gbDebugIdle = false; // if true will stay in idle
bool gbDebugSightOff = false; // if true it won't detect player
float gfAlertTime = 8.0f;
float gfAlertTimeOutOfSightMul = 1.5f;
float gfPreAlertTime = 0.5f;
int glMinExitHoleWanders = 1;
int glMaxExitHoleWanders = 4;
int glMinSearches = 2;
int glMaxSearches = 4;
float gfBlackboardMessageRange = 15.0f;
bool gbGhoul_PredictPlayerPos = false; // the ghoul will predict the player's position once after losing sight
bool gbGhoul_CheckForPlayerFollow = false; // the ghoul will sniff if the player has been following it for a while
float gfGhoul_SpeedRun = 5.2f;
cColor gGhoul_EyeColorDefault = cColor(1.65f, 1.65f, 1.65f);
cColor gGhoul_EyeColorAlerted = cColor(1.95f, 1.68f, 0.5f);
cColor gGhoul_EyeColorAttacking = cColor(2.5f, 0.7f, 0.7f);
float gfGhoul_EyeColorMul = 5.0f;

float gfMaxFearDistance = 2.0f;
float gfMinFearDistance = 10.0f;
float gfFear_SurpriseEffect = 0.5f;

//----------------------------------------------------------------------

float gfMaxThrowDistance = 10.f;
float gfMinThrowDistance = 5.f; // probably tweak theese?

//----------------------------------------------------------------------

//} END SETTINGS

//----------------------------------------------------------------------

/////////////////////////////////////////
// TYPES
//{//////////////////////////////////////

//----------------------------------------------------------------------

enum eGhoulAttractionObject
{
	eGhoulAttractionObject_NONE,
	eGhoulAttractionObject_MEAT,
}

//----------------------------------------------------------------------

enum eGhoulAttackFrames
{
	eGhoulAttackFrames_Idle,
	eGhoulAttackFrames_Startup,
	eGhoulAttackFrames_Active,
	eGhoulAttackFrames_Recovery,
	eGhoulAttackFrames_BecomeFree,
}

//----------------------------------------------------------------------

enum eGhoulState
{
	eGhoulState_Idle,
	eGhoulState_Wait,
	eGhoulState_HideInHole,
	eGhoulState_Emerge,
	eGhoulState_WanderToExitHole,
	eGhoulState_TrackSmell,
	eGhoulState_Sniff,
	eGhoulState_InvestigateSniff,
	eGhoulState_InvestigateSound,
	eGhoulState_ReturnToHole,
	eGhoulState_MoveTo,
	eGhoulState_Patrol,
	eGhoulState_Hunt,
	eGhoulState_PostHunt,
	eGhoulState_SearchForPlayer,
	eGhoulState_SearchArea,
	eGhoulState_CheckLastKnownPosition,
	eGhoulState_PlayerLightDetected,
	eGhoulState_CheckGobo,
	eGhoulState_CheckFlashlightHit,
	eGhoulState_PlayerDetected,
	eGhoulState_Alert,
	eGhoulState_MovingAlert,
	eGhoulState_AttackLunge,
	eGhoulState_AttackClose,
	eGhoulState_ThrowPlayer,
	eGhoulState_Struggle,
	eGhoulState_StruggleStandBy,
	eGhoulState_PostAttack,
	eGhoulState_Stunned,
	eGhoulState_Enthralled,
	eGhoulState_ThreateningApproach,
	eGhoulState_Stare,
    eGhoulState_Guard,
	eGhoulState_Trapped,
	eGhoulState_Blocked,
	eGhoulState_BlockedByProp,
	eGhoulState_EnterDoor,
	eGhoulState_Retreat,
	eGhoulState_PostRetreat,
	eGhoulState_BreakDoor,
	eGhoulState_Stuck,
	eGhoulState_WanderArea,
	eGhoulState_Attracted,
	eGhoulState_EatMeat,
	eGhoulState_WakeUp,
	eGhoulState_Debug,
	
	eGhoulState_PostAttack_Retreat,
	
	eGhoulState_ProximityEvent_Talk,
	eGhoulState_ProximityEvent_Fight,
	eGhoulState_ProximityEvent_Follow,
	
	eGhoulState_EnvironmentEvent_SimpleAnimation,
}

//----------------------------------------------------------------------

enum eGhoulProximity
{
	eGhoulProximity_Touching,
    eGhoulProximity_VeryClose,
	eGhoulProximity_Close,
    eGhoulProximity_SemiClose,
	eGhoulProximity_Near,
	eGhoulProximity_LowLightVision,
	eGhoulProximity_Midrange,
	eGhoulProximity_Far,
	eGhoulProximity_LungeAttack,
}

//----------------------------------------------------------------------

enum eGhoulBark
{
	eGhoulBark_Silent,
	eGhoulBark_Wander,
	eGhoulBark_Search,
	eGhoulBark_EatMeat,
}

//----------------------------------------------------------------------

enum eGhoulAlertState
{
	eGhoulAlertState_None,
	eGhoulAlertState_Alert,
	eGhoulAlertState_Investigating,
	eGhoulAlertState_Hunting,
}

//----------------------------------------------------------------------

enum eGhoulCommand
{
	eGhoulCommand_None,
	eGhoulCommand_Patrol,
	eGhoulCommand_GoToHole,
	eGhoulCommand_EmergeFromHole,
	eGhoulCommand_Retreat,
	eGhoulCommand_UseDoor,
	eGhoulCommand_Smell,
	eGhoulCommand_WakeUp,
	eGhoulCommand_ThreatenPlayer,
}

//----------------------------------------------------------------------

enum eGhoulAnimationMessageEvent
{
	eGhoulAnimationMessageEvent_GiveThrowDamage = 1,
}


//----------------------------------------------------------------------

class cGhoulPatrol
{
	cGhoulPatrol(){}
	cGhoulPatrol(int alId)
	{
		mlId = alId;
	}
	
	int mlId = -1;
	int mlLoopCount = -1;
	bool mbRandom = false;
	eGhoulSpeed mSpeed = eGhoulSpeed_Walk;
	tString msEndOfPatrolCallback = "";
	array<cGhoulPatrolNode> mvNodes;
}

class cGhoulPatrolNode
{
	tString msName;
	float mfMinWaitTime;
	float mfMaxWaitTime;
	tString msAnimName;
	bool mbLoopAnim;
}

//----------------------------------------------------------------------

class cDistanceCallback
{
	tString msFunction;
	float mfDistance;
}

//----------------------------------------------------------------------

//} END SETTINGS

//----------------------------------------------------------------------

class cScrAgentGhoul : cScrAgentHumanoid
{
	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// MAIN FUNCTIONS
	//=======================================
	//{//////////////////////////////////////
	
	//===========================================================

	//------------------------------------------------------------

	/////////////////////////////////////////
	// INIT
	//{//////////////////////////////////////

	//------------------------------------------------------------

	void Init()
	{
		mBaseObj.SetUpdatePlayerDetection(true);
	}

	//} END INIT

	//------------------------------------------------------------

	/////////////////////////////////////////
	// LOADING
	//{//////////////////////////////////////

	//------------------------------------------------------------

	void SetupCharBody()
	{
		cScrAgentHumanoid::SetupCharBody();
		iCharacterBody@ pCharBody = mBaseObj.GetCharBody();

		pCharBody.SetMass(80);
		pCharBody.SetMaxPositiveMoveSpeed(eCharDir_Forward, 1.2f);
		pCharBody.SetMoveSpeedMul(eCharDir_Forward, 1.1);
		pCharBody.SetMoveAcc(eCharDir_Forward, 4);
		pCharBody.SetMoveDeacc(eCharDir_Forward, 8);
		pCharBody.SetMaxPushMass(20);
		pCharBody.SetMaxPushForce(300);
		pCharBody.SetAccurateClimbing(true);
		
		pCharBody.GetCurrentBody().SetMaterial(mBaseObj.GetMap().GetPhysicsWorld().GetMaterialFromName("hanging_corpse"));
	}

	//------------------------------------------------------------

	void SetupAfterLoad(cWorld @apWorld, cResourceVarsObject@ apVars, cResourceVarsObject@ apInstanceVars)
	{
		cScrAgentHumanoid::SetupAfterLoad(apWorld, apVars, apInstanceVars);

		//////////////////////
		// General Setup
		mfSightMul = apInstanceVars.GetVarFloat("SightMul", 1.0f);
		mfHearingMul = apInstanceVars.GetVarFloat("HearingMul", 1.0f);
		
		mBaseObj.SetAlignEntityWithGroundRay(true);
		mBaseObj.SetFOV(cMath_ToRad(130.0f));
		mBaseObj.SetSightRange(20.0f);
		mBaseObj.SetSightRangeMul(mfSightMul);
		mBaseObj.SetRelativeEyeHeight(0.8f);
		
		if (gbDebugSightOff)
		{
			mBaseObj.SetSightRange(0);
		}
        

		////////////
		// Pathfinder Setup
		mpPathfinder.SetNodeContainerName("Ghoul");
		mpPathfinder.SetMaxHeight(0.8f);
        //Disable wall climbing for grunt
		mpPathfinder.SetClimbWalls(false);
		mpPathfinder.SetDirectPathMaxDistanceMul(mfDirectPathMaxDistanceMul);

		////////////
		// Attack animations setup
		msAttackAnimName = apVars.GetVarString("CloseAttackName", "Attack");
		mlNumAttackAnims = apVars.GetVarInt("NumAttackAnims", 1);
		msAttackLungeAnimName = apVars.GetVarString("LungeAttackName", "AttackLunge");
		mlNumAttackLungeAnims = apVars.GetVarInt("NumAttackLungeAnims", 1);

		////////////
		// Eating variables
		mfMinEatTime = apVars.GetVarFloat("MinEatTime", 5.0f);
		mfMaxEatTime = apVars.GetVarFloat("MaxEatTime", 5.0f);
		
		////////////
		// Ghoul
//		mbHunt_SuperHuntEnabled = apInstanceVars.GetVarBool("SuperHunt", true);
//		mbDetectFlashlight = apInstanceVars.GetVarBool("DetectFlashlight", true);
		msRetreatAreaName = apInstanceVars.GetVarString("RetreatAreas", "");
		
		////////////
		// Hole network
		msHoleNetwork = apInstanceVars.GetVarString("HoleNetwork", "");
		msPlayerPath = apInstanceVars.GetVarString("PlayerPath", "");
		msHoleConnections = apInstanceVars.GetVarString("HoleConnections", "");
		
		////////////
		// Animations
		msIdleAnim = apVars.GetVarString("CharMover_IdleAnim", "");
		
		msOrigWalkAnim = apVars.GetVarString("CharMover_WalkAnim", "");
		msWalkAnim = msOrigWalkAnim;

		SetupComponents(apWorld, apVars, apInstanceVars);
	}

	//------------------------------------------------------------

	void SetupComponents(cWorld @apWorld, cResourceVarsObject@ apVars, cResourceVarsObject@ apInstanceVars)
	{
		////////////
		// State Machine
		@mpStateMachine = cLux_CreateEntityComponent_StateMachine(mBaseObj);
		
		mpStateMachine.AddState("Idle", eGhoulState_Idle);
		mpStateMachine.AddState("Wait", eGhoulState_Wait);
		mpStateMachine.AddState("HideInHole", eGhoulState_HideInHole);
		mpStateMachine.AddState("Emerge", eGhoulState_Emerge);
		mpStateMachine.AddState("ReturnToHole", eGhoulState_ReturnToHole);
		mpStateMachine.AddState("MoveTo", eGhoulState_MoveTo);
		mpStateMachine.AddState("WanderToExitHole", eGhoulState_WanderToExitHole);
		mpStateMachine.AddState("TrackSmell", eGhoulState_TrackSmell);
		mpStateMachine.AddState("Sniff", eGhoulState_Sniff);
		mpStateMachine.AddState("InvestigateSniff", eGhoulState_InvestigateSniff);
		mpStateMachine.AddState("InvestigateSound", eGhoulState_InvestigateSound);
		mpStateMachine.AddState("Hunt", eGhoulState_Hunt);
		mpStateMachine.AddState("PostHunt", eGhoulState_PostHunt);
		mpStateMachine.AddState("SearchForPlayer", eGhoulState_SearchForPlayer);
		mpStateMachine.AddState("SearchArea", eGhoulState_SearchArea);
		mpStateMachine.AddState("CheckLastKnownPosition", eGhoulState_CheckLastKnownPosition);
		mpStateMachine.AddState("PlayerLightDetected", eGhoulState_PlayerLightDetected);
		mpStateMachine.AddState("CheckGobo", eGhoulState_CheckGobo);
		mpStateMachine.AddState("CheckFlashlightHit", eGhoulState_CheckFlashlightHit);
		mpStateMachine.AddState("Patrol", eGhoulState_Patrol);
		mpStateMachine.AddState("PlayerDetected", eGhoulState_PlayerDetected);
		mpStateMachine.AddState("Alert", eGhoulState_Alert);
		mpStateMachine.AddState("MovingAlert", eGhoulState_MovingAlert);
		mpStateMachine.AddState("AttackLunge", eGhoulState_AttackLunge);
		mpStateMachine.AddState("AttackClose", eGhoulState_AttackClose);
		mpStateMachine.AddState("ThrowPlayer", eGhoulState_ThrowPlayer);
		mpStateMachine.AddState("Struggle", eGhoulState_Struggle);
		mpStateMachine.AddState("StruggleStandBy", eGhoulState_StruggleStandBy);
		mpStateMachine.AddState("PostAttack", eGhoulState_PostAttack);
		mpStateMachine.AddState("Stunned", eGhoulState_Stunned);
		mpStateMachine.AddState("Enthralled", eGhoulState_Enthralled);
		mpStateMachine.AddState("ThreateningApproach", eGhoulState_ThreateningApproach);
		mpStateMachine.AddState("Stare", eGhoulState_Stare);
        mpStateMachine.AddState("Guard", eGhoulState_Guard);
		mpStateMachine.AddState("Trapped", eGhoulState_Trapped);
		mpStateMachine.AddState("BlockedByProp", eGhoulState_BlockedByProp);
		mpStateMachine.AddState("Retreat", eGhoulState_Retreat);
		mpStateMachine.AddState("PostRetreat", eGhoulState_PostRetreat);
		mpStateMachine.AddState("Blocked", eGhoulState_Blocked);
		mpStateMachine.AddState("EnterDoor", eGhoulState_EnterDoor);
		mpStateMachine.AddState("Stuck", eGhoulState_Stuck);
		mpStateMachine.AddState("WanderArea", eGhoulState_WanderArea);
		mpStateMachine.AddState("BreakDoor", eGhoulState_BreakDoor);
		mpStateMachine.AddState("Attracted", eGhoulState_Attracted);
		mpStateMachine.AddState("EatMeat", eGhoulState_EatMeat);
		mpStateMachine.AddState("WakeUp", eGhoulState_WakeUp);
		mpStateMachine.AddState("Debug", eGhoulState_Debug);
		
		mpStateMachine.AddState("PostAttack_Retreat", eGhoulState_PostAttack_Retreat);
		
		////////////
		// Proximity events
		mpStateMachine.AddState("ProximityEvent_Talk", eGhoulState_ProximityEvent_Talk);
		mvProximityEvents.push_back(cAgentEvent(eGhoulState_ProximityEvent_Talk, eAgentProximityEvent_GhoulTalk, 0.4f));
		
		mpStateMachine.AddState("ProximityEvent_Fight", eGhoulState_ProximityEvent_Fight);
		mvProximityEvents.push_back(cAgentEvent(eGhoulState_ProximityEvent_Fight, eAgentProximityEvent_GhoulFight, 0.4f));
		
		mpStateMachine.AddState("ProximityEvent_Follow", eGhoulState_ProximityEvent_Follow);
		mvProximityEvents.push_back(cAgentEvent(eGhoulState_ProximityEvent_Follow, eAgentProximityEvent_GhoulFollow, 0.2f));
		
		////////////
		// Environment events
		mpStateMachine.AddState("EnvironmentEvent_SimpleAnimation", eGhoulState_EnvironmentEvent_SimpleAnimation);
		

		////////////
		// Listener
		@mpSoundListener = cLux_CreateEntityComponent_SoundListener(mBaseObj);
		mpSoundListener.LoadFromInstanceVariables(apInstanceVars);
		mpSoundListener.SetHearRadius(mfHearRadius);
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);

		////////////
		// Light Sensor
		@mpLightSensor = cLux_CreateEntityComponent_LightSensor(mBaseObj);
		
		///////////////
		// Foot placement
		@mpFootPlacement = cLux_CreateEntityComponent_FootPlacement(mBaseObj);
		mpFootPlacement.LoadFromVariables(apVars);

		///////////////////////////////
		//Proximity Sensor
		@mpProximitySensor = cLux_CreateEntityComponent_ProximitySensor(mBaseObj);

		mpProximitySensor.AddState(eGhoulProximity_Touching, 1.2, 1.3, true, false);
        mpProximitySensor.AddState(eGhoulProximity_VeryClose, 2.0, 2.2, true, false);
		mpProximitySensor.AddState(eGhoulProximity_Close, 3.0, 3.2, true, false);
        mpProximitySensor.AddState(eGhoulProximity_SemiClose, 3.6, 3.7, true, false);
		mpProximitySensor.AddState(eGhoulProximity_Near, 4.5, 4.7, true, false);
		mpProximitySensor.AddState(eGhoulProximity_LowLightVision, 4.9, 5.2, true, false);
		mpProximitySensor.AddState(eGhoulProximity_Midrange, 12.4, 12.6, true, false);
		mpProximitySensor.AddState(eGhoulProximity_Far, 16.4, 16.6, true, false);

		mpProximitySensor.AddState(eGhoulProximity_LungeAttack, 5.0, 6.5, true, false);

		////////////
		// Mover Setup
		mpMover.SetupWallAvoidance(0.9f, 5.0f, 4);
		mpMover.SetWallAvoidanceActive(true);
		mpMover.SetupDynamicObjectAvoidance(2.5f, 20, 5);
		mpMover.SetDynamicObjectAvoidanceActive(true);
		
		mpMover.SetDynamicObjectPlayerAvoidanceActive(false);
		mpMover.SetupDynamicObjectPlayerAvoidance(4.0f, 3);

		mpMover.SetVerticalMoveSpeedExtraAnimMul(0.5f);

		mpMover.SetMaxForwardSpeed(1);
		mpMover.SetMaxBackwardSpeed(1);

		mpMover.SetRunToWalkSpeed(1.0);
		mpMover.SetWalkToRunSpeed(3.0);
		
		mpMover.AddSpeedState(eGhoulSpeed_SlowestWalk);
		mpMover.SetSpeedState_Forward(0.4);

		mpMover.AddSpeedState(eGhoulSpeed_SlowWalk);
		mpMover.SetSpeedState_Forward(0.75);
		
		mpMover.AddSpeedState(eGhoulSpeed_Walk);
		mpMover.SetSpeedState_Forward(1.0);
		
		mpMover.AddSpeedState(eGhoulSpeed_MediumWalk);
		mpMover.SetSpeedState_Forward(1.3f);
		
		mpMover.AddSpeedState(eGhoulSpeed_FastWalk);
		mpMover.SetSpeedState_Forward(1.6f);
		
		mpMover.AddSpeedState(eGhoulSpeed_FasterWalk);
		mpMover.SetSpeedState_Forward(2.1f);
		
		mpMover.AddSpeedState(eGhoulSpeed_SlowRun);
		mpMover.SetSpeedState_Forward(3.8f);
		
		mpMover.AddSpeedState(eGhoulSpeed_Run);
		mpMover.SetSpeedState_Forward(gfGhoul_SpeedRun);
		mpMover.SetSpeedState_TurnMaxSpeed(6);
		mpMover.SetSpeedState_TurnSpeedMul(12);
		mpMover.SetSpeedState_TurnBreakMul(2);
		
		mpMover.AddSpeedState(eGhoulSpeed_FastRun);
		mpMover.SetSpeedState_ForwardAcc(10);
		mpMover.SetSpeedState_ForwardDeacc(5);
		mpMover.SetSpeedState_Forward(10);
		mpMover.SetSpeedState_TurnMaxSpeed(15);
		mpMover.SetSpeedState_TurnSpeedMul(15);
		mpMover.SetSpeedState_TurnBreakMul(2);
		
		mpMover.AddSpeedState(eGhoulSpeed_Lunge);
		mpMover.SetSpeedState_Forward(6.7);
		mpMover.SetSpeedState_TurnMaxSpeed(6);
		mpMover.SetSpeedState_TurnSpeedMul(12);
		mpMover.SetSpeedState_TurnBreakMul(2);

		mpMover.AddSpeedState(eGhoulSpeed_Stopped);
		mpMover.SetSpeedState_Forward(0.0);

		mpMover.AddSpeedState(eGhoulSpeed_TurnDuringAttack);
		mpMover.SetSpeedState_Forward(0.1);
		mpMover.SetSpeedState_TurnMaxSpeed(12);
		mpMover.SetSpeedState_TurnSpeedMul(12);
		mpMover.SetSpeedState_TurnBreakMul(2);
		
		mpMover.AddSpeedState(eGhoulSpeed_QuickAccelRun);
		mpMover.SetSpeedState_Forward(gfGhoul_SpeedRun);
		mpMover.SetSpeedState_TurnMaxSpeed(6);
		mpMover.SetSpeedState_TurnSpeedMul(12);
		mpMover.SetSpeedState_TurnBreakMul(2);
		mpMover.SetSpeedState_ForwardAcc(200);
		
		///////////////////////////////
		//Edge glow
//		float fEdgeGlowAmount = 0.3f;//apInstanceVars.GetVarFloat("EdgeGlowAmount", 1.0f);
//		if(fEdgeGlowAmount>0)
//		{
//			//cLux_AddDebugMessage("EDGEGLOW: "+fEdgeGlowAmount);
//			@mpEdgeGlow = cLux_CreateEntityComponent_EdgeGlow(mBaseObj);
//			mpEdgeGlow.SetColor(cColor(0.1,0.25,0.25));
//			mpEdgeGlow.SetLightLimit(0.8f);
//			mpEdgeGlow.SetAlpha(fEdgeGlowAmount);
//			mpEdgeGlow.SetEdgeThickness(0.2f);
//		}

		/////////////////////////////////
		// Attack Damage
		@mpAttackDamage = cLux_CreateEntityComponent_AttackDamage(mBaseObj);

		mpAttackDamage.AddType(0,"Default");
		mpAttackDamage.SetType_Damage(0.35, 0.6);
		mpAttackDamage.SetType_DamageType(eDamageType_Silent);
		mpAttackDamage.SetType_Affects(true, false, true);
		mpAttackDamage.SetType_AddShapeAtSocket("socket_lefthand_damage",0, 1.25);
		mpAttackDamage.SetType_AddShapeFromCenter(cVector3f(0,0,1), 1.5f);

		float fCloseAttackRadius = 1.55f;
		float fCloseAttackCenterRadius = 1.9f;
		float fAttackForce = 400;

		mpAttackDamage.AddType(1,"CloseAttackL");
		mpAttackDamage.SetType_Damage(0.4, 0.4);
		mpAttackDamage.SetType_DamageType(eDamageType_Silent);
		mpAttackDamage.SetType_Affects(true, false, true);
		mpAttackDamage.SetType_Force(fAttackForce, 1);
		mpAttackDamage.SetType_AddShapeAtSocket("socket_lefthand_damage",0, fCloseAttackRadius);
		mpAttackDamage.SetType_AddShapeFromCenter(cVector3f(0,0,1), fCloseAttackCenterRadius);
		
		mpAttackDamage.AddType(2,"CloseAttackR");
		mpAttackDamage.SetType_Damage(0.4, 0.4);
		mpAttackDamage.SetType_DamageType(eDamageType_Silent);
		mpAttackDamage.SetType_Affects(true, false, true);
		mpAttackDamage.SetType_Force(fAttackForce, 1);
		mpAttackDamage.SetType_AddShapeAtSocket("socket_righthand_damage",0, fCloseAttackRadius);
		mpAttackDamage.SetType_AddShapeFromCenter(cVector3f(0,0,1), fCloseAttackCenterRadius);
		
		mpAttackDamage.AddType(3,"WeakAttackLeft");
		mpAttackDamage.SetType_Damage(0.125, 0.3);
		mpAttackDamage.SetType_DamageType(eDamageType_Silent);
		mpAttackDamage.SetType_Force(fAttackForce * 0.75, 1);
		mpAttackDamage.SetType_Affects(true, false, true);
		mpAttackDamage.SetType_AddShapeAtSocket("socket_lefthand_damage",0, fCloseAttackRadius);
		mpAttackDamage.SetType_AddShapeFromCenter(cVector3f(0,0,1), fCloseAttackCenterRadius);
		
		mpAttackDamage.AddType(4,"WeakAttackRight");
		mpAttackDamage.SetType_Damage(0.125, 0.3);
		mpAttackDamage.SetType_DamageType(eDamageType_Default);
		mpAttackDamage.SetType_Force(fAttackForce * 0.75, 1);
		mpAttackDamage.SetType_Affects(true, false, true);
		mpAttackDamage.SetType_AddShapeAtSocket("socket_righthand_damage",0, fCloseAttackRadius);
		mpAttackDamage.SetType_AddShapeFromCenter(cVector3f(0,0,1), fCloseAttackCenterRadius);
		
		//////////////////////////////////
		// Bark Machine
		@mpBarkMachine = cLux_CreateEntityComponent_BarkMachine(mBaseObj);
		msVoiceCharacter = apInstanceVars.GetVarString("VoiceCharacter", "");
		mbUseVoice = apInstanceVars.GetVarBool("UseVoice", true);
		mpBarkMachine.SetupVoice(msVoiceCharacter, true, 5.0f, 40.0f, 40.0f);
		cVector2f vMinMax;
		
		msAlertSubject = apInstanceVars.GetVarString("AlertSubject", "");
		msRetreatSubject = apInstanceVars.GetVarString("RetreatSubject", "");
		msEmergeSubject = apInstanceVars.GetVarString("EmergeSubject", "");
		msSmellSubject = apInstanceVars.GetVarString("SmellSubject", "");
		msEndSearchSubject = apInstanceVars.GetVarString("EndSearchSubject", "");
		msCheckLastKnownPositionSubject = apInstanceVars.GetVarString("CheckLastKnownPositionSubject", "");
		msHitByObjectSubject = apInstanceVars.GetVarString("HitByObjectSubject", "");
		
		mpBarkMachine.AddState(eGhoulBark_Silent);
		
		mpBarkMachine.AddState(eGhoulBark_Wander);
		vMinMax = apInstanceVars.GetVarVector2f("WanderMinMaxTime", cVector2f(10, 15));
		mpBarkMachine.SetState_VoiceBark(apInstanceVars.GetVarString("WanderSubject", ""), vMinMax.x, vMinMax.y, true);
		
		mpBarkMachine.AddState(eGhoulBark_Search);
		vMinMax = apInstanceVars.GetVarVector2f("SearchMinMaxTime", cVector2f(10, 15));
		mpBarkMachine.SetState_VoiceBark(apInstanceVars.GetVarString("SearchSubject", ""), vMinMax.x, vMinMax.y, true);
		
		mpBarkMachine.AddState(eGhoulBark_EatMeat);
		vMinMax = apInstanceVars.GetVarVector2f("EatMeatMinMaxTime", cVector2f(10, 15));
		mpBarkMachine.SetState_VoiceBark(apInstanceVars.GetVarString("EatMeatSubject", ""), vMinMax.x, vMinMax.y, true);
		

		//////////////////////////////////
		// Meat Sensor
		@mpMeatSensor = UserComponent_AIMeatSensor_Create(mBaseObj);

		//////////////////////////////////
		// Player Notify
		@mpPlayerNotify = UserComponent_AIPlayerNotify_Create(mBaseObj);
		
		//////////////////////////////////
        // Fear component
		mFearParams.m_idEntity = mBaseObj.GetID();
		mFearParams.mfBaseFearRate = mfFearDefault;
		mFearParams.mfSurpriseFactor = gfFear_SurpriseEffect;
		mFearParams.mfLookAtFactor = 0.3f;
		mFearParams.mfMinFearDist = gfMinFearDistance;
		mFearParams.mfActivationDistance = gfMinFearDistance;
		mFearParams.mfDeactivationDistance = 30.0f;
		mFearParams.mfActivationDelay = 0.3f;
		mFearParams.mfActivationLightLevel = -1.0f;
		mFearParams.mbLookAtDetectWholeArea = false;
		
		mFearParams.mfMaxFearDist = gfMaxFearDistance;
	}

	//------------------------------------------------------------

	void OnAfterWorldLoad()
	{
		cScrAgentHumanoid::OnAfterWorldLoad();
		
		BuildRetreatAreaArray();
		mlGhoulHoleNetworkId = Blackboard_RegisterGhoulHoleNetwork(mBaseObj.GetMap(), msHoleNetwork, msPlayerPath, msHoleConnections);

		if (mBaseObj.IsActive())
		{
			Blackboard_AddEnemy(mBaseObj.GetID());			
		}
	}
	
	//------------------------------------------------------------
	
	void OnStart()
	{		
		RegisterWithFearHandler();
	}
	
	//------------------------------------------------------------

	//} END Loading

	//------------------------------------------------------------

	/////////////////////////////////////////
	// GENERAL
	//{///////////////////////////////////////

	//------------------------------------------------------------
	
	cVector3f vFwdAvg;
	void OnUpdate(float afTimeStep)
	{
		cScrAgentHumanoid::OnUpdate(afTimeStep);
		if(mBaseObj.IsActive()==false) return;

		if (mbStarted == false)
		{
			mbStarted = true;
			OnStart();
		}
			
		if (cLux_ScriptDebugOn())
		{
			UpdateTestPoints(afTimeStep);
			UpdateTestRays(afTimeStep);
		}
		
		UpdateCheckLos(afTimeStep);
		UpdateDistanceCallbacks(afTimeStep);
		UpdateMoved(afTimeStep);
//		UpdateLoopingSounds(afTimeStep);
//		UpdateAwareness(afTimeStep);
		UpdatePlayerLandDetection(afTimeStep);
		UpdateProximityDetection(afTimeStep);

        mfTimeSinceLastSniff += afTimeStep;
	}
	
	//------------------------------------------------------------
	
	void OnVariableUpdate(float afTimeStep)
	{
		UpdateCheckObstacles(afTimeStep);
		UpdateSoundCounter(afTimeStep);
		UpdateProximityEvents(afTimeStep);
		UpdatePreAlertCounter(afTimeStep);
		UpdatePlayerRunningCounter(afTimeStep);
		UpdateFlashlightDetection(afTimeStep);

		if (mfPermafailInvulnerabilityTimer > 0 && FearHandler_GetIsPermaFailing() == false && cLux_GetPlayer().GetCurrentStateId() != ePlayerState_CutsceneAnimation)
		{
			mfPermafailInvulnerabilityTimer -= afTimeStep;
			if (mfPermafailInvulnerabilityTimer <= 0) mBaseObj.ResetPlayerDetectionState();
		}
	}

	//------------------------------------------------------------

	void ResetProperties()
	{
		cScrAgentHumanoid::ResetProperties();
	}

	//------------------------------------------------------------

	void OnSetActive(bool abX)
	{
		cScrAgentHumanoid::OnSetActive(abX);
		if (abX)
		{
			Blackboard_AddEnemy(mBaseObj.GetID());
			RegisterWithFearHandler();
			mBaseObj.Timer_Add("Timer_EnableFootstepSounds", 0.75, "OnTimer_EnableFootstepSounds");
		}
		else
		{
			mbFootstepSoundsActive = false;
			mfPermafailInvulnerabilityTimer = 0.f;
			
			Blackboard_RemoveGhoulHolesUsedBy(mBaseObj.GetID());
			Blackboard_SetAgentInvestigate(mBaseObj.GetID(), false);
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Terror_RemoveEnemy(mBaseObj.GetID());
			Blackboard_RemoveEnemy(mBaseObj.GetID());
			
			if (Blackboard_GetWraithStruggleOwner() == mBaseObj.GetID())
				Blackboard_SetWraithStruggleOwner(tID_Invalid);
			
			if (Sound_Exists("Smell_TrackingLoop")) Sound_Stop("Smell_TrackingLoop", 0.0f);
			if (Sound_Exists("WallMoveLoop")) Sound_Stop("WallMoveLoop", 0.0f);
			if (Sound_Exists("HoleActive")) Sound_Stop("HoleActive", 0.0f);
						
//			iLuxEntity@ pEnt = mBaseObj.GetMap().GetPlayerEntity();
//			if (pEnt !is null)
//			{
//				Music_RemoveDynamicTrack(pEnt.GetID());
//			}
			
			//Entity_Destroy(cLux_ID_Entity(m_idEyeLeft).GetName());
			//Entity_Destroy(cLux_ID_Entity(m_idEyeRight).GetName());
		}
	}
	
	//------------------------------------------------------------
	
	void OnTimer_EnableFootstepSounds(uint64 alID)
	{
		mbFootstepSoundsActive = true;
	}
	
	//------------------------------------------------------------
	
	void HitByProp(float afAmount, float afMass, iPhysicsBody @apBody, cLuxProp @apProp)
	{
		mvLastHitByPropPos = apBody.GetWorldPosition();
	}
	
	//------------------------------------------------------------

	///////////////////////////////////
	// This function will check if our ghoul is stuck and then broadcast a message
	// to ourself so we can catch that and handle on a per state basis if needed
	void UpdateCheckObstacles(float afTimeStep)
	{
		float fStuck = mpMover.GetStuckCounter();
		if (fStuck > 0.85f)
		{
			mBaseObj.BroadcastMessage(eCustomEntityMessage_StuckCounterHigh, null, mBaseObj.GetPosition(),0);
			mpMover.ResetStuckCounter();
		}
	}

	//------------------------------------------------------------

	///////////////////////////////////
	// This function will keep track of the amount of time since we have moved
	// Any state can then check if (mfMovedTimeout > someTime) to know that our
	// ghoul is stationary when it shouldn't be
	// TODO: figure out if needed
	void UpdateMoved(float afTimeStep)
	{
		mfMovedDistance = cMath_Vector3DistSqr(mBaseObj.GetPosition(),mvLastTrackedPosition);
		if (mfMovedDistance <= 0.0f)
			mfMovedTimeout += afTimeStep;
		else
		{
			mvLastTrackedPosition = mBaseObj.GetPosition();
			mfMovedTimeout = 0.0f;
		}
	}

	//------------------------------------------------------------

	void UpdateProximityEvents(float afTimeStep)
	{
		if (mfTimeSinceLastEvent < mfEventCooldown)
		{
			mfTimeSinceLastEvent += afTimeStep;
		}
	}
	
	//------------------------------------------------------------

	//} END GENERAL

	//} END MAIN FUNCTIONS

	//===========================================================

	//------------------------------------------------------------

	/////////////////////////////////////////
	// HELPERS
	//{//////////////////////////////////////

	//------------------------------------------------------------

	float GetDistanceTo(cVector3f avTarget, bool abUseFeetPos)
	{
		if (abUseFeetPos)
			return cVector3f(mBaseObj.GetCharBody().GetFeetPosition() - avTarget).Length();
		else
			return cVector3f(mBaseObj.GetCharBody().GetPosition() - avTarget).Length();
	}
	
	//------------------------------------------------------------
	
	tString SpeedStateToString(int alState)
	{
		switch (alState)
		{
			case eGhoulSpeed_Walk: return "walk";
			case eGhoulSpeed_FastWalk: return "fast walk";
			case eGhoulSpeed_Run: return "run";
			case eGhoulSpeed_FastRun: return "fast run";
			case eGhoulSpeed_Stopped: return "stopped";
			case eGhoulSpeed_Lunge: return "lunge";
			case eGhoulSpeed_TurnDuringAttack: return "turn during attack";
		}
		return "";
	}

	eGhoulSpeed StringToSpeedState(const tString& in asSpeed)
	{
		tString sSpeedString = cString_ToLowerCase(asSpeed);
		if (sSpeedString == "fastwalk") return eGhoulSpeed_FastWalk;
		if (sSpeedString == "run") return eGhoulSpeed_Run;
		if (sSpeedString == "fastrun") return eGhoulSpeed_FastRun;
		if (sSpeedString == "stopped") return eGhoulSpeed_Stopped;
		if (sSpeedString == "lunge") return eGhoulSpeed_Lunge;
		if (sSpeedString == "turnduringattack") return eGhoulSpeed_TurnDuringAttack;
		return eGhoulSpeed_Walk;
	}
	
	//------------------------------------------------------------
	
	tString StateToString(int alState)
	{
		switch (alState)
		{
			case eGhoulState_Idle: return "Idle";
			case eGhoulState_Wait: return "Wait";
			case eGhoulState_HideInHole: return "HideInHole";
			case eGhoulState_Emerge: return "Emerge";
			case eGhoulState_WanderToExitHole: return "WanderToExitHole";
			case eGhoulState_TrackSmell: return "TrackSmell";
			case eGhoulState_Sniff: return "Sniff";
			case eGhoulState_InvestigateSniff: return "InvestigateSniff";
			case eGhoulState_InvestigateSound: return "InvestigateSound";
			case eGhoulState_ReturnToHole: return "ReturnToHole";
			case eGhoulState_MoveTo: return "MoveTo";
			case eGhoulState_Patrol: return "Patrol";
			case eGhoulState_Hunt: return "Hunt";
			case eGhoulState_PostHunt: return "PostHunt";
			case eGhoulState_SearchForPlayer: return "SearchForPlayer";
			case eGhoulState_SearchArea: return "SearchArea";
			case eGhoulState_CheckLastKnownPosition: return "CheckLastKnownPosition";
			case eGhoulState_PlayerLightDetected: return "PlayerLightDetected";
			case eGhoulState_CheckGobo: return "CheckGobo";
			case eGhoulState_CheckFlashlightHit: return "CheckFlashlightHit";
			case eGhoulState_PlayerDetected: return "PlayerDetected";
			case eGhoulState_Alert: return "Alert";
			case eGhoulState_MovingAlert: return "MovingAlert";
			case eGhoulState_AttackLunge: return "AttackLunge";
			case eGhoulState_AttackClose: return "AttackClose";
			case eGhoulState_ThrowPlayer: return "ThrowPlayer";
			case eGhoulState_Struggle: return "Struggle";
			case eGhoulState_StruggleStandBy: return "StruggleStandBy";
			case eGhoulState_PostAttack: return "PostAttack";
			case eGhoulState_Stunned: return "Stunned";
			case eGhoulState_Enthralled: return "Enthralled";
			case eGhoulState_ThreateningApproach: return "ThreateningApproach";
			case eGhoulState_Stare: return "Stare";
            case eGhoulState_Guard: return "Guard";
			case eGhoulState_Trapped: return "Trapped";
			case eGhoulState_Blocked: return "Blocked";
			case eGhoulState_BlockedByProp: return "BlockedByProp";
			case eGhoulState_EnterDoor: return "EnterDoor";
			case eGhoulState_Retreat: return "Retreat";
			case eGhoulState_PostRetreat: return "PostRetreat";
			case eGhoulState_BreakDoor: return "BreakDoor";
			case eGhoulState_Stuck: return "Stuck";
			case eGhoulState_WanderArea: return "WanderArea";
			case eGhoulState_Attracted: return "Attracted";
			case eGhoulState_EatMeat: return "EatMeat";
			case eGhoulState_WakeUp: return "WakeUp";
			case eGhoulState_PostAttack_Retreat: return "PostAttack_Retreat";
			case eGhoulState_Debug: return "Debug";
			case eGhoulState_ProximityEvent_Talk: return "ProximityEvent_Talk";
			case eGhoulState_ProximityEvent_Fight: return "ProximityEvent_Fight";
			case eGhoulState_ProximityEvent_Follow: return "ProximityEvent_Follow";
			case eGhoulState_EnvironmentEvent_SimpleAnimation: return "EnvironmentEvent_SimpleAnimation";
		}
		return "";
	}
	
	//------------------------------------------------------------
	
	tString AlertStateToString(int alState)
	{
		switch (alState)
		{
			case eGhoulAlertState_None: return "None";
			case eGhoulAlertState_Alert: return "Alert";
			case eGhoulAlertState_Investigating: return "Investigating";
			case eGhoulAlertState_Hunting: return "Hunting";
		}
		return "";
	}
	
	//------------------------------------------------------------
	
	iLuxEntity@ GetClosestEntity(const array<iLuxEntity@> &in avEnts, const cVector3f &in avPos)
	{
		iLuxEntity@ pClosestEntity;
		float fClosestDist = -1;
		for (uint i = 0; i < avEnts.size(); ++i)
		{
			iLuxEntity@ pEnt = avEnts[i];
			float fDist = cMath_Vector3DistSqr(avPos, pEnt.GetPosition());
			if (fDist < fClosestDist || fClosestDist < 0)
			{
				fClosestDist = fDist;
				@pClosestEntity = pEnt;
			}
		}
		
		return pClosestEntity;
	}

	//------------------------------------------------------------
	
	void PlayRandomAnimation(const array<tString> &in avAnims, float afFadeTime = 0.3f, bool abLoop = false, bool abPlayTransition = true,  const tString &in asCallback = "")
	{
		if (avAnims.size() == 0) return;
		mpMover.PlayAnimation(avAnims[cMath_RandRectl(0, avAnims.size() - 1)], afFadeTime, abLoop, abPlayTransition, asCallback);
	}
	
	//------------------------------------------------------------
	
	tString ModeToString(int alMode)
	{
		switch (alMode)
		{
			case eGhoulMode_Idle: return "Idle";
			case eGhoulMode_Patrol: return "Patrol";
			case eGhoulMode_StalkThroughHoles: return "StalkThroughHoles";
			case eGhoulMode_Hunt: return "Hunt";
			case eGhoulMode_Trapped: return "Trapped";
			case eGhoulMode_Enthralled: return "Enthralled";
			case eGhoulMode_Guard: return "Guard";
		}
		return "";
	}

	eGhoulMode StringToMode(const tString &in asMode)
	{
		tString asModeString = cString_ToLowerCase(asMode);
		if (asModeString == "idle") return eGhoulMode_Idle;
		if (asModeString == "patrol") return eGhoulMode_Patrol;
		if (asModeString == "stalkthroughholes") return eGhoulMode_StalkThroughHoles;
		if (asModeString == "hunt") return eGhoulMode_Hunt;
		if (asModeString == "trapped") return eGhoulMode_Trapped;
		if (asModeString == "enthralled") return eGhoulMode_Enthralled;
		if (asModeString == "guard") return eGhoulMode_Guard;
		return eGhoulMode_Idle;
	}
	
	//------------------------------------------------------------
	
	tString CommandToString(int alCommand)
	{
		switch (alCommand)
		{
			case eGhoulCommand_None: return "None";
			case eGhoulCommand_Patrol: return "Patrol";
			case eGhoulCommand_GoToHole: return "GoToHole";
			case eGhoulCommand_EmergeFromHole: return "EmergeFromHole";
			case eGhoulCommand_Retreat: return "Retreat";
			case eGhoulCommand_UseDoor: return "BreakDoor";
			case eGhoulCommand_Smell: return "Smell";
			case eGhoulCommand_WakeUp: return "WakeUp";
			case eGhoulCommand_ThreatenPlayer: return "ThreatenPlayer";
		}
		return "";
	}
	
	eGhoulCommand StringToCommand(const tString &in asCommand)
	{
		tString asCommandString = cString_ToLowerCase(asCommand);
		if (asCommandString == "none") return eGhoulCommand_None;
		if (asCommandString == "patrol") return eGhoulCommand_Patrol;
		if (asCommandString == "gotohole") return eGhoulCommand_GoToHole;
		if (asCommandString == "emergefromhole") return eGhoulCommand_EmergeFromHole;
		if (asCommandString == "retreat") return eGhoulCommand_Retreat;
		if (asCommandString == "breakdoor") return eGhoulCommand_UseDoor;
		if (asCommandString == "smell") return eGhoulCommand_Smell;
		if (asCommandString == "wakeup") return eGhoulCommand_WakeUp;
		if (asCommandString == "threatenplayer") return eGhoulCommand_ThreatenPlayer;
		return eGhoulCommand_None;
	}
	
	//------------------------------------------------------------
	
	cVector3f GetFeetPosition()
	{
		cVector3f vFeet = mBaseObj.GetPosition();
		vFeet.y -= mBaseObj.GetCharBody().GetSize().y / 2.0f;
		vFeet.y += 0.1f;
		return vFeet;
	}
	
	//------------------------------------------------------------
	
	void ExecuteNoArgCallback(const tString &in asFunc)
	{
		if (asFunc == "") return;
		
		tString sMethodName = "void " + asFunc + "()";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.ScriptExecute();
		}
	}
	
	void ExecuteEntityCallback(const tString &in asFunc)
	{
		if (asFunc == "") return;
		
		tString sMethodName = "void " + asFunc + "(const tString &in asEntity)";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			tString sName = mBaseObj.GetName();
			pMap.SetArgString(0, sName);
			pMap.ScriptExecute();
		}
	}
	
	//------------------------------------------------------------
	
	bool mbRegisteredWithFearHandler = false;
	void RegisterWithFearHandler()
	{
		if (mbRegisteredWithFearHandler) return;
		mbRegisteredWithFearHandler = true;
		iScrFearHandler_Interface @pHandler = cast<iScrFearHandler_Interface>( cLux_GetUserModuleFromID(eModuleType_Custom_FearHandler) );
		pHandler.RegisterThreatAgent(mFearParams);
	}
	
	//------------------------------------------------------------

	//} END HELPERS

	//------------------------------------------------------------

	/////////////////////////////////////////
	// GLOBAL FUNCS
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	array<cVector3f> vTestNodes;
	int lTestNodesCountdown = 0;
	int mlDebug = 0;
	void _Global_DebugFunc()
	{
		
		mpStateMachine.ChangeState(eGhoulState_ThrowPlayer);
		return;
		cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] DEBUG");
		
		
		if (mlDebug == 0) mpMover.PlayAnimation("alert", 0.3, false, true);
		else if (mlDebug == 1) mpMover.PlayAnimation("aggressive_idle_stand", 0.3, true, true);
		
		++mlDebug;
		return;
		
			mBaseObj.SetSensesActive(false);
            Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
			mBaseObj.ResetPlayerDetectionState();
			mpMover.TurnToPos(mBaseObj.GetPlayerPos());
			mpStateMachine.ChangeState(eGhoulState_Idle);
		
//		PlayRandomAnimation(mvGhoulAnim_HitDoor);
		
//		mpStateMachine.ChangeState(eGhoulState_AttackLunge);
		
//		mBaseObj.GetMeshEntity().GetActorAnimController().PlayEmotion()
		
//		mvMoveTo_Goal = Player_GetPosition();
//		mpStateMachine.ChangeState(eGhoulState_MovingAlert);
//		mBaseObj.BroadcastMessage(eCustomEntityMessage_StuckCounterHigh, null, mBaseObj.GetPosition(),0);
//		mpMover.ResetStuckCounter();
		
//		Sound_CreateAtEntity("Smell_TrackingLoop", gsGhoulSound_SmellTrackingLoop, mBaseObj.GetName());
		
//		mBaseObj.RevealPlayerPos();
//		mpStateMachine.ChangeState(eGhoulState_CheckLastKnownPosition);
		
//		mvEnthralled_Pos = Map_GetEntity("doors_begin_2").GetPosition();
//		mbEnthralled_FaceDir = true;
//		mbEnthralled_WalkToPos = false;
//		mpStateMachine.ChangeState(eGhoulState_Enthralled);
		
//		iLuxEntity@ pEnt = Map_GetEntity("damage");
//		
//		cMatrixf asdf = cMatrixf_Identity;
//		asdf.SetTranslation(pEnt.GetPosition());
//		
//		iCollideShape@ pExplosionColl = cLux_GetCurrentMap().GetPhysicsWorld().CreateSphereShape(4.0f, cMatrixf_Identity);
//		
//		cLux_ShapeDamage(pExplosionColl, pEnt.GetMatrix(), pEnt.GetPosition(), 0.5f, 200.0f, 2000.0f, 0, 0.f, 
//						 eDamageType_Default, false, true, true, true, mBaseObj.GetID(),  cLux_GetCurrentMap().GetNewAttackInstanceID());
	}

	int mlAttackCloseIndex = 0;
	void _Global_AnimAttack()
	{
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_TurnDuringAttack);
		
		tString sAttack = msAttackAnimName + "_" + (mlAttackCloseIndex + 1);
		++mlAttackCloseIndex;
		mlAttackCloseIndex %= mlNumAttackAnims;
		
		mBaseObj.PlaySound("AttackSound", gsGhoulSound_Attack, true, true);
		mpMover.PlayAnimation(sAttack, 0.1f, false, false, "");
	}
	
	void _Global_DebugFunc2()
	{
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
	}
	
	void _Global_DebugMoveTo()
	{
		cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] DEBUG");
//		mpMover.SetSpeedState(eGhoulSpeed_Run);
		cVector3f vGoal = cScript_GetGlobalArgVector3f(0);
		mpPathfinder.MoveTo(vGoal, 1.0f, false);
	}
	
	void _Global_HideInHoleFollow()
	{
		mbHideInHole_FollowPlayer = cScript_GetGlobalArgBool(0);
		if (mpStateMachine.GetCurrentState() == eGhoulState_HideInHole)
		{
			HideInHole_StopTimers();
			State_HideInHole_Enter();
		}
		else
		{
			mpStateMachine.ChangeState(eGhoulState_HideInHole);
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_Mode_Set()
	{
		mMode = eGhoulMode(cScript_GetGlobalArgInt(0));
		
		mbModeOverrideSenses = false;
		if (mMode == eGhoulMode_Hunt)
		{
			mbModeOverrideSenses = true;
			mbModeSensesActive = false;
		}
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(1);
		if (bForce) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_ModePatrol_Setup()
	{
		++mlPatrol_InstanceCounter;
		mPatrol_ModeInstance.mlId = mlPatrol_InstanceCounter;
		mPatrol_ModeInstance.mlLoopCount = -1;
		mPatrol_ModeInstance.mbRandom = cScript_GetGlobalArgBool(0);
		mPatrol_ModeInstance.mSpeed = eGhoulSpeed(cScript_GetGlobalArgInt(1));
		mPatrol_ModeInstance.msEndOfPatrolCallback = cScript_GetGlobalArgString(2);
	}
	
	void _Global_ModePatrol_AddNode()
	{
		cGhoulPatrolNode newNode;
		newNode.msName = cScript_GetGlobalArgString(0);
		newNode.mfMinWaitTime = cScript_GetGlobalArgFloat(1);
		newNode.mfMaxWaitTime = cScript_GetGlobalArgFloat(2);
		newNode.msAnimName = cScript_GetGlobalArgString(3);
		newNode.mbLoopAnim = cScript_GetGlobalArgBool(4);
		
		mPatrol_ModeInstance.mvNodes.push_back(newNode);
	}
	
	void _Global_ModePatrol_ClearNodes()
	{
		mPatrol_ModeInstance.mvNodes.resize(0);
	}
	
	void _Global_ModePatrol_SetSpeed()
	{
		mPatrol_ModeInstance.mSpeed = eGhoulSpeed(cScript_GetGlobalArgInt(0));
		if (mpStateMachine.GetCurrentState() == eGhoulState_Patrol)
		{
			mpMover.SetSpeedState(mPatrol_CurrentInstance.mSpeed);
			mPatrol_CurrentInstance.mSpeed = mPatrol_ModeInstance.mSpeed;
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_ModeEnthralled_Setup()
	{
        iLuxEntity @pEnt = cLux_GetCurrentMap().GetEntityByName(cScript_GetGlobalArgString(0));           
		mvEnthralled_LookAtPos = pEnt !is null ? pEnt.GetPosition() : mBaseObj.GetPosition();
        
        @pEnt = cLux_GetCurrentMap().GetEntityByName(cScript_GetGlobalArgString(1));           
		mvEnthralled_StandPos = pEnt !is null ? pEnt.GetPosition() : mBaseObj.GetPosition();
        
        msEnthralled_IdleAnim = cScript_GetGlobalArgString(2);
	}
	
	//------------------------------------------------------------
	
	void _Global_ModeStalkThroughHoles_Setup()
	{
		msHoleNetwork = cScript_GetGlobalArgString(0);
		msPlayerPath = cScript_GetGlobalArgString(1);
		msHoleConnections = cScript_GetGlobalArgString(2);
		mbHideInHole_HideUntilDisturbed = cScript_GetGlobalArgBool(3);
		mlGhoulHoleNetworkId = Blackboard_RegisterGhoulHoleNetwork(mBaseObj.GetMap(), msHoleNetwork, msPlayerPath, msHoleConnections);
	}
	
	//------------------------------------------------------------
	
	void _Global_ModeGuard_Setup()
	{
        iLuxEntity @pEnt = cLux_GetCurrentMap().GetEntityByName(cScript_GetGlobalArgString(0));           
		mvGuard_LookAtPos = pEnt !is null ? pEnt.GetPosition() : mBaseObj.GetPosition();
        
        @pEnt = cLux_GetCurrentMap().GetEntityByName(cScript_GetGlobalArgString(1));           
		mvGuard_StandPos = pEnt !is null ? pEnt.GetPosition() : mBaseObj.GetPosition();
        
        msGuard_IdleAnim = cScript_GetGlobalArgString(2);
        msGuard_IdleSound = cScript_GetGlobalArgString(3);
		msGuard_DisturbAnim = cScript_GetGlobalArgString(4);
		mlGuard_SpeedState = cScript_GetGlobalArgInt(5);
	}
	
	//------------------------------------------------------------
	
	void _Global_ModeRandomWanderArea_Setup()
	{
		mvWanderArea_AreaCenter = cScript_GetGlobalArgVector3f(0);
		mfWanderArea_MinRadius = cScript_GetGlobalArgFloat(1);
		mfWanderArea_MaxRadius = cScript_GetGlobalArgFloat(2);
		mfWanderArea_Time = -1.0f;
	}
	
	//------------------------------------------------------------
	
	void _Global_Command_Remove()
	{
		mCommand = eGhoulCommand_None;
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(0);
		if (bForce) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_CommandPatrol_AddNode()
	{
		cGhoulPatrolNode newNode;
		newNode.msName = cScript_GetGlobalArgString(0);
		newNode.mfMinWaitTime = cScript_GetGlobalArgFloat(1);
		newNode.mfMaxWaitTime = cScript_GetGlobalArgFloat(2);
		newNode.msAnimName = cScript_GetGlobalArgString(3);
		newNode.mbLoopAnim = cScript_GetGlobalArgBool(4);
		
		mPatrol_CommandInstance.mvNodes.push_back(newNode);
	}
	
	void _Global_CommandPatrol_ClearNodes()
	{
		mPatrol_CommandInstance.mvNodes.resize(0);
	}
	
	void _Global_CommandPatrol_SetSpeed()
	{
		mPatrol_CommandInstance.mSpeed = eGhoulSpeed(cScript_GetGlobalArgInt(0));
		if (mpStateMachine.GetCurrentState() == eGhoulState_Patrol)
		{
			mpMover.SetSpeedState(mPatrol_CurrentInstance.mSpeed);
			mPatrol_CurrentInstance.mSpeed = mPatrol_CommandInstance.mSpeed;
		}
	}
	
	void _Global_CommandPatrol_Execute()
	{
		mbPatrol_SmellPatrol = false;
		ExecutePatrol(cScript_GetGlobalArgBool(0), cScript_GetGlobalArgInt(1), cScript_GetGlobalArgBool(2), cScript_GetGlobalArgInt(3), cScript_GetGlobalArgString(4));
	}
	
	void _Global_CommandSmellPatrol_Execute()
	{
		mbPatrol_SmellPatrol = true;
		ExecutePatrol(cScript_GetGlobalArgBool(0), cScript_GetGlobalArgInt(1), cScript_GetGlobalArgBool(2), cScript_GetGlobalArgInt(3), cScript_GetGlobalArgString(4));
	}
	
	void ExecutePatrol(bool abForce, int alLoopCount, bool abrandom, int alSpeed, const tString &in asEndOfPatrolCallback)
	{
		mCommand = eGhoulCommand_Patrol;
		
		++mlPatrol_InstanceCounter;
		mPatrol_CommandInstance.mlId = mlPatrol_InstanceCounter;
		mPatrol_CommandInstance.mlLoopCount =  alLoopCount;
		mPatrol_CommandInstance.mbRandom = abrandom;
		mPatrol_CommandInstance.mSpeed = eGhoulSpeed(alSpeed);
		mPatrol_CommandInstance.msEndOfPatrolCallback = asEndOfPatrolCallback;
		
		mPatrol_NextInstance = mPatrol_CommandInstance;
		mPatrol_CommandInstance = cGhoulPatrol();
		mlPatrol_CurrentLoop = 1;
				
		bool bForce = CanForceStateChange() && abForce;
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Patrol) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------

	void _Global_CommandRetreat_Execute()
	{
		mCommand = eGhoulCommand_Retreat;
		
		mbRetreat_CommandCalculatePos = cScript_GetGlobalArgBool(1);
		mvRetreat_CommandRetreatToPos = cScript_GetGlobalArgVector3f(2);
		msCommandCompletedCallback = cScript_GetGlobalArgString(3);
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(0);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_CommandGoToSpecificHole_Execute()
	{
		tString sHole = cScript_GetGlobalArgString(1);
		iLuxEntity@ pEnt = Map_GetEntity(sHole);
		if (pEnt is null) return;
		
		if (mpStateMachine.GetCurrentState() == eGhoulState_HideInHole)
		{
			WallMoveTo(pEnt.GetID());
			return;
		}
		
		mCommand = eGhoulCommand_GoToHole;
		m_idReturnToHole_CommandHole = pEnt.GetID();
		mReturnToHole_CommandSpeed = eGhoulSpeed(cScript_GetGlobalArgInt(2));
		msCommandCompletedCallback = cScript_GetGlobalArgString(3);
		mbReturnToHole_CommandDeactivateAfter = cScript_GetGlobalArgBool(5);
		
		bool bInstant = cScript_GetGlobalArgBool(4);
		if (bInstant)
		{
			SetHidden(true);
			m_idHideInHole_Hole = pEnt.GetID();
			PositionAtGhoulHole(m_idHideInHole_Hole);
			mpStateMachine.ChangeState(eGhoulState_HideInHole);
			return;
		}
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(0);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	void _Global_CommandGoToHole_Execute()
	{
		cVector3f vPos = cScript_GetGlobalArgVector3f(0);
		bool bClosest = cScript_GetGlobalArgBool(3);
		float fMinRadius = cScript_GetGlobalArgFloat(4);
		float fMaxRadius = cScript_GetGlobalArgFloat(5);
		bool bOnlyFree = cScript_GetGlobalArgBool(6);
		bool bOnlyOutOfPlayerSight = cScript_GetGlobalArgBool(7);
		
		tID idHole = tID_Invalid;
		if (bClosest) idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, vPos, fMinRadius, fMaxRadius, bOnlyFree, false, false, bOnlyOutOfPlayerSight);
		else idHole = Blackboard_GetRandomGhoulHole(mlGhoulHoleNetworkId, vPos, fMinRadius, fMaxRadius, bOnlyFree, false, false, bOnlyOutOfPlayerSight);
		
		iLuxEntity@ pEnt = cLux_ID_Entity(idHole);
		if (pEnt is null) return;
		
		if (mpStateMachine.GetCurrentState() == eGhoulState_HideInHole)
		{
			WallMoveTo(pEnt.GetID());
			return;
		}
		
		mCommand = eGhoulCommand_GoToHole;
		m_idReturnToHole_CommandHole = pEnt.GetID();
		mReturnToHole_CommandSpeed = eGhoulSpeed(cScript_GetGlobalArgInt(2));
		msCommandCompletedCallback = cScript_GetGlobalArgString(8);
		mbReturnToHole_CommandDeactivateAfter = cScript_GetGlobalArgBool(10);
		
		bool bInstant = cScript_GetGlobalArgBool(9);
		if (bInstant)
		{
			m_idHideInHole_Hole = pEnt.GetID();
			PositionAtGhoulHole(m_idHideInHole_Hole);
			mpStateMachine.ChangeState(eGhoulState_HideInHole);
			return;
		}
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(1);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_CommandEmergeFromHole_Execute()
	{
		tString sHole = cScript_GetGlobalArgString(1);
		iLuxEntity@ pEnt = Map_GetEntity(sHole);
		if (pEnt is null) return;
		
		mCommand = eGhoulCommand_EmergeFromHole;
		m_idEmerge_CommandHole = pEnt.GetID();
		msCommandCompletedCallback = cScript_GetGlobalArgString(2);
		
		msEmerge_CustomAnim = cScript_GetGlobalArgString(3);
		msEmerge_CustomEmergeEntity = cScript_GetGlobalArgString(4);
		
		if (mpStateMachine.GetCurrentState() == eGhoulState_HideInHole)
		{
			Emerge(pEnt.GetID(), 0.0f);
			return;
		}
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(0);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_CommandUseDoor_Execute()
	{
		tString sDoorName = cScript_GetGlobalArgString(0);
		cLuxProp@ pProp = Map_GetProp(sDoorName);
		if (pProp is null || pProp.GetIsDoor() == false) return;
		
		bool bBreak = cScript_GetGlobalArgBool(1);
		if (bBreak) m_idBlockedByProp_ForcedBreak = pProp.GetID();
		
		mCommand = eGhoulCommand_UseDoor;
		mvMoveTo_CommandGoal = pProp.GetPosition();
		mMoveTo_CommandSpeed = eGhoulSpeed(cScript_GetGlobalArgInt(3));
		msCommandCompletedCallback = cScript_GetGlobalArgString(4);
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(2);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_CommandSmell_Execute()
	{
		mCommand = eGhoulCommand_Smell;
		msCommandCompletedCallback = cScript_GetGlobalArgString(1);
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(0);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_CommandWakeUp_Execute()
	{
		mCommand = eGhoulCommand_WakeUp;
		msWakeUp_Anim = cScript_GetGlobalArgString(1);
		msCommandCompletedCallback = cScript_GetGlobalArgString(2);
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(0);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void _Global_CommandThreatenPlayer_Execute()
	{
		mCommand = eGhoulCommand_ThreatenPlayer;
		msCommandCompletedCallback = cScript_GetGlobalArgString(4);
		
		mlThreateningApproach_AggressivenessLevel = cScript_GetGlobalArgInt(1);
		mbThreateningApproach_Gestures = cScript_GetGlobalArgBool(2);
		mbThreateningApproach_AdjustSpeed = cScript_GetGlobalArgBool(3);
		mfThreateningApproach_MinSpeedDist = cScript_GetGlobalArgFloat(5);
		mfThreateningApproach_MaxSpeedDist = cScript_GetGlobalArgFloat(6);
		
		bool bForce = CanForceStateChange() && cScript_GetGlobalArgBool(0);
		if (bForce || mpStateMachine.GetCurrentState() == eGhoulState_Retreat) mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	void _Global_CommandThreatenPlayer_SetAggressiveness()
	{
		mlThreateningApproach_AggressivenessLevel = cScript_GetGlobalArgInt(0);
		ThreateningApproach_SetAggressiveness(mlThreateningApproach_AggressivenessLevel);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetCallback_EmergeCompleted()
	{
		msEmerge_CompletedCallback = cScript_GetGlobalArgString(0);
		mbEmerge_CompletedCallbackAutoRemove = cScript_GetGlobalArgBool(1);
	}
	
	void _Global_SetCallback_EnterHideInHole()
	{
		msHideInHole_EnterCallback = cScript_GetGlobalArgString(0);
		mbHideInHole_EnterCallbackAutoRemove = cScript_GetGlobalArgBool(1);
	}
	
    void _Global_SetCallback_EnterHunt()
    {
        msHunt_EnterCallback = cScript_GetGlobalArgString(0);
		mbHunt_EnterCallbackAutoRemove = cScript_GetGlobalArgBool(1);
    }
	
	 void _Global_SetCallback_EnterIdle()
    {
        msIdle_EnterCallback = cScript_GetGlobalArgString(0);
		mbIdle_EnterCallbackAutoRemove = cScript_GetGlobalArgBool(1);
    }
	
	void _Global_SetCallback_ThrowAnimationOver()
	{
		msThrowPlayer_AnimationOverCallback = cScript_GetGlobalArgString(0);
		mbThrowPlayer_AnimationOverCallbackAutoRemove = cScript_GetGlobalArgBool(1);
	}
		
	void _Global_SetCallback_Alerted()
	{
		msAlertedCallback = cScript_GetGlobalArgString(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetSuperHunt()
	{
		mbHunt_SuperHuntEnabled = cScript_GetGlobalArgBool(0);
	}
	
	void _Global_SetCanBeAttracted()
	{
		mbAttracted_Enabled = cScript_GetGlobalArgBool(0);
	}
	
	void _Global_GetCanBeAttracted()
	{
		bool bCanBeAttracted = !IsAggressive() && mfCannotBeAttractedTimer <= 0.0f && mbAttracted_Enabled == true;
		cScript_SetGlobalReturnBool(bCanBeAttracted);
	}
	
	void _Global_SetSmellingActive()
	{
		mbDetectSmell = cScript_GetGlobalArgBool(0);
	}
	
	void _Global_SetInstantKill()
    {
        mbAttack_InstantKill = cScript_GetGlobalArgBool(0);
    }
	
	void _Global_GetCurrentState()
	{
		cScript_SetGlobalReturnString(StateToString(mpStateMachine.GetCurrentState()));
	}
	
	void _Global_SetAdaptiveHuntSpeed()
    {
        mbHunt_AdaptiveSpeed = cScript_GetGlobalArgBool(0);
        mfHunt_AdaptiveSpeedTarDist = cScript_GetGlobalArgFloat(1);
    }
	
	void _Global_SetAdjustHuntSpeed()
	{
		mbHunt_AdjustSpeed = cScript_GetGlobalArgBool(0);
		mfHunt_AdjustSpeedMul = cScript_GetGlobalArgFloat(1);
	}
	
	void _Global_IsSuspicious()
    {
        int lState = mpStateMachine.GetCurrentState();
		cScript_SetGlobalReturnBool(lState == eGhoulState_Alert ||
									lState == eGhoulState_CheckFlashlightHit ||
									lState == eGhoulState_CheckGobo ||
                                    lState == eGhoulState_MovingAlert ||
                                    lState == eGhoulState_CheckLastKnownPosition ||
                                    lState == eGhoulState_InvestigateSniff ||
                                    lState == eGhoulState_InvestigateSound ||
                                    lState == eGhoulState_TrackSmell ||
                                    lState == eGhoulState_Sniff ||
                                    lState == eGhoulState_SearchForPlayer ||
									lState == eGhoulState_SearchArea ||
                                    lState == eGhoulState_PostHunt ||
									lState == eGhoulState_PlayerDetected ||
									lState == eGhoulState_PlayerLightDetected);
    }
	
	void _Global_GetStateIsAggressive()
	{
		cScript_SetGlobalReturnBool(IsAggressive());
	}
	
	void _Global_SetDetectFlashlight()
	{
		mbDetectFlashlight = cScript_GetGlobalArgBool(0);
	}
	
	void _Global_SetUseVoice()
	{
		mbUseVoice = cScript_GetGlobalArgBool(0);
	}
	
	void _Global_IsBlocked()
	{
		int lState = mpStateMachine.GetCurrentState();
		cScript_SetGlobalReturnBool(lState == eGhoulState_BreakDoor ||
									lState == eGhoulState_Blocked ||
									lState == eGhoulState_BlockedByProp);
	}
	
	void _Global_SetHoleNetwork()
	{
		msHoleNetwork = cScript_GetGlobalArgString(0);
		msPlayerPath = cScript_GetGlobalArgString(1);
		msHoleConnections = cScript_GetGlobalArgString(2);
		mlGhoulHoleNetworkId = Blackboard_RegisterGhoulHoleNetwork(mBaseObj.GetMap(), msHoleNetwork, msPlayerPath, msHoleConnections);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetCollisionCourseActive()
	{
		cScript_SetGlobalReturnBool(mbCollisionCourseDetection && IsAggressive() == false);
	}
	
	//------------------------------------------------------------
	
	void _Global_CanParticipateInEvent()
	{
		cScript_SetGlobalReturnBool(CanParticipateInEvent());
	}
	
	//------------------------------------------------------------
	
	void _Global_IsInEligibleStateForEvent()
	{
		cScript_SetGlobalReturnBool(EligibleStateForEvent(mpStateMachine.GetCurrentState()));
	}

	//------------------------------------------------------------

	void _Global_EatMeat()
	{
		cScript_GetGlobalArgString(0);
		mpStateMachine.ChangeState(eGhoulState_EatMeat);
	}
	
	//------------------------------------------------------------
	
	void _Global_GetNextProximityEvent()
	{
		if (mvProximityEvents.size() > 0)
		{
			float fRand = cMath_RandRectf(0.0f, 1.0f);
			float fProb = 0.0f;
			for (uint i = 0; i < mvProximityEvents.size(); ++i)
			{
				cAgentEvent@ pAgentEvent = mvProximityEvents[i];
				fProb += pAgentEvent.mfProbability;
				if (fRand <= fProb)
				{
					cScript_SetGlobalReturnInt(pAgentEvent.mEventType);
					return;
				}
			}
		}
		cScript_SetGlobalReturnInt(-1);
	}
	
	//------------------------------------------------------------
	
	int mlBackupRequestedState;
	cVector3f mlBackupRequestPos;
	bool mbBackupRequestsActive = true;
	
	void _Global_BlackboardBackupRequest()
	{
		if (mbBackupRequestsActive == false) return;
		
		mlBackupRequestPos = cScript_GetGlobalArgVector3f(0);
		mlBackupRequestedState = cScript_GetGlobalArgInt(1);
		
		if (mlBackupRequestedState == eGhoulState_CheckLastKnownPosition)
		{
			mvCheckLastKnownPosition_Goal = mlBackupRequestedState;
			mbCheckLastKnownPosition_FromBackupRequest = true;
			mpStateMachine.ChangeState(mlBackupRequestedState);
		}
		else if (mlBackupRequestedState == eGhoulState_InvestigateSound)
		{
			mvInvestigateSound_Goal = mlBackupRequestedState;
			mbInvestigateSound_CanRequestBackup = true;
			mfSoundCounter = 7.0f;
			mpStateMachine.ChangeState(mlBackupRequestedState);
		}
		else if (mlBackupRequestedState == eGhoulState_Hunt)
		{
			if (IsAggressive() || mpStateMachine.GetNextState() == eGhoulState_Hunt || mpStateMachine.GetCurrentState() == eGhoulState_StruggleStandBy) return;
			if (cMath_Vector3DistSqr(mlBackupRequestPos, mBaseObj.GetPosition()) > 4 * gfBlackboardMessageRange * gfBlackboardMessageRange) return;
			mBaseObj.Timer_Add("BackupResponseHuntTimer", cMath_RandRectf(0.0f, 0.5f), "BackupResponseHuntTimer");
		}
	}
	
	void BackupResponseHuntTimer(uint64 alID)
	{
		if (H64("BackupResponseHuntTimer") == alID)
		{
			mBaseObj.Timer_Add("BackupResponseHuntTimer2", cMath_RandRectf(0.1f, 1.5f), "BackupResponseHuntTimer");
			mpMover.TurnToPos(mlBackupRequestPos);
			return;
		}
		mpStateMachine.ChangeState(eGhoulState_Hunt);
	}
	
	//------------------------------------------------------------
	
	void _Global_BlackboardAgentBlockedByDoor()
	{
		cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] Another agent is already opening the door, standing back");
		
		mpPathfinder.Stop();
		mpStateMachine.StopTimer("Pursuit");
		mpStateMachine.AddTimer("Pursuit", cMath_RandRectf(1.5f, 2.5f));
		
		cVector3f vSourcePos = cScript_GetGlobalArgVector3f(0);
		cVector3f vAwayDir = mBaseObj.GetPosition() - vSourcePos;
		vAwayDir.y = 0;
		vAwayDir.Normalize();
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + vAwayDir * 2.5f, 0.0f, 2.0f, true, false, false, null);
		mpPathfinder.MoveTo(pNode.GetPosition(), 0.2f, false);
	}
	
	//------------------------------------------------------------
	
	void _Global_BlackboardProximityEvent()
	{
		mlProximityEventType = cScript_GetGlobalArgInt(0);
		mbProximityEventFirstAgent = cScript_GetGlobalArgBool(1);
		m_idProximityEventOtherAgent = cScript_GetGlobalArgID(2);
				
		if (mlProximityEventType < 0) return;
		
		switch (mlProximityEventType)
		{
			case eAgentProximityEvent_GhoulTalk: mpStateMachine.ChangeState(eGhoulState_ProximityEvent_Talk); break;
			case eAgentProximityEvent_GhoulFight: mpStateMachine.ChangeState(eGhoulState_ProximityEvent_Fight); break;
			case eAgentProximityEvent_GhoulFollow: mpStateMachine.ChangeState(eGhoulState_ProximityEvent_Follow); break;
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_BlackboardEnvironmentEvent()
	{
		m_idEnvironmentEventEntity = cScript_GetGlobalArgID(0);
		mlEnvironmentEventType = cScript_GetGlobalArgInt(1);
		
		switch (mlEnvironmentEventType)
		{
			case eAgentEnvironmentEvent_GhoulSearchGround: mpStateMachine.ChangeState(eGhoulState_EnvironmentEvent_SimpleAnimation); break;
			case eAgentEnvironmentEvent_GhoulInteractWithFetish: mpStateMachine.ChangeState(eGhoulState_EnvironmentEvent_SimpleAnimation); break;
			case eAgentEnvironmentEvent_GhoulEat: mpStateMachine.ChangeState(eGhoulState_EnvironmentEvent_SimpleAnimation); break;
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_ForcedFollow()
	{
		mlProximityEventType = eAgentProximityEvent_GhoulFollow;
		mbProximityEventFirstAgent = cScript_GetGlobalArgBool(0);
		m_idProximityEventOtherAgent = cScript_GetGlobalArgID(1);
		mbProximityEvent_Follow_MeetMidway = cScript_GetGlobalArgBool(2);
		mvProximityEvent_Follow_MeetPos = cScript_GetGlobalArgVector3f(3);
		mbProximityEvent_Follow_MoveToSpecificPos = cScript_GetGlobalArgBool(4);
		mvProximityEvent_Follow_MoveToPos = cScript_GetGlobalArgVector3f(5);
		mpStateMachine.ChangeState(eGhoulState_ProximityEvent_Follow);
	}
	
	//------------------------------------------------------------
	
	cVector3f mvPreCollisionGoal;
	void _Global_BlackboardOnCollisionCourse()
	{
		mpPathfinder.SetMoving(false);
		mBaseObj.Timer_Add("TimerEndCollisionWait", 5.0f, "TimerEndCollisionWait");
		mvPreCollisionGoal = mpPathfinder.GetGoalPos();
		
		cVector3f vAvoidPos = mBaseObj.GetPosition();
		vAvoidPos += mBaseObj.GetCharBody().GetRight() * -2.5f;
		vAvoidPos += mBaseObj.GetCharBody().GetForward() * 2.0f;
		mpPathfinder.MoveTo(vAvoidPos, 1.0f, false);
	}
	
	void _Global_BlackboardOnCollisionCourseEnd()
	{
		mBaseObj.Timer_Add("TimerEndCollisionWait", 2.0f, "TimerEndCollisionWait");
	}
	
	void TimerEndCollisionWait(uint64 alID)
	{
		if (IsAggressive()) return;
		mpPathfinder.SetMoving(true);
		mpPathfinder.MoveTo(mvPreCollisionGoal, 1.2f, true);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetAgentDefeaned()
	{
		bool bDeaf = cScript_GetGlobalArgBool(0);
		float fRecovery = cScript_GetGlobalArgFloat(1);
		
		if (mBaseObj.Timer_Exists("RecoverHearing"))
			mBaseObj.Timer_Remove("RecoverHearing");
				
		mbCurrentlyDeaf = bDeaf;
		
		if (fRecovery < 0) return;
		mBaseObj.Timer_Add("RecoverHearing", fRecovery, "Timer_RecoverHearing");
	}
	
	void Timer_RecoverHearing(uint64 alId)
	{
		cLux_AddDebugMessage("[agent] " + mBaseObj.GetName() + " -- Recovery of hearing to default value");
		mbCurrentlyDeaf = false;
	}
	
	//------------------------------------------------------------
	
	void _Global_SetDistanceCallback()
	{
		tString fFunc = cScript_GetGlobalArgString(0);
		float fDistance = cScript_GetGlobalArgFloat(1);
		
		for (uint i = 0; i < mDistanceCallbacks.size(); ++i)
		{
			cDistanceCallback@ pCallback = mDistanceCallbacks[i];
			if (pCallback.msFunction == "")
			{
				mDistanceCallbacks.removeAt(i);
				return;
			}
			if (pCallback.msFunction == fFunc && pCallback.mfDistance == fDistance) return;
		}
		
		cDistanceCallback newCallback;
		newCallback.msFunction = fFunc;
		newCallback.mfDistance = fDistance;
		
		mDistanceCallbacks.push_back(newCallback);
	}
	
	//------------------------------------------------------------
	
	void _Global_EnterLiquidArea()
	{
		mbIsInLiquid = true;
		mpMover.SetSpeedMul(0.5f);
		
		//////////////////
		// Sound
		tString sSound = cLux_GetUnderwaterEffectsActive() ? "creatures/foley/creature/ghoul/water/underwater/ghoul_enter_water_below" :
															 "creatures/foley/creature/ghoul/water/ghoul_enter_water_above";
		
		cSoundEntity@ pSound = mBaseObj.GetMap().GetWorld().CreateSoundEntity("Sound_EnterLiquid_" + mBaseObj.GetName(), sSound, true);
		pSound.SetScriptableIsSaved(false);
		pSound.SetWorldPosition(mBaseObj.GetCharBody().GetFeetPosition());
		
		/////////////////
		// Particles
		// (TEMP!)
		ParticleSystem_CreateAtEntity("PS_ExitLiquid_" + mBaseObj.GetName(), "splash_small_oneshot", mBaseObj.GetName(), false);
	}
	
	//------------------------------------------------------------
	
	void _Global_ExitLiquidArea()
	{
		mbIsInLiquid = false;
		mpMover.SetSpeedMul(1.f);
		
		//////////////////
		// Sound
		tString sSound = cLux_GetUnderwaterEffectsActive() ? "creatures/foley/creature/ghoul/water/underwater/ghoul_exit_water_below" :
															 "creatures/foley/creature/ghoul/water/ghoul_exit_water_above";
		
		cSoundEntity@ pSound = mBaseObj.GetMap().GetWorld().CreateSoundEntity("Sound_ExitLiquid_" + mBaseObj.GetName(), sSound, true);
		pSound.SetScriptableIsSaved(false);
		pSound.SetWorldPosition(mBaseObj.GetCharBody().GetFeetPosition());
		
		/////////////////
		// Particles
		// (TEMP!)
		ParticleSystem_CreateAtEntity("PS_ExitLiquid_" + mBaseObj.GetName(), "splash_small_oneshot", mBaseObj.GetName(), false);	
	}
	
	//------------------------------------------------------------
	
	void _Global_SetAllowPlayerThrow()
	{
		mbAllowPlayerThrow = cScript_GetGlobalArgBool(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetPlayerThrowForcedDirection()
	{
		mlThrowPlayer_ForcedDirection = cScript_GetGlobalArgInt(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_CancelPlayerThrow()
	{
		mbThrowPlayer_Cancel = cScript_GetGlobalArgBool(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetCanAttack()
	{
		mbCanAttack = cScript_GetGlobalArgBool(0);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetCustomWalkAnim()
	{
		tString sAnim = cScript_GetGlobalArgString(0);
		if (sAnim == "") msWalkAnim = msOrigWalkAnim;
		else			 msWalkAnim = sAnim;
		mpMover.SetWalkAnimName(msWalkAnim);
	}
	
	//------------------------------------------------------------

	//} END GLOBAL

	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// GHOUL SPECIFIC CODE
	//=======================================
	//{//////////////////////////////////////

	//===========================================================
	
	//------------------------------------------------------------
	
	void OnRecieveMessage(int alMessageId, cLuxEntityMessageData @apData)
	{
		
		if (alMessageId == eLuxEntityMessage_AnimationFootStep)
		{
			////////////////////////
			// Handle footsteps
			if (mbFootstepSoundsActive == false) return;
		
			tString sSoundPath = sFootstep_SoundPath;
			tString sSoundCategory = "";
			tString sSoundName = "";
			
			int lSpeedState = mpMover.GetSpeedState();
			bool bRunning = lSpeedState == eGhoulSpeed_Run || lSpeedState == eGhoulSpeed_FastRun || lSpeedState == eGhoulSpeed_Lunge;
			
			sSoundName = bRunning ? sFootstep_RunSound : sFootstep_WalkSound;
			
			///////////////////////
			// In water?
			if (mbIsInLiquid)
			{
                //Use ghoul water footsteps if in water
                sSoundPath = "creatures/foley/creature/ghoul/";
                sSoundName = "ghoul_walk";
				sSoundCategory = "water/";
				
				////////////////
				// Player submerged underwater?
				if (cLux_GetUnderwaterEffectsActive())
				{
					sSoundCategory = "water/underwater/";
					sSoundName += "_water_below";
				}
				else
				{
					sSoundName += "_water_above";
				}
			}
			
			////////////////////////////
			// Play sound!
			tString sSound = sSoundPath + sSoundCategory + sSoundName;
			cSoundEntity@ pSound = mBaseObj.GetMap().GetWorld().CreateSoundEntity("Sound_Footstep_" + mBaseObj.GetName(), sSound, true);
			
			if (pSound !is null)
			{
				///////////////////
				// Play at socket?
				tString sSocket = apData.msX;			
				cNode3D@ pSocket = mBaseObj.GetMeshEntity().GetSocket(apData.msX);
				
				if (pSocket !is null)
				{
					pSocket.AddEntity(pSound);
				}
				else
				{
					pSound.SetWorldPosition(mBaseObj.GetCharBody().GetFeetPosition());
				}
				
				pSound.SetScriptableIsSaved(false);
			}
		}
		else if (alMessageId == eLuxEntityMessage_AnimationMessageEvent && mbCutsceneAnimation_Active == false)
		{
			////////////////////////
			// Handle Animation message events
			switch(apData.mlX)
			{
				case eGhoulAnimationMessageEvent_GiveThrowDamage:
				{
					float fFearAfterHit = mbAttack_InstantKill ? 1 : (FearHandler_GetLevel() + mfThrowPlayer_Damage);
					
					if (mbAttack_InstantKill) Player_GiveDamage(1, 1.f, eDamageType_Thrown, mBaseObj.GetName());
					else Player_GiveDamage(mfThrowPlayer_Damage, 1.f, eDamageType_Thrown, mBaseObj.GetName()); 
					
					// TODO: temp
//					if (fFearAfterHit >= 1) FearHandler_TriggerPermaFail(true, mBaseObj.GetName());
					Player_GiveDamage(0.0f, 1.0f, eDamageType_Silent, mBaseObj.GetName());
					
					break;
				}
			}
		}
	}

	//------------------------------------------------------------
	
	///////////////////////////////////
	// GHOUL HELPERS
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbPlayerIsInLos = false;
	float mfPlayerLosCounter = 0.0f;
	
	void UpdateCheckLos(float afTimeStep)
	{
		mfPlayerLosCounter -= afTimeStep;
		if (mfPlayerLosCounter >= 0.0f) return;
		mfPlayerLosCounter = cMath_RandRectf(0.3, 0.6);
				
		mBaseObj.GetPlayerIsInLineOfSight("OnLosResult");
	}
	
	void OnLosResult(bool abSuccessful)
	{
		mbPlayerIsInLos = abSuccessful;
	}
	
	//------------------------------------------------------------
	
	float mfDistanceCallback_UpdateTimer = 0.1f;
	float mfDistanceCallback_PreviousDistance = 0.0f;
	void UpdateDistanceCallbacks(float afTimeStep)
	{
		if (mDistanceCallbacks.size() == 0) return;
		
		mfDistanceCallback_UpdateTimer -= afTimeStep;
		if (mfDistanceCallback_UpdateTimer > 0) return;
		
		mfDistanceCallback_UpdateTimer = cMath_RandRectf(0.08f, 0.12f);
		
		float fDist = mBaseObj.GetDistanceToPlayer();
		
		for (int i = 0; i < mDistanceCallbacks.size(); ++i)
		{
			cDistanceCallback@ pCallback = mDistanceCallbacks[i];
			if (fDist <= pCallback.mfDistance && mfDistanceCallback_PreviousDistance > pCallback.mfDistance)
			{
				ExecuteDistanceCallback(pCallback.msFunction, 1);
			}
			else if (fDist > pCallback.mfDistance && mfDistanceCallback_PreviousDistance <= pCallback.mfDistance)
			{
				ExecuteDistanceCallback(pCallback.msFunction, -1);
			}
		}
		
		mfDistanceCallback_PreviousDistance = fDist;
	}
	
	void ExecuteDistanceCallback(tString asFunc, int alState)
	{
		if (asFunc == "") return;
		
		tString sMethodName = "void " + asFunc + "(int alState)";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.SetArgInt(0, alState);
			pMap.ScriptExecute();
		}
	}
	
	//------------------------------------------------------------
	
	tString msGrowlLoopSoundName;
	float mfGrowlTargetVolume = 0.0f;

	tString msEatLoopSoundName;
	float mfEatTargetVolume = 0.0f;

	int mlLoopingSoundUpdates = -1;
	float mfGrowlTime=0.0f;
	
	void UpdateLoopingSounds(float afTimeStep)
	{
		mfGrowlTime += afTimeStep;

		if (mlLoopingSoundUpdates<0)
		{
			mlLoopingSoundUpdates = cMath_RandRectl(1,60);	// Stagger the updates (also this isn't a uint)
			return;
		}

		mlLoopingSoundUpdates++;
		if (mlLoopingSoundUpdates % 5 == 0)
			return;

		////////////////////////////
		// Growl
		if (msGrowlLoopSoundName == "")
		{
			msGrowlLoopSoundName = "sfx_" + mBaseObj.GetName() + "_growlloopsound";
		}

		if (Sound_Exists(msGrowlLoopSoundName)==false)
		{
			Sound_CreateAtEntity(msGrowlLoopSoundName, gsGhoulSound_GrowlLoop, mBaseObj.GetName(), 0.0f, false, 0.0f);
			return;	// early out so we don't create a whole bunch of sounds at once
		}
		else
		{
			Sound_Fade(msGrowlLoopSoundName,mfGrowlTargetVolume,0.5f);
		}

		////////////////////////////
		// Growl
		if (msEatLoopSoundName == "")
		{
			msEatLoopSoundName = "sfx_" + mBaseObj.GetName() + "_eatloopsound";
		}

		if (Sound_Exists(msEatLoopSoundName)==false)
		{
			Sound_CreateAtEntity(msEatLoopSoundName, gsGhoulSound_EatLoop, mBaseObj.GetName(), 0.0f, false, 0.0f);
			return; // early out so we don't create a whole bunch of sounds at once
		}
		else
		{
			Sound_Fade(msEatLoopSoundName,mfEatTargetVolume,0.5f);
		}
	}

	//------------------------------------------------------------

	void SetGrowlVolume(float afTargetVolume, float afTimeStep)
	{
		if (afTargetVolume > 0.0f)
		{
			afTargetVolume = afTargetVolume * cMath_Sin(mfGrowlTime);
			if (afTargetVolume < 0)
				afTargetVolume = 0;
		}

		mfGrowlTargetVolume = afTargetVolume;
	}
	
	//------------------------------------------------------------

	void SetEatVolume(float afTargetVolume)
	{
		mfEatTargetVolume = afTargetVolume;
	}

	//------------------------------------------------------------

	cVector3f mvBuildPathDebugMidpoint = cVector3f_Zero;
	
	bool BuildPathTowardPos(const cVector3f &in avPos, float afAmount, bool abDoMove)
	{
		cVector3f vFeetPostion = mBaseObj.GetCharBody().GetFeetPosition();

		//////////////////////////////////
		// Get the path and real length to goal pos.
		if(mpPathfinder.BuildPathNodeArrayToPos(avPos)==false)
		{
			cLux_AddDebugMessage("Could not build path!");
			return false;
		}

		float fFullDist = mpPathfinder.GetPathNodeArrayFullLength();
		float fWantedDist = fFullDist*afAmount - 0.001f; //Just offset a bit so it works when amount =1
		float fPrevDist = 0;
		float fDist =0;

		//////////////////////////////////
		// Get the node that comes after the wanted distance
		cAINode @pNode = null;
		int lIdx= -1;
		int lNodeCount = mpPathfinder.GetPathNodeArraySize();

		cLux_AddDebugMessage("Wanted Dist = " + fWantedDist + " Full Dist = " + fFullDist + " Node count = " + lNodeCount);

		/////////////////////////
		// For paths around corners
		if (lNodeCount > 1)
		{
			for(int i=0; i<lNodeCount; ++i)
			{
				@pNode = mpPathfinder.GetPathNodeArrayNode(i);

				fPrevDist = fDist;
				fDist = mpPathfinder.GetPathNodeArrayDist(i);

				if(fDist>=fWantedDist)
				{
					lIdx = i;
					cLux_AddDebugMessage("Got node at " + fDist);
					break;
				}
			}
		}

		////////////////////////
		// Straight line to point, so use midpoint
		else
		{
			float fMin = 1.0f;
			float fMax = 3.0f;
			cVector3f vMidPoint = (vFeetPostion+avPos)/2;
			@pNode = mpPathfinder.GetNodeAtPos(vMidPoint, fMin, fMax, false, false, false, null);
		}

		/////////////////////////////
		// No node found
		if(pNode is null)
		{
			Error("[Ghoul " + mBaseObj.GetName() + "] Pathnode was null after running BuildPathTowardPos - we likely did not find a nearby pathnode");
			return false;
		}

		/////////////////////////////////
		// Move to the pathnode if instructed to do so
		if(abDoMove && lIdx >= 0)
		{
			mvBuildPathDebugMidpoint = mpPathfinder.GetPathNodeArrayNode(lIdx).GetPosition();
			mpPathfinder.MoveTo(mpPathfinder.GetPathNodeArrayNode(lIdx).GetPosition(),1,false);
			return true;
		}

		return false;
	}

	//------------------------------------------------------------
	
	bool IsAttacking()
	{
		int lState = mpStateMachine.GetCurrentState();
		return lState == eGhoulState_AttackLunge ||
			   lState == eGhoulState_AttackClose ||
			   lState == eGhoulState_ThrowPlayer;
	}
	
	//------------------------------------------------------------

	bool IsAggressive()
	{
		int lState = mpStateMachine.GetCurrentState();
		return lState == eGhoulState_AttackClose ||
			   lState == eGhoulState_AttackLunge ||
			   lState == eGhoulState_ThrowPlayer ||
			   lState == eGhoulState_Struggle ||
			   lState == eGhoulState_Hunt;
	}
	
	//------------------------------------------------------------
	
	bool CanForceStateChange()
	{
		int lState = mpStateMachine.GetCurrentState();
		if (lState == eGhoulState_Struggle) return false;
		return true;
	}
	
	//------------------------------------------------------------
	
	bool IsAlert()
	{
		int lState = mpStateMachine.GetCurrentState();
		return lState == eGhoulState_Alert ||
				lState == eGhoulState_MovingAlert;
	}
	
	//------------------------------------------------------------
	
	bool IsStateProximityEvent(int alId)
	{
		for (int i = 0; i < mvProximityEvents.size(); ++i)
		{
			if (mvProximityEvents[i].mlStateId == alId)
			{
				return true;
			}
		}
		return false;
	}
	
	//------------------------------------------------------------
	
	bool CanParticipateInEvent()
	{
		int lState = mpStateMachine.GetCurrentState();
		return mfTimeSinceLastEvent >= mfEventCooldown && EligibleStateForEvent(lState);
	}
	
	//------------------------------------------------------------
	
	bool EligibleStateForEvent(int mlState)
	{
		return (mlState == eGhoulState_Idle ||
				mlState == eGhoulState_Patrol ||
				mlState == eGhoulState_PostRetreat ||
				mlState == eGhoulState_WanderArea ||
				mlState == eGhoulState_ReturnToHole ||
				mlState == eGhoulState_Wait ||
				mlState == eGhoulState_WanderToExitHole);
	}
	
	//------------------------------------------------------------
	
	cLuxArea@ GetClosestSpawn(cVector3f avPos, float afMinimumDistanceRequired=-1.0f)
	{
		tID idClosest = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, avPos, afMinimumDistanceRequired);
		return cLux_ID_Area(idClosest);
	}
	
	//------------------------------------------------------------

	void PositionAtGhoulHole(tID a_idGhoulHole)
	{
		cLuxArea@ pHole = cLux_ID_Area(a_idGhoulHole);
		if (pHole is null) return;
		
		cVector3f vNewPos = pHole.GetPosition();
		vNewPos += cVector3f_Down * pHole.GetSize().y / 2;
		
		mBaseObj.GetCharBody().SetFeetPosition(vNewPos, false);
		
		cVector3f vForward = cMath_MatrixMul(pHole.GetMatrix().GetRotation(), cVector3f(0, 0, 1));
		float fYaw = -cMath_GetAngleFromPoints2D(0, cVector2f(vForward.x, vForward.z));
		mBaseObj.GetCharBody().SetYaw(fYaw);
	}
	
	//------------------------------------------------------------
	
	bool IsPlayerInDeadEnd(float afMaxDeadEndSize = 15.0f)
	{
		lTestNodesCountdown = 1000;
		
		/////////////////////////////
		// Pick 4 directions from the player
		array<cVector3f> vDirs;
		vDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(45.0f)), mBaseObj.GetPlayerDir()));
		vDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-45.0f)), mBaseObj.GetPlayerDir()));
		vDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(135.0f)), mBaseObj.GetPlayerDir()));
		vDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-135.0f)), mBaseObj.GetPlayerDir()));
		
		int lValidNodes = 0;
		int lTooClosePaths = 0;
		
		vTestNodes.resize(0);
		
		for (int i = 0; i < vDirs.length(); ++i)
		{
			/////////////////////////////
			// Pick a direction from the player
			cVector3f vDir = vDirs[i];
			vDir.Normalize();
			
			/////////////////////////////
			// Get point along the direction
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPlayerPos() + vDir * afMaxDeadEndSize, 0.0f, 10.0f, true, false, false, null);
		
			if (pNode is null) continue;
			
			cVector3f vLosStart = mBaseObj.GetPlayerPos();
			vLosStart.y = 1;
			cVector3f vLosEnd = pNode.GetPosition();
			vLosEnd.y = 1;
			
			/////////////////////////////
			// If there is LOS to the point, it is within the room and will be ignored
			if (cLux_CheckLineOfSight(vLosStart, vLosEnd, true, true)) continue;
			
			++lValidNodes;
			
			vTestNodes.push_back(pNode.GetPosition());
			
			/////////////////////////////
			// Build path to point
			mpPathfinder.BuildPathNodeArrayFromTo(mBaseObj.GetPlayerPos(), pNode.GetPosition());
			
			/////////////////////////////
			// Iterate path nodes, check if any of them are too close to the agent
			bool bTooClose = false;
			for (int j = 0; j < mpPathfinder.GetPathNodeArraySize(); ++j)
			{
				cVector3f vPathNodePos = mpPathfinder.GetPathNodeArrayNode(j).GetPosition();	
				if (mBaseObj.GetDistanceToPos(vPathNodePos) <= 3.5f)
				{
					bTooClose = true;
					break;
				}
			}
			
			if (bTooClose)
			{
				++lTooClosePaths;
			}
		}
		
		/////////////////////////////
		// If all paths are too close the the agent, report dead end
		return lValidNodes > 0 && lValidNodes == lTooClosePaths && (mBaseObj.GetDistanceToPlayer() >= 4.0f || mbPlayerIsInLos == false);
	}
	
	//------------------------------------------------------------
	
	bool HandlePlayerDeadEnd(float afIgnoreChance = -1.0f, float afMaxDeadEndSize = 15.0f, float afMaxPathLength = 15.0f)
	{
		if (mMode == eGhoulMode_Guard) return false;
		
		float fPathLength = mpPathfinder.BuildPathNodeArrayToPos(mBaseObj.GetPlayerPos()) ? mpPathfinder.GetPathNodeArrayFullLength() : -1.0f;
//		cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] HandlePlayerDeadEnd (DeadEnd: " + IsPlayerInDeadEnd() + " Dist: " + mBaseObj.GetDistanceToPlayer() + " PathDist: " + fPathLength + ")");
		
		if (mbAvoidingDeadEndPlayer || IsPlayerInDeadEnd(afMaxDeadEndSize) == false) return false;
		if (fPathLength >= afMaxPathLength) return false;
		mbAvoidingDeadEndPlayer = true;
		if (cMath_RandRectf(0.0f, 1.0f) <= afIgnoreChance)
		{
			cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] Player in a dead end, but we ignored this by chance");
			return false;
		}
		
		/////////////////////////////
		// Try moving forward pas the player
		cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] Player in a dead end, try to avoid");
		bool bTurnAround = false;
		cAINode@ pNode = mpPathfinder.GetNodeOutOfSight(mBaseObj.GetPosition() + mBaseObj.GetCharBody().GetForward() * 12.0f, 0.0f, 6.0f, mBaseObj.GetPlayerPos(), cVector3f_Zero, -1.0f, false, false, false, null);
		if (pNode is null || mpPathfinder.BuildPathNodeArrayToPos(pNode.GetPosition()) == false)
		{
			/////////////////////////////
			// If we cannot move forward, turn around and move backwards
			@pNode = mpPathfinder.GetNodeOutOfSight(mBaseObj.GetPosition() - mBaseObj.GetCharBody().GetForward() * 10.0f, 0.0f, 7.0f, mBaseObj.GetPlayerPos(), cVector3f_Zero, -1.0f, false, false, false, null);
			bTurnAround = true;
		}
		if (pNode is null || mpPathfinder.BuildPathNodeArrayToPos(pNode.GetPosition()) == false)
		{
			cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] Could not find a node to avoid player, ignoring dead end");
			return false;
		}
		
		mpPathfinder.Stop();
		mvDeadEndAvoidGoal = pNode.GetPosition();
		mBaseObj.Timer_Add("Timer_DeadEndAvoid", bTurnAround ? cMath_RandRectf(2.5f, 3.0f) : cMath_RandRectf(0.5f, 1.0f), "Timer_DeadEndAvoid");
		if (bTurnAround)
		{
			mBaseObj.Timer_Add("Timer_DeadEndReaction", cMath_RandRectf(0.5f, 1.0f), "Timer_DeadEndReaction");
		}
		return true;
	}
	
	void Timer_DeadEndReaction(uint64 alID)
	{
		mBaseObj.PlaySound("LookAround", gsGhoulSound_LookAround, true, true);
		PlayRandomAnimation(mvGhoulAnim_LookAroundLong, 0.0f, false, false, "");
	}
	
	cVector3f mvDeadEndAvoidGoal;
	void Timer_DeadEndAvoid(uint64 alID)
	{
		mpPathfinder.MoveTo(mvDeadEndAvoidGoal, 0.2f, false);
	}
	
	//------------------------------------------------------------
	
	void TryHunt()
	{
		if (Terror_GetAmount() >= 1.0f)
		{
			mpStateMachine.ChangeState(eGhoulState_Hunt);
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateSoundCounter(float afTimeStep)
	{		
		if (mfSoundCounter <= 0) return;
		
		//////////////////////
		// Decrease sound counter
		mfSoundCounter -= afTimeStep;
		if (mfSoundCounter < 0) mfSoundCounter = 0;
	}
	
	void IncreaseSoundCounter(int alPrio)
	{
		float fSoundCounterChange = (alPrio + 1.0f) / 4.0f;
		if (mbLanded) fSoundCounterChange *= 2.0f;
		mfSoundCounter += fSoundCounterChange;
		if (mfSoundCounter > 12.0f) mfSoundCounter = 12.0f;
	}
	
	//------------------------------------------------------------
	
	float GetFinalSmellRange()
	{
		if (Player_IsInSmellHideArea()) return 0;
		return mfSniffRange * mfSniffRangeMul;
	}
	
	//------------------------------------------------------------
	
	bool TryToMeetUp(tID a_idOtherAgent, const tString &in asCallbackTimer)
	{
		cVector3f vOtherAgentPos = cLux_ID_Agent(a_idOtherAgent).GetPosition();
		
		//////////////////////
		// Stop meetup when close enough
		if (mBaseObj.GetDistanceToPos(vOtherAgentPos) < 2.4f)
		{
			mpPathfinder.Stop();
			mpStateMachine.AddTimer(asCallbackTimer, 0.2f);
			return true;
		}
		
		//////////////////////
		// Move towards the other agent
		cVector3f vOtherAgentDir = vOtherAgentPos - mBaseObj.GetPosition();
		vOtherAgentDir.Normalize();
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(vOtherAgentPos, 0.0f, 2.0f, true, false, false, null);
		mpPathfinder.MoveTo(pNode.GetPosition(), 0.2f, true);
		
		return false;
	}
	
	//------------------------------------------------------------
	
	float mfPreAlertCounter = 0.0f;
	float mfPreAlertDetectWindow = 0.0f;
	bool mbPreAlertActive = true;
	
	void UpdatePreAlertCounter(float afTimeStep)
	{
		if (mbPreAlertActive == false) return;
		if (mfPreAlertDetectWindow > 0)
		{
			mfPreAlertDetectWindow -= afTimeStep;
			return;
		}
		
		if (mBaseObj.GetDistanceToPlayer() <= 10.0f ||
			mBaseObj.PlayerIsDetected() == false ||
			IsAggressive() || IsAlert() ||
			(mBaseObj.GetDistanceToPlayer() <= 15.0f && Player_GetCrouching() == false) ||
			(mBaseObj.GetDistanceToPlayer() <= 20.0f && Player_GetCrouching() == false && cLux_GetPlayer().GetAverageMoveSpeed() > 3.0f))
		{
			if (mfPreAlertCounter > 0.0f)
			{
				mfPreAlertCounter -= afTimeStep * 0.2f;
			}
			else
			{
				mfPreAlertCounter = 0.0f;
			}
			
			if (mbPreAlert) mBaseObj.ResetPlayerDetectionState();
			mbPreAlert = false;
			return;
		}
		
		mbPreAlert = true;
		
		mfPreAlertCounter += afTimeStep;
		if (mfPreAlertCounter >= gfPreAlertTime)
		{
			mfPreAlertCounter = 0.0f;
			mbPreAlert = false;
			mfPreAlertDetectWindow = 0.5f;
			mBaseObj.ResetPlayerDetectionState();
		}
	}
	
	//------------------------------------------------------------
	
	float mfPlayerRunningCounter;
	
	void UpdatePlayerRunningCounter(float afTimeStep)
	{
		if (Player_GetVelocity().SqrLength() >= 4.0f * 4.0f)
		{
			mfPlayerRunningCounter += afTimeStep;
		}
		else
		{
			mfPlayerRunningCounter = 0.0f;
		}
	}
	
	//------------------------------------------------------------
	
	float mfAwarenessPlayerIsFollowingTimer = 0.0f;
	float mfAwarenessPlayerIsFollowingCounter = 0.0f;
	float mfAwarenessPlayerIsFollowingSniffChance = 0.1f;
	
	void UpdateAwareness(float afTimeStep)
	{
		/////////////////////
		// Peridoically check if the player is stalking us from behind        
		mfAwarenessPlayerIsFollowingTimer += afTimeStep;
		if (mfAwarenessPlayerIsFollowingTimer >= 1.0f)
		{
			mfAwarenessPlayerIsFollowingTimer = 0.0f;
			if (CanCheckForPlayerFollow() &&
				mBaseObj.GetDistanceToPlayer() <= 6.0f &&
				mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos()) == false)
			{
				mfAwarenessPlayerIsFollowingCounter += 1.0f;
			}
			else if (mfAwarenessPlayerIsFollowingCounter > 0.0f)
			{
				mfAwarenessPlayerIsFollowingCounter -= 1.0f;
				if (mfAwarenessPlayerIsFollowingCounter < 0) mfAwarenessPlayerIsFollowingCounter = 0.0f;
			}
			
			if (mfAwarenessPlayerIsFollowingCounter >= 6.0f)
			{
				float fSniffChance = mfAwarenessPlayerIsFollowingSniffChance + ((mfAwarenessPlayerIsFollowingCounter / 10.0f) - 0.6f);
				if (cMath_RandRectf(0.0f, 1.0f) <= fSniffChance)
				{
                    mfAwarenessPlayerIsFollowingCounter = 0.0f;
					mfAwarenessPlayerIsFollowingTimer = -5.0f;
                    
                    if (GetSensesActive() == false) return;
                    
					cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] Player was stalking us, sniff");
					mpStateMachine.ChangeState(eGhoulState_Sniff);					
				}
			}
		}
	}
	
	bool CanCheckForPlayerFollow()
	{
		int lState =  mpStateMachine.GetCurrentState();
		return gbGhoul_CheckForPlayerFollow == true &&
               (lState == eGhoulState_CheckLastKnownPosition ||
                lState == eGhoulState_CheckLastKnownPosition ||
                lState == eGhoulState_EnterDoor ||
                lState == eGhoulState_Idle ||
                lState == eGhoulState_InvestigateSniff ||
                lState == eGhoulState_InvestigateSound ||
                lState == eGhoulState_Patrol ||
                lState == eGhoulState_PostHunt ||
                lState == eGhoulState_PostRetreat ||
                lState == eGhoulState_WanderArea||
                lState == eGhoulState_Retreat ||
                lState == eGhoulState_ReturnToHole ||
                lState == eGhoulState_SearchForPlayer ||
				lState == eGhoulState_SearchArea ||
                lState == eGhoulState_WanderToExitHole);
	}
	
	//------------------------------------------------------------
	
	int mlSidestepIndex = 0;
	array<cVector3f> mvSidestepDirs;
	bool mbSidestepMoving = false;
	
	void SidestepBlockage()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") SidestepBlockage");
		
		mlSidestepIndex = 0;
		mbSidestepMoving = false;
		
		cVector3f vRaycastFrom = mBaseObj.GetPosition();
		vRaycastFrom.y -= mBaseObj.GetCharBody().GetSize().y / 2.0f;
		vRaycastFrom.y += 0.2f;
		
		
		mvSidestepDirs.resize(0);
		mvSidestepDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(80.0f)), mBaseObj.GetCharBody().GetForward()));
		mvSidestepDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-80.0f)), mBaseObj.GetCharBody().GetForward()));
		
		mBaseObj.GetClosestBody("SidestepBlockage_RaycastResult", vRaycastFrom, mvSidestepDirs[0], 3.0f);
		mBaseObj.GetClosestBody("SidestepBlockage_RaycastResult", vRaycastFrom, mvSidestepDirs[1], 3.0f);
	}
	
	void SidestepBlockage_RaycastResult(bool abSuccesful, float afDistance, const cVector3f&in avNormal, iPhysicsBody@ apBody, int alUservalue)
	{
		if (mbSidestepMoving) return;
		if (abSuccesful == false)
		{
			mpMover.ResetStuckCounter();
			cVector3f vMoveTo = mBaseObj.GetPosition();
			cVector3f vDir = mvSidestepDirs[mlSidestepIndex];
			vMoveTo += vDir * 3.0f;
			
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(vMoveTo, 0.0f, 3.0f, true, true, false, null);
			if (pNode !is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Sidestep move");
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
				
				DrawTestPoint(pNode.GetPosition(), 0.5f);
				mbSidestepMoving = true;
				return;
			}
		}
		
		if (mlSidestepIndex == (mvSidestepDirs.length() - 1))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No obvious sidestep path, trying general retreat");
			GeneralRetreat();		
		}
		++mlSidestepIndex;
	}

	//------------------------------------------------------------
	
	array<cVector3f> mvGeneralRetreatDirs;
	array<float> mvGeneralRetreatY;
	int mlGeneralRetreatIndex = 0;
	int mlGeneralRetreat_DirFreeCount = 0;
	bool mbGeneralRetreatMoving = false;
	
	void GeneralRetreat()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") General retreat");
		
		mlGeneralRetreatIndex = 0;
		mbGeneralRetreatMoving = false;
		
		if (mvGeneralRetreatDirs.length() == 0)
		{
			mvGeneralRetreatDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(45.0f)), mBaseObj.GetCharBody().GetForward()));
			mvGeneralRetreatDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-45.0f)), mBaseObj.GetCharBody().GetForward()));
			mvGeneralRetreatDirs.push_back(mBaseObj.GetCharBody().GetRight());
			mvGeneralRetreatDirs.push_back(cVector3f_Zero -mBaseObj.GetCharBody().GetRight());
			mvGeneralRetreatDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(135.0f)), mBaseObj.GetCharBody().GetForward()));
			mvGeneralRetreatDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-135.0f)), mBaseObj.GetCharBody().GetForward()));
			mvGeneralRetreatDirs.push_back(cVector3f_Zero - mBaseObj.GetCharBody().GetForward());
			
			float fRaycastY1 = mBaseObj.GetPosition().y - (mBaseObj.GetCharBody().GetSize().y) / 2.0f + 0.2f;
			float fRaycastY2 = mBaseObj.GetEyePostion().y;
			mvGeneralRetreatY.push_back(fRaycastY1);
			mvGeneralRetreatY.push_back(fRaycastY2);
		}
		
		for (int i = 0; i < mvGeneralRetreatDirs.length(); ++i)
		{
			for (int j = 0; j < mvGeneralRetreatY.size(); ++j)
			{
				cVector3f vRayCastFrom = mBaseObj.GetPosition();
				vRayCastFrom.y = mvGeneralRetreatY[j];
				mBaseObj.GetClosestBody("GeneralRetreat_RaycastResult", vRayCastFrom, mvGeneralRetreatDirs[i], 4.0f);
			}
		}
	}
	
	void GeneralRetreat_RaycastResult(bool abSuccesful, float afDistance, const cVector3f&in avNormal, iPhysicsBody@ apBody, int alUserValue)
	{
		if (mbGeneralRetreatMoving) return;
		if (abSuccesful == false)
		{
			++mlGeneralRetreat_DirFreeCount;
			if (mlGeneralRetreat_DirFreeCount == 2)
			{
				cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + mvGeneralRetreatDirs[mlGeneralRetreatIndex / mvGeneralRetreatY.size()] * 4.0f, 0.0f, 3.0f, true, true, false, null);
				if (pNode !is null)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") General retreat move");
				
					if (UsesVoice() && msRetreatSubject != "") mpBarkMachine.PlayVoice(msRetreatSubject, 1);
					
					mpPathfinder.MoveTo(mBaseObj.GetPosition() + mvGeneralRetreatDirs[mlGeneralRetreatIndex / mvGeneralRetreatY.size()] * 4.0f, 1.0f, false);
					mbGeneralRetreatMoving = true;
				}
			}
		}

		if (mlGeneralRetreatIndex == ((mvGeneralRetreatDirs.length() * 2) - 1))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No obvious general retreat path");
			mpStateMachine.ChangeState(eGhoulState_Idle);		
		}
		
		++mlGeneralRetreatIndex;
		if (mlGeneralRetreatIndex % mvGeneralRetreatY.size() == 0)
		{
			mlGeneralRetreat_DirFreeCount = 0;
		}
	}
	
	//------------------------------------------------------------
	
	void ResetRetreatFlags()
	{
		mbSidestepMoving = false;
		mbGeneralRetreatMoving = false;
	}
	
	//------------------------------------------------------------
	
	void UpdateFlashlightDetection(float afTimeStep)
	{
		if (mfGoboCounter > 0.0f)
		{
			if (mfGoboCounter > 0.2f && mfHitByFlashlightCounter <= 0.0f)
			{
				mBaseObj.BroadcastMessage(eCustomEntityMessage_DetectFlashlightGobo, null, mvGoboPos,0);
				mfGoboCounter = 0.0f;
			}
			mfGoboCounter -= 0.5f * afTimeStep;
			mfGoboCounter = cMath_Clamp(mfGoboCounter, 0.0f, 0.5f);
		}
		
		if (mfHitByFlashlightCounter > 0.0f)
		{
			mfHitByFlashlightCounter -= afTimeStep;
			mfHitByFlashlightCounter = cMath_Clamp(mfHitByFlashlightCounter, 0.0f, 2.0f);
		}
	}
	
	bool mbLanded = false;
	bool mbPreviouslyGrounded = true;
	void UpdatePlayerLandDetection(float afTimeStep)
	{
		bool bGrounded = cLux_GetPlayer().GetCharacterBody().IsOnGround();
		if (bGrounded && mbPreviouslyGrounded == false)
		{
			mbLanded = true;
			mBaseObj.Timer_Remove("Timer_LandPeriod");
			mBaseObj.Timer_Add("Timer_LandPeriod", 0.1f, "OnTimer_LandPeriod");
		}
		mbPreviouslyGrounded = bGrounded;
	}
	
	void OnTimer_LandPeriod(uint64 alID)
	{
		mbLanded = false;
	}
			
	//------------------------------------------------------------
	
	float mfProximityDetectionTimer = 0.0f;
	bool mbProximityDetectionActive = true;
	
	void UpdateProximityDetection(float afTimeStep)
	{
		mfProximityDetectionTimer -= afTimeStep;
		if (mfProximityDetectionTimer > 0.0f) return;
		
		mfProximityDetectionTimer = cMath_RandRectf(0.1f, 0.2f);
		
		bool bHiding = Player_GetHiding();
		bool bAvoidPlayer = bHiding && IsAggressive() == false;
		mpMover.SetDynamicObjectPlayerAvoidanceActive(bAvoidPlayer);
		
		if (mbProximityDetectionActive == false) return;
		if (GetSensesActive(false) == false) return;
		if (IsAggressive()) return;
		if (mpStateMachine.GetCurrentState() == eGhoulState_WakeUp) return;
		if (bHiding) return;
		if (mBaseObj.CheckIsOnScreen(true) == false) return;
		if ((mpStateMachine.GetCurrentState() != eGhoulState_PostAttack && mpProximitySensor.GetPlayerInsideState(eGhoulProximity_Close)) ||
			mpProximitySensor.GetPlayerInsideState(eGhoulProximity_Touching))
		{
			if (mbPlayerSubmerged) mpStateMachine.ChangeState(eGhoulState_TrackSmell);
			else mpStateMachine.ChangeState(eGhoulState_Hunt);
		}
	}
	
	//------------------------------------------------------------
	
	cColor mCurrentEyeColor;
	void SetEyeColor(cColor &in aColor)
	{
//		mCurrentEyeColor = aColor * gfGhoul_EyeColorMul;
//		if (m_idEyeLeft != tID_Invalid) cLux_ID_Entity(m_idEyeLeft).GetMeshEntity().SetIlluminationColor(mCurrentEyeColor);
//		if (m_idEyeRight != tID_Invalid) cLux_ID_Entity(m_idEyeRight).GetMeshEntity().SetIlluminationColor(mCurrentEyeColor);
//		
//		mBaseObj.Timer_Remove("Timer_SetEyeColor");
//		mBaseObj.Timer_Add("Timer_SetEyeColor", 0.2f, "OnTimer_SetEyeColor");
	}
	
	void OnTimer_SetEyeColor(uint64 alID)
	{
		if (m_idEyeLeft != tID_Invalid) cLux_ID_Entity(m_idEyeLeft).GetMeshEntity().SetIlluminationColor(mCurrentEyeColor);
		if (m_idEyeRight != tID_Invalid) cLux_ID_Entity(m_idEyeRight).GetMeshEntity().SetIlluminationColor(mCurrentEyeColor);
	}
	
	//------------------------------------------------------------
	
	void _Global_SetVisible()
	{
		bool bVisibile = cScript_GetGlobalArgBool(0);
		mBaseObj.GetMeshEntity().SetVisible(bVisibile);
	}
	
	//------------------------------------------------------------
	
	bool UsesVoice()
	{
		return msVoiceCharacter != "" && mbUseVoice;
	}
	
	//------------------------------------------------------------
	
	bool BuildRetreatAreaArray()
	{
		mvRetreatAreas.resize(0);

		array <tString> vAreaStrings;
		cString_GetStringVec(msRetreatAreaName, vAreaStrings, " ");

		for(int i = 0; i < vAreaStrings.length(); ++i)
		{
			array<iLuxEntity@> vEntities;
			if (mBaseObj.GetMap().GetEntityArray(vAreaStrings[i], eLuxEntityType_Area, "", vEntities))
			{
				for (int j = 0; j < vEntities.length(); ++j)
				{
					mvRetreatAreas.push_back(vEntities[j].GetID());
				}
			}
			else
			{
				Error("[Ghoul " + mBaseObj.GetName() + "] Could not find any retreat areas for : " + mBaseObj.GetName());
				return false;
			}
		}

		return true;
	}
	
	//------------------------------------------------------------
	
	cLuxArea@ GetClosestRetreatArea()
	{
		cLuxArea@ pClosestArea = null;
		float fClosestPathDist = -1.0f;
		for (int i = 0; i < mvRetreatAreas.size(); ++i)
		{
			cLuxArea@ pArea = cLux_ID_Area(mvRetreatAreas[i]);
			float fDist = mBaseObj.GetDistanceToPos(pArea.GetPosition());
			if (fDist > 30.0f) continue;
			if (cLux_CheckLineOfSight(cLux_GetPlayer().GetCamera().GetPosition(), pArea.GetPosition(), true, true)) continue;
			if (mpPathfinder.BuildPathNodeArrayToPos(pArea.GetPosition()) == false) continue;
			
			float fPathDist = mpPathfinder.GetPathNodeArrayFullLength();
			if (fClosestPathDist < 0.0f  || fPathDist < fClosestPathDist)
			{
				@pClosestArea = pArea;
				fClosestPathDist = fPathDist;
			}
		}
		return pClosestArea;
	}
	
	//------------------------------------------------------------
	
	float mfQuickHoleReturn_Timer = 0.0f;
	void UpdateQuickHoleReturn(float afTimeStep, float afDistance, bool abOnlyWhenBehindPlayer = false)
	{
		mfQuickHoleReturn_Timer -= afTimeStep;
		if (mfQuickHoleReturn_Timer >= 0.0f) return;
		mfQuickHoleReturn_Timer = 0.2f;
		if (mBaseObj.GetDistanceToPlayer() <= afDistance) return;
		if (mlGhoulHoleNetworkId < 0) return;
		
		if (abOnlyWhenBehindPlayer)
		{
			int lGhoulIndex = Blackboard_GetPlayerPathIndex(mlGhoulHoleNetworkId, mBaseObj.GetPosition());
			int lPlayerIndex = Blackboard_GetPlayerPathIndex(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos());
			if (lGhoulIndex >= lPlayerIndex) return;
		}
		
		if (mBaseObj.IsLookedAtByPlayer())
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player too far, quick return to hole");
			
			mbHideInHole_MoveAwayStart = false;
			
			ReturnToHole(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition()), eGhoulSpeed_Run);
		}
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player too far, instant return to hole");
			mbHideInHole_MoveAwayStart = false;
			mpStateMachine.ChangeState(eGhoulState_HideInHole);
		}
	}
	
	//------------------------------------------------------------
	
	float mfDoorDetection_Timer = 0.0f;
	void UpdateDoorDetection(float afTimeStep)
	{
		mfDoorDetection_Timer -= afTimeStep;
		if (mfDoorDetection_Timer >= 0.0f) return;
		mfDoorDetection_Timer = 0.1f;
		
		cVector3f vRayFrom = mBaseObj.GetPosition();
		vRayFrom += mBaseObj.GetCharBody().GetForward() * mBaseObj.GetCharBody().GetSize().x;
		
		cLuxClosestEntityData closestData;
		cLux_GetClosestEntity(mBaseObj.GetPosition(), mBaseObj.GetCharBody().GetForward(), 2.0f, 0, false, closestData);
		
		if (closestData.mpEntity is null) return;
		if (closestData.mpEntity.GetIsDoor() == false) return;
		float fReactDist = (mBaseObj.GetCharBody().GetSize().x / 2.0f) + 0.5f;
		if (closestData.mfDistance > fReactDist) return;
		if (closestData.mpEntity.GetID() == m_idBlockedByProp_Entity) return;
		if (SwingDoor_GetOpenableByAgent(closestData.mpEntity.GetName()) == false) return;
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") DoorDetection: door detected " + closestData.mpEntity.GetName());
		mlBlocked_PrevState = mpStateMachine.GetCurrentState();
		m_idBlockedByProp_Entity = closestData.mpEntity.GetID();
		mpStateMachine.ChangeState(eGhoulState_BlockedByProp);
	}
	
	//------------------------------------------------------------
	
	void EnterInvestigateState(bool abMusic = true)
	{
		SetEyeColor(gGhoul_EyeColorAlerted);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearSpotted);
//		Music_AddDynamicTrack(cLux_GetCurrentMap().GetPlayerEntity().GetID(), 0, eMusicPrio_AgentAlert, "A2_Proto_GhoulSearch", 0.6f, 3.0f, 3.0f);
		Blackboard_SetAgentInvestigate(mBaseObj.GetID(), true);
		mAlertState = eGhoulAlertState_Investigating;
	}
	
	void LeaveInvesitgateState()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearDefault);
//		Music_RemoveDynamicTrack(cLux_GetCurrentMap().GetPlayerEntity().GetID());
		Blackboard_SetAgentInvestigate(mBaseObj.GetID(), false);
	}

	//------------------------------------------------------------
	
	void EnterAlertState(float afAlertTimeMul = 1.0f)
	{
		SetEyeColor(gGhoul_EyeColorAlerted);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearSpotted);
		Blackboard_SetGlobalAlert();
		Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime * afAlertTimeMul);
		mAlertState = eGhoulAlertState_Alert;
		
		if (msAlertedCallback != "")
		{
			ExecuteEntityCallback(msAlertedCallback);
			msAlertedCallback = "";
		}
	}
	
	void LeaveAlertState()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearDefault);
		Terror_RemoveEnemy(mBaseObj.GetID());
	}
	
	//------------------------------------------------------------
	
	void EnterHuntState()
	{
		SetEyeColor(gGhoul_EyeColorAttacking);
		FearThreatAgent_SetOverrideFactor(mBaseObj.GetName(), mfFearHunted);
		mAlertState = eGhoulAlertState_Hunting;
        Music_PlayExt(msGhoulMusic_Hunt, true, 1, 1, 2.0f, 0, eMusicPrio_AgentToHuntTransition, true);
	}
	
	void LeaveHuntState()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		FearThreatAgent_SetOverrideFactor(mBaseObj.GetName(), -1.0f);
	}
	
	//------------------------------------------------------------
	
	void LeaveBlockedState()
	{
		if (mCommand == eGhoulCommand_UseDoor)
		{
			mCommand = eGhoulCommand_None;
			ExecuteLeaveBlockedStateCallback(msCommandCompletedCallback);
		}
	}
	
	void ExecuteLeaveBlockedStateCallback(const tString &in asFunc)
	{
		if (asFunc == "") return;
		
		tString sMethodName = "void " + asFunc + "()";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.ScriptExecute();
		}
	}
	
	//------------------------------------------------------------
	
	bool GetSensesActive(bool abCheckIfPlayerSubmerged = true)
	{
		if (abCheckIfPlayerSubmerged && mbPlayerSubmerged) return false;
		if (mbModeOverrideSenses) return mbModeSensesActive;
		if (mfPermafailInvulnerabilityTimer > 0) return false;
		if (FearHandler_GetIsPermaFailing()) return false;
		return mBaseObj.GetSensesActive();
	}
	
	//------------------------------------------------------------
	
	tString GetDetectedAnimation(const cVector3f &in avDetectedPos)
	{
		cVector3f vToDetected = avDetectedPos - mBaseObj.GetPosition();
		vToDetected.y = 0;
		vToDetected.Normalize();
		
		float fAngle = cMath_ToDeg(cMath_Vector3Angle(vToDetected, mBaseObj.GetCharBody().GetForward()));
		float fSign = cMath_Vector3Dot(vToDetected, mBaseObj.GetCharBody().GetRight()) >= 0 ? 1.0f : -1.0f;
		
		if (fAngle <= 30.0f) return gsGhoulAnim_PlayerDetected;
		else if (fAngle <= 70.0f) return fSign >= 0 ? gsGhoulAnim_PlayerDetected_45_Right : gsGhoulAnim_PlayerDetected_45_Left;
		else return fSign >= 0 ? gsGhoulAnim_PlayerDetected_90_Right : gsGhoulAnim_PlayerDetected_90_Left;
		return "";
	}
	
	//------------------------------------------------------------
	
	//} END GHOUL HELPERS

	//===========================================================

	/////////////////////////////////////////
	//=======================================
	// STATES
	//=======================================
	/////////////////////////////////////////

	//===========================================================

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: DEFAULT
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_Default_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Default ------");
		mfMovedTimeout = 0.0f;
	}
	
	//------------------------------------------------------------
	
	void State_Default_Leave()
	{
		msAnimState = "";
	}
	
	//------------------------------------------------------------
	
	void State_Default_Update(float afTimeStep) {}

	//------------------------------------------------------------

	bool State_Default_Message(int alMessageId)
	{
		if (mpPathfinder.IsClimbing()) return true;
		
		int lState = mpStateMachine.GetCurrentState();
		int lProximityState = mpStateMachine.GetCurrentMessageData().mlX;

		//////////////////////
		// Player Detected
		if(alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player detected");
			if (mAlertState == eGhoulAlertState_Hunting)
			{
				mpStateMachine.ChangeState(eGhoulState_Hunt);
			}
			else if (mbPreAlert)
			{
				
			}
			else if (mAlertState == eGhoulAlertState_Investigating)
			{
				mpStateMachine.ChangeState(eGhoulState_Alert);
			}
			else
			{
				mpStateMachine.ChangeState(mBaseObj.GetDistanceToPlayer2D() <= 8.0f ? eGhoulState_Alert : eGhoulState_PlayerDetected);
			}
			return false;
		}
		else if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player undetected");
			return false;
		}

		/////////////////////
		// Stuck Counter High
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh)
		{
			mpStateMachine.ChangeState(eGhoulState_Blocked);
			return true;
		}

		/////////////////////
		// Heard sound
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetSensesActive() == false) return true;
			if (mbCurrentlyDeaf) return false;
			
			/////////////////////
			// Ignore sounds if we see the player
			if (mBaseObj.PlayerIsDetected())
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Ignoring sound because player is detected");
				return false;
			}

			if (Map_TimerExists("Timer_NoDebrisNoise"))
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Ignore sound because of debris detection");
				return false;
			}
			
			cVector3f vGoal = mpStateMachine.GetCurrentMessageData().mvX;
			int lPrio = mpStateMachine.GetCurrentMessageData().mlX;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Sound heard: (Prio: " + lPrio + " InvestigateSoundPrio: " + mlInvestigateSound_Prio + " " +  mpStateMachine.GetCurrentMessageData().msX + ")");
			
			mvInvestigateSound_Goal = vGoal;
			mlInvestigateSound_Prio = lPrio;
			mpStateMachine.ChangeState(eGhoulState_InvestigateSound);
			return false;
		}

		/////////////////////
		// Proximity Sensors
		else if(alMessageId == eLuxEntityMessage_LeaveProximity)
		{
			if (GetSensesActive() == false) return true;
		}
		else if(alMessageId == eLuxEntityMessage_EnterProximity)
		{
			if (GetSensesActive(false) == false) return true;
			
			//TODO: figure out how to make this work
			
//			if (lProximityState == eGhoulProximity_Near)
//			{
//				mbAlert_Delayed = true;
//				mpStateMachine.ChangeState(eGhoulState_Alert);
//			}
		}
		
		/////////////////////
		// Hit by prop
		else if (alMessageId == eLuxEntityMessage_HitByProp)
		{
			if (GetSensesActive() == false) return true;
			
			float fHitSpeed = mpStateMachine.GetCurrentMessageData().mvX.x;
			float fHitHeightFromFeet = mvLastHitByPropPos.y - mBaseObj.GetCharBody().GetFeetPosition().y;
			float fDistance = cMath_Vector3Dist(mvLastHitByPropPos, mBaseObj.GetCharBody().GetFeetPosition());
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hit by object (Speed: " + fHitSpeed + " TimeSinceLastInteraction: " + cLux_GetPlayer().GetTimeSincePhysicsObjectInteraction() + " HeightFromFeet: " + fHitHeightFromFeet + ")");

			/////////////////////
			// Set timer to ignore debris noise for a while
			if (fHitHeightFromFeet <= 0.3f && fDistance <= 2.5f)
			{
				Map_RemoveTimer("Timer_NoDebrisNoise");
				Map_AddTimer("Timer_NoDebrisNoise", 1.0f, "");
			}
			
			/////////////////////
			// Prevent the ghoul triggering this by running over small objects on the ground
			if (fHitSpeed < 1.4f) return false;
			if (cLux_GetPlayer().GetTimeSincePhysicsObjectInteraction() > 1.0f) return false;
			if (fHitHeightFromFeet <= 0.2f) return false;
			
			mbStunned_Stunned = true;
			mpStateMachine.ChangeState(eGhoulState_Stunned);
		}

		/////////////////////
		// Attracted
		else if (alMessageId == eCustomEntityMessage_AttractAgent)
		{
			if (mbAttracted_Enabled == false) return true;
			mvMeatAttractPos = mpStateMachine.GetCurrentMessageData().mvX;
			mpStateMachine.ChangeState(eGhoulState_Attracted);
		}
        
        /////////////////////
		// Player dead
		else if (alMessageId == eLuxEntityMessage_PlayerDead)
		{
			if (FearHandler_GetIsPermaFailing() == false) return true;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player permafailing, going to idle and ignoring player for a while");
			
			mfPermafailInvulnerabilityTimer = 10;
			
            Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
			
//			mBaseObj.ResetPlayerDetectionState();			
			mpMover.TurnToPos(mBaseObj.GetPlayerPos());
			
			mpStateMachine.ChangeState(eGhoulState_Idle);
            return true;
		}
		
		/////////////////////
		// End of path
		else if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mbSidestepMoving || mbGeneralRetreatMoving)
			{
				tString sAction = mbSidestepMoving ? "sidestep" : "general retreat";
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EndOfPath after " + sAction + ", return to pre-blocked state");
				ResetRetreatFlags();
				
				if (mlBlocked_PrevState == eGhoulState_Retreat)
				{
					mlBlocked_PrevState = eGhoulState_Idle;
				}
				mpStateMachine.ChangeState(mlBlocked_PrevState);
			}
		}
		
		/////////////////////
		// Water hiding
		else if (alMessageId == eCustomEntityMessage_PlayerSubmerged)
		{
			mbPlayerSubmerged = true;
		}
		else if (alMessageId == eCustomEntityMessage_PlayerEmerged)
		{
			mbPlayerSubmerged = false;
			mBaseObj.ResetPlayerDetectionState();
		}
		
		/////////////////////
		// Flashlight detection
		else if (mbDetectFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			if (alMessageId == eCustomEntityMessage_SeeFlashlightGobo)
			{
//				cLux_AddDebugMessage("[Ghoul " + mBaseObj.GetName() + "] See flashlight gobo");
				mvGoboPos = mpStateMachine.GetCurrentMessageData().mvX;
				mfGoboCounter += 0.15f;
			}
			
			else if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Detect flashlight gobo");
				if (mAlertState >= eGhoulAlertState_Investigating)
				{
					mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
					mpStateMachine.ChangeState(eGhoulState_CheckGobo);
				}
				else mpStateMachine.ChangeState(eGhoulState_PlayerLightDetected);
			}
			
			else if (alMessageId == eCustomEntityMessage_HitByFlashlight)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Hit by flashlight");
				if (mBaseObj.GetDistanceToPlayer2D() <= 10.0f)
				{
					mfHitByFlashlightCounter += 1.0f;
					if (mAlertState >= eGhoulAlertState_Investigating)
					{
						mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
						mpStateMachine.ChangeState(eGhoulState_CheckFlashlightHit);
					}
					else mpStateMachine.ChangeState(eGhoulState_PlayerLightDetected);
				}
			}
		}

		return false;
	}
	
	//------------------------------------------------------------

	//} END DEFAULT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: IDLE
	//{////////////////////////////////

	//------------------------------------------------------------

	bool mbIdle_Stop = true;
	
	float mfIdle_Wait = 0.0f;
	bool mbIdle_StopIdleWhenDisturbed = false;
	bool mbIdle_SensesActive = true;
	
	tString msIdle_EnterCallback = "";
	bool mbIdle_EnterCallbackAutoRemove = false;

	//-----------------------------------------------------------

	void State_Idle_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Idle ------");
		
		SetEyeColor(gGhoul_EyeColorDefault);
		mAlertState = eGhoulAlertState_None;
		
		mpPathfinder.Stop();
		
		mpStateMachine.AddTimer("DecideBehavior", 0.0f);
		
		ExecuteNoArgCallback(msIdle_EnterCallback);
		if (mbIdle_EnterCallbackAutoRemove) msIdle_EnterCallback = "";
	}

	//------------------------------------------------------------

	void State_Idle_Leave()
	{
		mbIdle_Stop = false;
		mpMover.SetUseMoveStateAnimations(true);
	}
	
	//------------------------------------------------------------
	
	void State_Idle_Update(float afTimeStep)
	{
		UpdateSmellDetection(afTimeStep);
	}
	
	//------------------------------------------------------------
	
	bool State_Idle_Message(int alMessageId)
	{
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_Idle_TimerUp(uint64 alId)
	{
		if (alId == H64("DecideBehavior"))
		{
			Idle_DecideBehavior();
			mpStateMachine.AddTimer("DecideBehavior", 0.2f);
		}
	}
	
	//------------------------------------------------------------
	
	void Idle_DecideBehavior()
	{
		//cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") DecideBehavior");
		
		if (Idle_DecideCommandBehavior()) return;
		if (Idle_DecideModeBehavior()) return;
	}
	
	bool Idle_DecideCommandBehavior()
	{
		if (mCommand == eGhoulCommand_Retreat)
		{
			mbRetreat_CalculatePos = mbRetreat_CommandCalculatePos;
			mvRetreat_RetreatToPos = mvRetreat_CommandRetreatToPos;
			mpStateMachine.ChangeState(eGhoulState_Retreat);
			return true;
		}
		else if (mCommand == eGhoulCommand_GoToHole)
		{
			ReturnToHole(m_idReturnToHole_CommandHole, mReturnToHole_CommandSpeed);
			return true;
		}
		else if (mCommand == eGhoulCommand_EmergeFromHole)
		{
			m_idEmerge_Hole = m_idEmerge_CommandHole;
			mpStateMachine.ChangeState(eGhoulState_Emerge);
			return true;
		}
		else if (mCommand == eGhoulCommand_UseDoor)
		{
			MoveTo(mvMoveTo_CommandGoal, mMoveTo_CommandSpeed, 2.0f);
			return true;
		}
		else if (mCommand == eGhoulCommand_Smell)
		{
			mpStateMachine.ChangeState(eGhoulState_TrackSmell);
			return true;
		}
		else if (mCommand == eGhoulCommand_WakeUp)
		{
			mpStateMachine.ChangeState(eGhoulState_WakeUp);
			return true;
		}
		else if (mCommand == eGhoulCommand_ThreatenPlayer)
		{
			mpStateMachine.ChangeState(eGhoulState_ThreateningApproach);
			return true;
		}
		else if (mCommand == eGhoulCommand_Patrol)
		{
			if (mPatrol_NextInstance.mvNodes.size() < 1)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ERROR: No patrol nodes, will stay in idle");
				mCommand = eGhoulCommand_None;
				return false;
			}
			
			if (mPatrol_NextInstance.mlLoopCount < 1)
			{
				mCommand = eGhoulCommand_None;
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ERROR: Cannot loop infinitely with a command, use a mode instead");
				return false;
			}
			
			mpStateMachine.ChangeState(eGhoulState_Patrol);
			return true;
		}
		return false;
	}
	
	bool Idle_DecideModeBehavior()
	{
		if (mMode == eGhoulMode_Patrol)
		{
			if (mPatrol_ModeInstance.mvNodes.size() < 1)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ERROR: No patrol nodes, will stay in idle");
				return false;
			}
			
			mPatrol_NextInstance = mPatrol_ModeInstance;
			mpStateMachine.ChangeState(eGhoulState_Patrol);
			return true;
		}
		else if (mMode == eGhoulMode_StalkThroughHoles)
		{
			if (mpStateMachine.GetCurrentState() == eGhoulState_Emerge) return true;
			if (mpStateMachine.GetCurrentState() == eGhoulState_WanderArea) return true;
			if (mpStateMachine.GetCurrentState() == eGhoulState_ReturnToHole) return true;
			mpStateMachine.ChangeState(eGhoulState_ReturnToHole);
			return true;
		}
		else if (mMode == eGhoulMode_Hunt)
		{
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPlayerFeetPos(), 0.0f, 5.0f, true, false, false, null);
			
			if (pNode is null)
				cLux_AddAIDebugMessage("No nodes found for hunting!");
			
			if (pNode !is null && cMath_Vector3Dist(pNode.GetPosition(), mBaseObj.GetPlayerFeetPos()) <= 2.5f)
			{
				mpStateMachine.ChangeState(eGhoulState_Hunt);
			}
			return true;
		}
		else if (mMode == eGhoulMode_Trapped)
		{
			mpStateMachine.ChangeState(eGhoulState_Trapped);
			return true;
		}
		else if (mMode == eGhoulMode_Enthralled)
		{
			mpStateMachine.ChangeState(eGhoulState_Enthralled);
			return true;
		}
		else if (mMode == eGhoulMode_Guard)
		{
			mpStateMachine.ChangeState(eGhoulState_Guard);
			return true;
		}
		else if (mMode == eGhoulMode_RandomWanderArea)
		{
			mpStateMachine.ChangeState(eGhoulState_WanderArea);
			return true;
		}
		else if (mMode == eGhoulMode_Idle)
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
			return true;
		}
		return false;
	}
    
	//------------------------------------------------------------

	//} END STATE: IDLE

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: WAIT
	//{////////////////////////////////

	//------------------------------------------------------------

	void State_Wait_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Wait ------");
	}

	//------------------------------------------------------------

	void State_Wait_Leave() {}
	void State_Wait_Update(float afTimeStep) {}
	bool State_Wait_Message(int alMessageId) { return false; }

	//------------------------------------------------------------

	void State_Wait_TimerUp(uint64 alId)
	{
		if (alId == H64("CheckIdle"))
		{
			Idle_DecideBehavior();
			mpStateMachine.AddTimer("CheckIdle", 0.5f);
		}
		
		if(alId == H64("WaitTimer"))
		{
		}
	}

	//------------------------------------------------------------

	//} END STATE: WAIT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: HIDE IN HOLE
	//{////////////////////////////////

	//------------------------------------------------------------
	
	tID m_idHideInHole_Hole = tID_Invalid;
	bool mbHideInHole_FollowPlayer = false;

	bool mbHidden = false;
	bool mbHideInHole_CanHear = false;
	bool mbHideInHole_SoundEmerge = false;
	cVector3f mvHideInHole_SoundPos;
	int mlHideInHole_NoiseCount = 0;
	bool mbHideInHole_MoveAwayStart = false;
	
	tString msHideInHole_EnterCallback = "";
	bool mbHideInHole_EnterCallbackAutoRemove = false;
	
	bool mbHideInHole_EmergeTimerPaused = false;
	bool mbPauseOnNextHide = false;
	float mfHideInHole_EmergeChance = 0;
		
	bool mbHideInHole_InvestigateSound = false;
	bool mbHideInHole_HideUntilDisturbed = false;
	float mfHideInHole_MovingFear = 0.4f;
	float mfHideInHole_StaticFear = 0.2f;
	float mfHideInHole_SoundRadius = 8.0f;
	float mfHideInHole_ImportantSoundRadius = 3.0f;
	int mlHideInHole_WaitLookAtCount = 0;
	int mlHideInHole_MoveWithoutEmergeCount = 0;
	
	//------------------------------------------------------------

    void State_HideInHole_Enter()
	{	
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: HideInHole ------", false, true);
				
		///////////////////////
		// Make it hear map wide when in hiding, so we can emerge from holes
		mpSoundListener.SetHearRadius(999999.0f);
		mpSoundListener.SetSoundRadiusMul(2.0f);
		
		mlHideInHole_NoiseCount = 0;
		mbHideInHole_CanHear = false;
		mbHideInHole_InvestigateSound = false;
		mbHideInHole_SoundEmerge = false;
		mlHideInHole_MoveWithoutEmergeCount = 0;

		///////////////////////
		// Hide it
		SetHidden(true);
		FearThreatAgent_SetComponentEnabled(mBaseObj.GetName(), false);
		FearThreatAgent_SetCanGasp(mBaseObj.GetName(), false);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfHideInHole_StaticFear);
		FearThreatAgent_SetSurpriseFactor(mBaseObj.GetName(), 0.0f);
		FearThreatAgent_SetActivationDistance(mBaseObj.GetName(), 12.0f);
		FearThreatAgent_SetMaxFearDistance(mBaseObj.GetName(), 4.0f);
		
		HideInHole_ExecuteEnterCallback();
		
		if (mCommand == eGhoulCommand_GoToHole)
		{
			mCommand = eGhoulCommand_None;
			ExecuteEntityCallback(msCommandCompletedCallback);
			if (mbReturnToHole_CommandDeactivateAfter)
			{
				mBaseObj.SetActive(false);
			}
		}
		
		//////////////
		// Hide in closest hole if no hole specified
		if (m_idHideInHole_Hole == tID_Invalid)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No hole specified, hide in closest");
			m_idHideInHole_Hole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition());
		}
		
		//////////////
		// Fallback if no hole found
		if (m_idHideInHole_Hole == tID_Invalid)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No hole to hide in, return to idle", false, true);
			mpStateMachine.ChangeState(eGhoulState_Idle);
			return;
		}
		
		PositionAtGhoulHole(m_idHideInHole_Hole);
		
		Blackboard_SetGhoulHoleUsed(m_idHideInHole_Hole, mBaseObj.GetID());
		
		mpPathfinder.Stop();
		Terror_RemoveEnemy(mBaseObj.GetID());
		
		if (mbHideInHole_HideUntilDisturbed)			mpStateMachine.AddTimer("MoveAway", 1.0f);
		else if (mbHideInHole_FollowPlayer) 			mpStateMachine.AddTimer("FollowPlayer", 0.0f);
		else if (mMode == eGhoulMode_Idle) {}
		else if (mbHideInHole_MoveAwayStart) 			mpStateMachine.AddTimer("MoveAway", 1.0f);
		else if (mbHideInHole_MoveAwayStart == false) 	mpStateMachine.AddTimer("MoveToBestHole", 1.0f);
		
		mpStateMachine.AddTimer("EnableHearing", 2.0f);
		mpStateMachine.AddTimer("ClosedHoleCheck", 0.2f);
	}
	
	//------------------------------------------------------------

	void State_HideInHole_Leave()
	{			
		FearThreatAgent_SetComponentEnabled(mBaseObj.GetName(), true);
		FearThreatAgent_SetCanGasp(mBaseObj.GetName(), true);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearDefault);
		FearThreatAgent_SetSurpriseFactor(mBaseObj.GetName(), gfFear_SurpriseEffect);
		FearThreatAgent_SetActivationDistance(mBaseObj.GetName(), gfMinFearDistance);
		FearThreatAgent_SetMaxFearDistance(mBaseObj.GetName(), gfMaxFearDistance);
		
		mbHideInHole_MoveAwayStart = true;

		///////////////////////
		// Reset hearing
		mpSoundListener.SetHearRadius(mfHearRadius);
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);
		
		Blackboard_RemoveGhoulHoleUsed(m_idHideInHole_Hole);
		m_idHideInHole_Hole = tID_Invalid;
		
		if (mpStateMachine.GetNextState() != eGhoulState_Emerge)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Forced emerge without animations", false, true);
			PositionAtGhoulHole(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), -1.0f, -1.0f, false));
			SetHidden(false);
		}

		Sound_Stop("WallMoveStart", 0.0f);
		Sound_Stop("WallMoveLoop", 0.0f);
		Sound_Stop("HoleActive", 0.0f);
		Sound_Stop("HoleArrived", 0.0f);
	}
	
	//------------------------------------------------------------

	void State_HideInHole_Update(float afTimeStep)
	{
		UpdateWallMovement(afTimeStep);
	}
	
	//------------------------------------------------------------

	bool State_HideInHole_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetSensesActive() == false) return true;
			if (mbHideInHole_FollowPlayer) return true;
			if (mbHideInHole_CanHear == false) return true;
			
			mvHideInHole_SoundPos = mpStateMachine.GetCurrentMessageData().mvX;
			
			tID idClosestHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mvHideInHole_SoundPos, -1.0f, mfHideInHole_SoundRadius, false);
			if (idClosestHole == tID_Invalid) return true;
			
			cVector3f vPlayerVelocity = cLux_GetPlayer().GetAverageMoveDirection();
			vPlayerVelocity.Normalize();
			float fPlayerSpeed = cLux_GetPlayer().GetAverageMoveSpeed();
			float fDistance = cMath_Vector3Dist(cLux_ID_Entity(idClosestHole).GetPosition(), mvHideInHole_SoundPos);
			bool bImportantRadius = fDistance <= mfHideInHole_ImportantSoundRadius;
			bool bFootstep = mpStateMachine.GetCurrentMessageData().msX == "Footstep";
			bool bLoudFootstep = fPlayerSpeed > 4.0f || vPlayerVelocity.y < -0.15f;
			
			if (bFootstep && bLoudFootstep == false && bImportantRadius == false) return true;
			
			bool bHighPriority = fDistance <= mfHideInHole_ImportantSoundRadius && (bFootstep == false || fPlayerSpeed > 4.0f || vPlayerVelocity.y < -0.15f);
			
			mbHideInHole_InvestigateSound = true;
			++mlHideInHole_NoiseCount;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Heard sound #" + mlHideInHole_NoiseCount);
			
			if (mbHideInHole_SoundEmerge)
			{
				if (bHighPriority) ++mlHideInHole_NoiseCount;
				if (mlHideInHole_NoiseCount >= 8)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Trigger intercept emerge");
					mbHideInHole_CanHear = false;
					mBaseObj.Timer_Remove("EmergeDelayed");
					WallMoveTo(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), 8.0f, -1.0f, true, true), "InterceptEmerge");
				}
				return true;
			}
			
			HideInHole_StopTimers();
			
			mbHideInHole_CanHear = false;
			mpStateMachine.AddTimer("EnableHearing", 1.0f);
			
			if (mBaseObj.Timer_Exists("EmergeDelayed")) return true;
			
			mpStateMachine.StopTimer("ResetNoiseCount");
			
			if (bHighPriority == false && mlHideInHole_NoiseCount <= 1)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Heard first sound");
				mBaseObj.PlaySound("SoundHeard", gsGhoulSound_SoundHeard, true, true);
				if (m_idHideInHole_Hole == idClosestHole && mbWallMove == false)
				{
					mpStateMachine.AddTimer("ResetNoiseCount", 8.0f);
					mpStateMachine.AddTimer("SetupLookAtWait", 2.0f);
				}
				else
				{
					WallMoveTo(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mvHideInHole_SoundPos, -1.0f, -1.0), "WaitInvestigateSound");
				}
			}
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Heard second sound");
				mbHideInHole_SoundEmerge = true;
				mBaseObj.PlaySound("SoundHeard", gsGhoulSound_SoundHeard, true, true);
				if (m_idHideInHole_Hole == idClosestHole && mbWallMove == false)
				{
					mpStateMachine.AddTimer("InvestigateSoundEmerge", 2.0f);
				}
				else
				{
					WallMoveTo(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mvHideInHole_SoundPos, -1.0f, -1.0), "InvestigateSoundEmerge");
				}
			}
			return true;
		}

		return true;
	}
	
	//------------------------------------------------------------
	
	void State_HideInHole_TimerUp(uint64 alId)
	{
		if (alId == H64("FollowPlayer"))
		{
			if (mbWallMove == false)
			{
				WallMoveTo(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), -1.0f, -1.0f, false));
			}
			mpStateMachine.AddTimer("FollowPlayer", 1.0f);
		}
		
		if (alId == H64("MoveAway"))
		{			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveAway");
			tID idMoveToHole = Blackboard_GetRandomGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), 15.0f, 45.0f, true, false, false, false, array<tID> = { m_idHideInHole_Hole });
			if (idMoveToHole == tID_Invalid)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveAway fallback");
				idMoveToHole = Blackboard_GetRandomGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), -1.0f, -1.0f, true, false, false, false, array<tID> = { m_idHideInHole_Hole });
			}
			
			WallMoveTo(idMoveToHole, "MoveAwayEnd");
		}
		
		if (alId == H64("MoveAwayEnd"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveAwayEnd");
			
			if (mbHideInHole_HideUntilDisturbed)
			{
				mpStateMachine.AddTimer("MoveAway", cMath_RandRectf(8.f, 10.f));
			}
			else
			{
				mpStateMachine.AddTimer("MoveToBestHole", cMath_RandRectf(5.0f, 7.0f));
			}			
		}
			
		if (alId == H64("MoveToBestHole"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveToBestHole count: " + (mlHideInHole_MoveWithoutEmergeCount + 1));
			
			HideInHole_StopTimers();
			
			++mlHideInHole_MoveWithoutEmergeCount;
			tID idMoveToHole = Blackboard_GetBestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), mBaseObj.GetID());
			if (idMoveToHole != m_idHideInHole_Hole)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveToBestHole move to " + cLux_ID_Entity(idMoveToHole).GetName());
				WallMoveTo(idMoveToHole, "BestHoleArrive");
			}
			else
			{
				mpStateMachine.AddTimer("DecideEmerge", 0.0f);
			}
		}
		
		if (alId == H64("BestHoleArrive"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") BestHoleArrive");
			tID idMoveToHole = Blackboard_GetBestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPlayerPos(), mBaseObj.GetID());
			if (idMoveToHole != m_idHideInHole_Hole)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveToBestHole move to " + cLux_ID_Entity(idMoveToHole).GetName());
				WallMoveTo(idMoveToHole, "DecideEmerge");
			}
			else
			{
				mpStateMachine.AddTimer("DecideEmerge", 0.0f);
			}
		}
		
		if (alId == H64("DecideEmerge"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") DecideEmerge");
			
			if (mlHideInHole_MoveWithoutEmergeCount == 2)
			{
				if (cMath_RandRectf(0.0f, 1.0f) <= 0.75f)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") DecideEmerge 0.75 chance emerge");
					Emerge(m_idHideInHole_Hole, 5.0f);
					return;
				}
			}
			else if (mlHideInHole_MoveWithoutEmergeCount > 2)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") DecideEmerge 1.0 chance emerge");
				Emerge(m_idHideInHole_Hole, 5.0f);
				return;
			}

			mpStateMachine.AddTimer("SetupLookAtWait", 0.2f);
		}
		
		if (alId == H64("SetupLookAtWait"))
		{
			mpStateMachine.AddTimer("StopWaitForLookAt", cMath_RandRectf(6.0f, 8.0f));
			mlHideInHole_WaitLookAtCount = 0;
			mpStateMachine.AddTimer("WaitForLookAt", 0.0f);
		}
		
		if (alId == H64("WaitForLookAt"))
		{
			if (mpStateMachine.TimerExists("StopWaitForLookAt") == false) return;
			if (mbWallMove == false && cLux_ID_Entity(m_idHideInHole_Hole).CheckIsOnScreen(true))
			{
				++mlHideInHole_WaitLookAtCount;
				if (mlHideInHole_WaitLookAtCount > 2)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") WaitForLookAt loookat emerge");
					Emerge(m_idHideInHole_Hole, 5.0f);
					return;
				}
			}
			mpStateMachine.AddTimer("WaitForLookAt", 0.2f);
		}
		
		if (alId == H64("StopWaitForLookAt"))
		{			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") StopWaitForLookAt no lookat");
			mpStateMachine.StopTimer("WaitForLookAt");
			mpStateMachine.AddTimer("MoveToBestHole", 0.0f);
		}
		
		if (alId == H64("InvestigateSoundEmerge"))
		{
			mbEmerge_InvestigatSound = true;
			mvEmerge_InvestigatSoundPos = mvHideInHole_SoundPos;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Investigate sound emerge");
			Emerge(m_idHideInHole_Hole, 5.0f);
		}
		
		if (alId == H64("WaitInvestigateSound"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") WaitInvestigateSound");
			HideInHole_StopTimers();
			mpStateMachine.AddTimer("MoveToBestHole", 5.0f);
			mpStateMachine.AddTimer("ResetNoiseCount", 5.0f);
		}
		
		if (alId == H64("InterceptEmerge"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") InterceptEmerge");
			mbEmerge_InstantHunt = true;
			Emerge(m_idHideInHole_Hole, 0.0f);
		}
		
		if (alId == H64("EnableHearing"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EnableHearing");
			mbHideInHole_CanHear = true;
		}
		
		if (alId == H64("LowerFear"))
		{
			FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), 0.2f);
		}
		
		if (alId == H64("ClosedHoleCheck"))
		{
			if (cLux_ID_Entity(m_idHideInHole_Hole).IsActive() == false)
			{
				HideInHole_StopTimers();
				if (mbHideInHole_InvestigateSound)
				{
					WallMoveTo(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mvHideInHole_SoundPos), "InvestigateSoundEmerge");
				}
				else
				{
					WallMoveTo(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition()), "MoveAway");
				}
			}
			mpStateMachine.AddTimer("ClosedHoleCheck", 0.2f);
		}
		
		if (alId == H64("ResetNoiseCount"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reset noise count");
			mbHideInHole_InvestigateSound = false;
			mlHideInHole_NoiseCount = 0;
			mpStateMachine.AddTimer("MoveToBestHole", cMath_RandRectf(2.0f, 4.0f));
		}
	}
	
	//------------------------------------------------------------
	
	void HideInHole_ExecuteEnterCallback()
	{
		if (msHideInHole_EnterCallback == "") return;
		
		tString sMethodName = "void " + msHideInHole_EnterCallback + "(const tString &in asEntity, const tString &in asHoleName)";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.SetArgString(0, mBaseObj.GetName());
			pMap.SetArgString(1, cLux_ID_Entity(m_idReturnToHole_Hole).GetName());
			pMap.ScriptExecute();
		}
		
		if (mbHideInHole_EnterCallbackAutoRemove) msHideInHole_EnterCallback = "";
	}
	
	//------------------------------------------------------------
	
	bool mbWallMove = false;
	bool mbWallMoveApproach = false;
	cVector3f mvWallMoveGoal;
	cVector3f mvWallMoveSegmentEnd;
	array<cVector3f> mvWallMoveNodes;
	float mfWallMoveSpeed = 7.0f;
	tString msWallMoveEndCallback = "";
	
	void UpdateWallMovement(float afTimeStep)
	{
		if (mbWallMove == false) return;
		
		float fDist = cMath_Vector3Dist(mvWallMoveSegmentEnd, mBaseObj.GetPosition());		
		if (fDist <= 0.05f)
		{
			mBaseObj.SetPosition(mvWallMoveSegmentEnd);
			UpdateWallMoveSegment();
			return;
		}
		
		if (mbWallMoveApproach == false && cMath_Vector3Dist(mvWallMoveGoal, mBaseObj.GetPosition()) <= 8.0f)
		{
			mbWallMoveApproach = true;
			WallMoveApproach();
		}
		
		if (mbWallMoveApproach)
		{
			float fParam = 1.f - (cMath_Vector3Dist(mvWallMoveGoal, mBaseObj.GetPosition()) / 8.f);
			Sound_SetParam("HoleActive", 0, fParam);
		}
		
		float fFrameMove = mfWallMoveSpeed * afTimeStep;
		fFrameMove = cMath_Clamp(fFrameMove, 0.0f, fDist);
		
		cVector3f vMoveDir = mvWallMoveSegmentEnd - mBaseObj.GetPosition();
		vMoveDir.Normalize();
		
		cVector3f vNewPos = mBaseObj.GetPosition();
		vNewPos += vMoveDir * fFrameMove;
		mBaseObj.SetPosition(vNewPos);
	}
	
	//------------------------------------------------------------
	
	void HideInHole_StopTimers()
	{
		mpStateMachine.StopTimer("MoveAway");
		mpStateMachine.StopTimer("MoveAwayEnd");
		mpStateMachine.StopTimer("MoveToBestHole");
		mpStateMachine.StopTimer("DecideEmerge");
		mpStateMachine.StopTimer("WaitForLookAt");
		mpStateMachine.StopTimer("StopWaitForLookAt");
		mpStateMachine.StopTimer("InvestigateSoundEmerge");
		mpStateMachine.StopTimer("WaitInvestigateSound");
		mpStateMachine.StopTimer("InvestigateSoundEmerge");
	}
	
	//------------------------------------------------------------
	
	void WallMoveTo(tID a_idHole, tString asEndCallbackTimer = "")
	{
		iLuxEntity@ pHole = cLux_ID_Entity(a_idHole);
		if (pHole is null)
		{
//			WallMoveEnd();
			return;
		}
		if (m_idHideInHole_Hole == a_idHole) return;

		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") WallMove: start moving to " + pHole.GetName(), false, true);
		
		mbWallMoveApproach = false;
		
		Blackboard_RemoveGhoulHoleUsed(m_idHideInHole_Hole);
		Blackboard_SetGhoulHoleUsed(a_idHole, mBaseObj.GetID());
		m_idHideInHole_Hole = a_idHole;
		
		msWallMoveEndCallback = asEndCallbackTimer;
				
		FearThreatAgent_SetComponentEnabled(mBaseObj.GetName(), true);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfHideInHole_MovingFear);
		mpStateMachine.StopTimer("LowerFear");
		
		mvWallMoveGoal = pHole.GetPosition();
		mbWallMove = true;
		
		mvWallMoveNodes.resize(0);
		UpdateWallMoveSegment();
		
		Sound_Stop("WallMoveStart", 0.0f);
		Sound_Stop("WallMoveLoop", 0.0f);
		Sound_Stop("HoleActive", 0.0f);
		Sound_Stop("HoleArrived", 0.0f);
		
		Sound_CreateAtEntity("WallMoveStart", gsGhoulSound_WallMoveStart, mBaseObj.GetName());
		Sound_CreateAtEntity("WallMoveLoop", gsGhoulSound_WallMoveLoop, mBaseObj.GetName());
	}
	
	//------------------------------------------------------------
	
	void WallMoveApproach()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") WallMove: approaching destination " + cLux_ID_Entity(m_idHideInHole_Hole).GetName(), false, false);
		
		Sound_Stop("WallMoveLoop", 1.0f);
		Sound_CreateAtEntity("HoleActive", gsGhoulSound_HoleActiveLoop, cLux_ID_Entity(m_idHideInHole_Hole).GetName());
	}
	
	//------------------------------------------------------------
	
	void WallMoveEnd()
	{
		cLux_AddDebugMessage("WALL MOVE END");
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") WallMove: arrived at destination " + cLux_ID_Entity(m_idHideInHole_Hole).GetName(), false, true);
		
		mbWallMove = false;
		
		mpStateMachine.AddTimer("LowerFear", 5.0f);			
		
		Sound_Stop("HoleActive", 1.0f);
		Sound_CreateAtEntity("HoleArrived", gsGhoulSound_HoleArrived, cLux_ID_Entity(m_idHideInHole_Hole).GetName());
		ParticleSystem_CreateAtEntity("PS_HoleArrived", "ghoul_hole_arrive", cLux_ID_Entity(m_idHideInHole_Hole).GetName(), false);
		
		if (msWallMoveEndCallback != "") mpStateMachine.AddTimer(msWallMoveEndCallback, 0.0f);		
	}
	
	//------------------------------------------------------------
	
	void StopWallMove()
	{
		mbWallMove = false;
	}
	
	//------------------------------------------------------------
	
	void UpdateWallMoveSegment()
	{
		if (mvWallMoveNodes.size() == 0)
		{
			array<cVector3f> vNodes = Blackboard_GetClosestWallConnection(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), mvWallMoveGoal, -1.0f, 4.0f);
			if (vNodes.size() < 2)
			{
				cLux_AddDebugMessage("GHOUL GO TO GOAL");
				mvWallMoveSegmentEnd = mvWallMoveGoal;
				float fGoalDist = cMath_Vector3Dist(mvWallMoveGoal, mBaseObj.GetPosition());
				if (fGoalDist <= 0.05f) WallMoveEnd();
				return;
			}
			else
			{
				
				mvWallMoveNodes.push_back(vNodes[0]);
				mvWallMoveNodes.push_back(vNodes[1]);
			}
		}
		mvWallMoveSegmentEnd = mvWallMoveNodes[0];
		mvWallMoveNodes.pop_front();
	}

	//------------------------------------------------------------

	//} END HIDE IN HOLE

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: EMERGE
	//{////////////////////////////////

	//------------------------------------------------------------
	
	tID m_idEmerge_Hole = tID_Invalid;
	bool mbEmerge_InvestigatSound = false;
	bool mbEmerge_InstantHunt = false;
	bool mbEmerge_Spotted = false;
	cVector3f mvEmerge_InvestigatSoundPos;
	tString msEmerge_CompletedCallback = "";
	bool mbEmerge_CompletedCallbackAutoRemove = false;
	
	tString msEmerge_CustomAnim = "";
	tString msEmerge_CustomEmergeEntity = "";
	cVector3f mvEmerge_CrawlDir;
	cVector3f mvEmerge_CrawlEndPos;
	bool mbEmerge_Crawling = false;
	bool mbEmerge_CrawlingAnim = false;
		
	tID m_idEmerge_CommandHole = tID_Invalid;
	
	//------------------------------------------------------------

    void State_Emerge_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Emerge ------", false, true);
		
		mbEmerge_Spotted = false;
		
		if (m_idEmerge_Hole == tID_Invalid)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Cannot emerge because no spawn area set, return to HideInHole");
			mpStateMachine.ChangeState(eGhoulState_HideInHole);
			return;
		}
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Emerge from: "+ cLux_ID_Entity(m_idEmerge_Hole).GetName());
		
		mpSoundListener.SetHearRadius(mfHearRadius);
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);
		
		Blackboard_RemoveGhoulHoleUsed(m_idEmerge_Hole);

		mbHidden = false;
		PositionAtGhoulHole(m_idEmerge_Hole);
		
		SetHidden(false);		
		msAnimState = "InitialEmerge";
		
		mpPathfinder.Stop();
		mpMover.StopTurning();
		mBaseObj.GetCharBody().StopMovement();
		
		mbProximityDetectionActive = false;
		
		/////////////////////////////
		// Custom emerge anim?
		if (msEmerge_CustomAnim != "")
		{
			iLuxEntity@ pEnt = mBaseObj.GetMap().GetEntityByName(msEmerge_CustomEmergeEntity);
			if (pEnt !is null)
			{
				iCharacterBody@ pBody = mBaseObj.GetCharBody();
				pBody.SetTestCollision(false);
				
				float fYaw = cMath_GetAngleFromPoints3D(0, pEnt.GetMatrix().GetTranspose().GetForward()).y;
				pBody.SetYaw(fYaw);
				
				pBody.SetFeetPosition(pEnt.GetPosition(), false);				
			}
			
			mpMover.PlayAnimation(msEmerge_CustomAnim, 0.f, false, false);			
		}
		else
		{
			mvEmerge_CrawlEndPos = mBaseObj.GetCharBody().GetFeetPosition();
			mvEmerge_CrawlDir = cLux_ID_Entity(m_idEmerge_Hole).GetMainBody().GetWorldMatrix().GetTranspose().GetForward();
			cVector3f vNewPos = mvEmerge_CrawlEndPos - mvEmerge_CrawlDir * 3;
			mBaseObj.GetCharBody().SetFeetPosition(vNewPos, false);
			
			Debug_DrawSphere(mvEmerge_CrawlEndPos, 0.2, cColor_Blue * 2, 5);
			Debug_DrawSphere(vNewPos, 0.2, cColor_Blue * 2, 5);
			Debug_DrawLine(mvEmerge_CrawlEndPos, vNewPos, cColor_Blue * 2, 5);
						
			mBaseObj.GetCharBody().SetActive(false);
			mBaseObj.GetCharBody().SetGravityActive(false);
			
			mbEmerge_Crawling = true;
			
			mpMover.PlayAnimation(gsGhoulAnim_CrawlLoop, 0, true);
			mbEmerge_CrawlingAnim = true;
			
			cVector3f vPSPos = mvEmerge_CrawlEndPos - mvEmerge_CrawlDir * 0.2f;
			vPSPos += cVector3f_Up * 0.5f;
			cParticleSystem@ pPS = mBaseObj.CreateParticleSystem("EmergeParticles", "ghoul_emerge", true, false);
			if (pPS !is null) pPS.SetPosition(vPSPos);
		}
		
		mBaseObj.PlaySound("EmergeSound", gsGhoulSound_CrawlOut, true, true);		
		mBaseObj.PlaySound("EmergeFoleySound", gsGhoulSound_CrawlOutFoley, true, true);	
	}
	
	//------------------------------------------------------------

	void State_Emerge_Leave()
	{
		mBaseObj.GetCharBody().SetActive(true);
		mBaseObj.GetCharBody().SetGravityActive(true);
		
		m_idEmerge_Hole = tID_Invalid;
		mbEmerge_InvestigatSound = false;
		mbEmerge_InstantHunt = false;
		mbProximityDetectionActive = true;
		
		Terror_RemoveEnemy(mBaseObj.GetID());
	}
	
	//------------------------------------------------------------

	void State_Emerge_Update(float afTimeStep)
	{
		if (mbEmerge_Spotted == false && Terror_GetAmount() > 0.5f)
		{
			mbEmerge_Spotted = true;
		}
		
		if (mbEmerge_Crawling)
		{
			cVector3f vNewPos = mBaseObj.GetCharBody().GetFeetPosition() + mvEmerge_CrawlDir * 3 * afTimeStep;
			cVector3f vToGoal = mvEmerge_CrawlEndPos - mBaseObj.GetCharBody().GetFeetPosition();
			if (mbEmerge_CrawlingAnim && vToGoal.Length() < 0.5f)
			{
				mbEmerge_CrawlingAnim = false;
				mpMover.PlayAnimation(gsGhoulAnim_CrawlExit, 0.3f, false);
			}
			
			if (cMath_Vector3Dot(mvEmerge_CrawlDir, vToGoal) <= 0)
			{
				vNewPos = mvEmerge_CrawlEndPos;
				mbEmerge_Crawling = false;
			}
			mBaseObj.GetCharBody().SetFeetPosition(vNewPos, false);
		}
	}
	
	//------------------------------------------------------------

	bool State_Emerge_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "InitialEmerge")
			{
				mBaseObj.GetCharBody().SetActive(true);
				mBaseObj.GetCharBody().SetGravityActive(true);
				
				if (mBaseObj.GetDistanceToPlayer() < 5 || mbEmerge_InstantHunt) mpStateMachine.ChangeState(eGhoulState_Hunt);
				else mpStateMachine.AddTimer("LookAround", 0);
				
				if (msEmerge_CustomAnim != "")
				{
					msEmerge_CustomAnim = "";
					msEmerge_CustomEmergeEntity = "";
					
					iCharacterBody@ pBody = mBaseObj.GetCharBody();
					pBody.SetTestCollision(true);
					pBody.SetFeetPosition(mBaseObj.GetMeshEntity().GetBoneStateFromName("j_Char_Root").GetWorldPosition(), false);
				}
			}
			else if (msAnimState == "LookAround")
			{
				DecidePostEmergeBehavior();
			}
			
			msAnimState = "";
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			if (mbPreAlert) return true;
			
			Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			Terror_RemoveEnemy(mBaseObj.GetID());
			return true;
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Emerge_TimerUp(uint64 alId)
	{
		if (alId == H64("LookAround"))
		{
			if (UsesVoice() && msEmergeSubject != "") mpBarkMachine.PlayVoice(msEmergeSubject, 1);
			else mBaseObj.PlaySound("LookAround", gsGhoulSound_LookAround, true, true);
			
			msAnimState = "LookAround";
			mBaseObj.GetCharBody().SetFeetPosition(mvEmerge_CrawlEndPos + mvEmerge_CrawlDir * 0.5, false);
			PlayRandomAnimation(mvGhoulAnim_LookAroundLong, 0, false, false, "");
		}
	}

	//------------------------------------------------------------
	
	void Emerge_ExecuteCompletedCallback()
	{
		if (msEmerge_CompletedCallback == "") return;
		
		tString sMethodName = "void " + msEmerge_CompletedCallback + "(const tString &in asGhoul, const tString &in asHole)";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
            pMap.SetArgString(0, mBaseObj.GetName());
            pMap.SetArgString(1, cLux_ID_Entity(m_idEmerge_Hole).GetName());
			pMap.ScriptExecute();
		}
		
		if (mbEmerge_CompletedCallbackAutoRemove) msEmerge_CompletedCallback = "";
	}
	
	//------------------------------------------------------------
	
	void DecidePostEmergeBehavior()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Decide post emerge behavior");
		
		Emerge_ExecuteCompletedCallback();	
		if (mCommand == eGhoulCommand_EmergeFromHole)
		{
			mCommand = eGhoulCommand_None;
			ExecuteEntityCallback(msCommandCompletedCallback);
		}
		
		if (mbEmerge_Spotted)
		{
			mpStateMachine.ChangeState(mBaseObj.PlayerIsDetected() ? eGhoulState_Hunt : eGhoulState_CheckLastKnownPosition);
			return;
		}
		
		if (mbEmerge_InvestigatSound)
		{
			mvSearchArea_SearchPos = mvEmerge_InvestigatSoundPos;
			mpStateMachine.ChangeState(eGhoulState_SearchArea);
			return;
		}
		
		Idle_DecideBehavior();
		if (mpStateMachine.GetNextState() != eGhoulState_Emerge) return;
		
		float fRand = cMath_RandRectf(0.0f, 1.0f);
		if (fRand < -0.5f)
		{
			mvWanderArea_AreaCenter = mBaseObj.GetPosition();
			mvWanderArea_AreaCenter += mBaseObj.GetCharBody().GetForward() * 5.0f;
			mfWanderArea_MinRadius = 2.0f;
			mfWanderArea_MaxRadius = 10.0f;
			mfWanderArea_Time = cMath_RandRectf(8.0f, 12.0f);
			mpStateMachine.ChangeState(eGhoulState_WanderArea);
		}
		else
		{
			tID idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), -1.0f, -1.0f, true, false, true, false, array<tID> = { m_idEmerge_Hole });
			if (idHole == tID_Invalid)
			{
				idHole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition(), -1.0f, -1.0f, true, false, false, false, array<tID> = { m_idEmerge_Hole });
			}
			ReturnToHole(idHole);
		}
	}
	
	//------------------------------------------------------------
	
	void SetHidden(bool abHidden, bool abAffectCharBody = true)
	{
		mbHidden = abHidden;
		if (abAffectCharBody)
		{
			mBaseObj.GetCharBody().SetActive(!abHidden);
		}
		mBaseObj.GetMeshEntity().SetActive(!abHidden);
		mBaseObj.GetMeshEntity().SetVisible(!abHidden);
	}
	
	//------------------------------------------------------------
	
	tID m_idEmergeDelayed_Hole = tID_Invalid;
	void Emerge(tID a_idHole, float afDelay = 0.0f)
	{
		m_idEmergeDelayed_Hole = a_idHole;
		mBaseObj.Timer_Remove("EmergeDelayed");
		mBaseObj.Timer_Add("EmergeDelayed", afDelay, "EmergeDelayed");
		if (afDelay > 3.0f) mBaseObj.Timer_Add("EmergeAlert", 1.0f, "EmergeAlert");
	}
	
	void EmergeAlert(uint64 alID)
	{
		mBaseObj.PlaySound("AlertEmerge", gsGhoulSound_EmergeAlert, true, true);
		FearThreatAgent_SetComponentEnabled(mBaseObj.GetName(), true);
	}
	
	void EmergeDelayed(uint64 alID)
	{
		m_idEmerge_Hole	= m_idEmergeDelayed_Hole;
		mpStateMachine.ChangeState(eGhoulState_Emerge);
	}
	
	//------------------------------------------------------------

	//} END EMERGE

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: WANDER TO EXIT HOLE
	//{////////////////////////////////

	//------------------------------------------------------------
	
	int mlWanderToExitHole_WandersToDo = -1;
	int mlWanderToExitHole_CurrentWander = 0;
	cVector3f mvWanderToExitHole_Goal;
	
	//------------------------------------------------------------

    void State_WanderToExitHole_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: WanderToExitHole ------",false,true);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		
		if (mlWanderToExitHole_CurrentWander <= 0)
		{
			mlWanderToExitHole_WandersToDo = cMath_RandRectl(glMinExitHoleWanders, glMaxExitHoleWanders);
//			cLuxArea@ pSpawn = GetRandomSpawn(mSpawnHole);
			cLuxArea@ pSpawn;
			if (pSpawn !is null)
			{
				@mExitHole = pSpawn;
			}
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No holes available, return to idle");
				mpStateMachine.ChangeState(eGhoulState_Idle);
				return;
			}
		}
		
		if (mlWanderToExitHole_CurrentWander < mlWanderToExitHole_WandersToDo)
		{
			++mlWanderToExitHole_CurrentWander;
		}
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Wander " + mlWanderToExitHole_CurrentWander + "/" +mlWanderToExitHole_WandersToDo);

		//////////////////////////
		// Keep moving towards the exit hole in steps, depending on how many wanders are left
		float fWanderPercentageRemaining = 1.0f - (float(mlWanderToExitHole_CurrentWander - 1) / float(mlWanderToExitHole_WandersToDo));
		float fWanderProgressStep = 1.0f / float(mlWanderToExitHole_WandersToDo);
		float fNewWanderProgress = 1.0f / fWanderPercentageRemaining * fWanderProgressStep;
		cVector3f vStart = mlWanderToExitHole_CurrentWander == 1 ? mBaseObj.GetPosition() : mvWanderToExitHole_Goal;
		mvWanderToExitHole_Goal = (vStart * (1.0f - fNewWanderProgress)) + (mExitHole.GetPosition() * fNewWanderProgress);
		
		cAINode @pNode = mpPathfinder.GetNodeAtPos(mvWanderToExitHole_Goal, 3.0f, 6.0f, false, false, false, null);
		if (pNode !is null)
		{
			mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
			mpPathfinder.MoveTo(pNode.GetPosition(), 1, false);
		}
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Couldn't find a node at the wander goal, transition to random wander");
//			mpStateMachine.ChangeState(eGhoulState_RandomWanderArea);
			return;
		}
	}
	
	//------------------------------------------------------------

	void State_WanderToExitHole_Leave()
	{
	}
	
	//------------------------------------------------------------

	void State_WanderToExitHole_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_WanderToExitHole_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mlWanderToExitHole_CurrentWander >= mlWanderToExitHole_WandersToDo)
			{
				mpStateMachine.AddTimer("ToReturnToHole", cMath_RandRectf(2.0f, 3.0f));
			}
			else
			{
				mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(2.0f, 3.0f));
			}
			return true;
		}

		return false;
	}
	
	//------------------------------------------------------------

	void State_WanderToExitHole_TimerUp(uint64 alId)
	{
		if(alId == H64("ToReturnToHole"))
		{
			mpStateMachine.ChangeState(eGhoulState_ReturnToHole);
		}

		if (alId == H64("ToIdle"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
		
		if(alId == H64("CheckDeadEnd"))
		{
			HandlePlayerDeadEnd(0.1f, 10.0f);
			mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
		}
	}

	//------------------------------------------------------------

	//} END WANDER

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: WANDER AREA
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvWanderArea_AreaCenter;
	float mfWanderArea_MinRadius = 2.0f;
	float mfWanderArea_MaxRadius = 10.0f;
	float mfWanderArea_Time = 2.0f;
	
	//------------------------------------------------------------

	void State_WanderArea_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: WanderArea ------", false, true);
		
		mpStateMachine.AddTimer("WanderToSpot", 0.0f);
		mpStateMachine.AddTimer("CheckIdle", 0.5f);
		if (mfWanderArea_Time >= 0.0f) mpStateMachine.AddTimer("Exit", mfWanderArea_Time);
	}

	//------------------------------------------------------------

	void State_WanderArea_Leave()
	{
	}

	//------------------------------------------------------------

	void State_WanderArea_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
		UpdateSmellDetection(afTimeStep);
//		UpdateQuickHoleReturn(afTimeStep, 14.0f, true);
	}

	//------------------------------------------------------------

	bool State_WanderArea_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpStateMachine.AddTimer("WanderToSpot", 1.0f);
			return true;
		}
		return false;
	}

	//------------------------------------------------------------

	void State_WanderArea_TimerUp(uint64 alId)
	{
		if (alId == H64("WanderToSpot"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Wander to spot");
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvWanderArea_AreaCenter, mfWanderArea_MinRadius, mfWanderArea_MaxRadius, false, false, true, null);
			if (pNode is null) 
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No spot found, return to idle");
				mpStateMachine.ChangeState(eGhoulState_Idle);
				return;
			}
			mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
		}
		
		if (alId == H64("CheckIdle"))
		{
			Idle_DecideBehavior();
			mpStateMachine.AddTimer("CheckIdle", 0.5f);
		}
		
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}

	//------------------------------------------------------------

	//} END WANDER AREA
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: TRACK SMELL
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfTrackSmell_SmellRadius = 7.0f;
	float mfTrackSmell_GiveUpCounterMax = 18.0f;
	
	float mlTrackSmell_CurrentSmellId = -1;
	cVector3f mvTrackSmell_CurrentSmell;
	cVector3f mvTrackSmell_MoveTo;
	float mvTrackSmell_CurrentSmellRadius;
	tString msTrackSmell_AnimState;
	bool mbTrackSmell_Moving = false;
	bool mbTrackSmell_EndOfPath = false;
	bool mbTrackSmell_MovingSound = false;
	bool mbTrackSmell_QueueInvestigateSound = false;
	bool mbTrackSmell_LostTrack = false;
	bool mbTrackSmell_Enabled = true;
	float mfTrackSmell_GiveUpCounter = 0.0f;
	float mfTrackSmell_EndOfPathGiveUpTimer = 0.0f;
	bool mbTracksMell_Unreachable = false;
	bool mbTrackSmell_CheckSmellRedirect = false;

	//------------------------------------------------------------

    void State_TrackSmell_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: TrackSmell ------", false, true);
				
		if (mbTrackSmell_Enabled == false || GetSensesActive(false) == false || mbDetectSmell == false)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Smelling disabled, return to idle");
			CommandSmell_Complete();
			mpStateMachine.ChangeState(eGhoulState_Idle);
			return;
		}
		
		EnterInvestigateState();
		
		mpSoundListener.SetSoundRadiusMul(mfHearingMul * 1.2f);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
		mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkSearch);
		
		mlTrackSmell_CurrentSmellId = -1;
		mvTrackSmell_CurrentSmell = cVector3f_Zero;
		mbTrackSmell_Moving = false;
		mbTrackSmell_QueueInvestigateSound = false;
		mfTrackSmell_GiveUpCounter = mfTrackSmell_GiveUpCounterMax;
		mbTrackSmell_LostTrack = false;
		mbTracksMell_Unreachable = false;
		mfTrackSmell_EndOfPathGiveUpTimer = 0;
		
		mpStateMachine.AddTimer("InitialSmell", 0.2);

//		msTrackSmell_AnimState = "InitialSmell";
//		TrackSmell_Smell();
	}
	
	//------------------------------------------------------------

	void State_TrackSmell_Leave()
	{
		if (mbPatrol_SmellPatrol == false || mbPatrol_SmellPatrol && mCommand != eGhoulCommand_Patrol)
			LeaveInvesitgateState();
		
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);
		mpMover.SetWalkAnimName(msWalkAnim);
		mpMover.SetMaxForwardSpeed(1.0f);
		
		for (int i = 0; i < mvGhoulAnim_Sniff.size(); ++i) mBaseObj.StopAnimation(mvGhoulAnim_Sniff[i], 0.2f);
		mBaseObj.StopAnimation(gsGhoulAnim_Frustration, 0.2f);
		
		Sound_Stop("Smell_TrackingLoop", 0.2f);
	}
	
	//------------------------------------------------------------

	void State_TrackSmell_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
		
		if (mbTrackSmell_LostTrack == false)
		{
			mfTrackSmell_GiveUpCounter -= afTimeStep;
			mfTrackSmell_GiveUpCounter = cMath_Clamp(mfTrackSmell_GiveUpCounter, 0.0f, mfTrackSmell_GiveUpCounterMax);
			
			if (mfTrackSmell_GiveUpCounter == 0.0f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Give up due to counter");
				TrackSmell_LostTrack();
			}
		}

		if (mbTrackSmell_Moving)
		{
			if (mbTrackSmell_MovingSound == false)
			{
				mbTrackSmell_MovingSound = true;
				Sound_CreateAtEntity("Smell_TrackingLoop", gsGhoulSound_SmellTrackingLoop, mBaseObj.GetName());
				Sound_SetParam("Smell_TrackingLoop", gsGhoulSound_SmellTrackingLoop_ParamIntensity, 0.0f);
			}
			else
			{
				cBreadcrumb@ pBread = Blackboard_GetBreadcrumb(mlTrackSmell_CurrentSmellId);
				bool bIntense = false;
				if (pBread !is null)
				{
					float fDist = cMath_Vector3Dist(mBaseObj.GetPosition(), pBread.mvPosition);
					if (fDist <= pBread.mfRadius * 0.6f && mBaseObj.GetDistanceToPlayer() <= 5.0f) bIntense = true;
				}
				
				mpMover.SetMaxForwardSpeed(bIntense ? 0.8f : 1.3f);
				Sound_SetParam("Smell_TrackingLoop", gsGhoulSound_SmellTrackingLoop_ParamIntensity, bIntense ? 1.0f : 0.0f);
			}
		}
		else
		{
			if (mbTrackSmell_MovingSound)
			{
				mbTrackSmell_MovingSound = false;
				Sound_Stop("Smell_TrackingLoop", 0.5f);
			}
		}
	}
	
	//------------------------------------------------------------

	bool State_TrackSmell_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msTrackSmell_AnimState == "InitialSmell")
			{
				if (mbTrackSmell_QueueInvestigateSound) mpStateMachine.ChangeState(eGhoulState_InvestigateSound);
				else mpStateMachine.AddTimer("CheckSmell", 0.2f);
				
				CommandSmell_Complete();
			}
			else if (msTrackSmell_AnimState == "CheckGoal")
			{
				mpStateMachine.AddTimer("CheckSmell", 0.2f);
			}
			else if (msTrackSmell_AnimState == "LostTrack")
			{
				if (mbTrackSmell_QueueInvestigateSound)
				{
					mpStateMachine.ChangeState(eGhoulState_InvestigateSound);
				}
				else
				{
					TrackSmell_Disable(15.0f);
					mpStateMachine.ChangeState(eGhoulState_Idle);
				}
			}
			
			msTrackSmell_AnimState = "";
			return true;
		}
		
//		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
//		{
//			mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
//			mpStateMachine.ChangeState(eGhoulState_CheckGobo);
//			return true;
//		}
//		
//		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
//		{
//			mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
//			mpStateMachine.ChangeState(eGhoulState_CheckFlashlightHit);
//			return true;
//		}
		
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetSensesActive() == false) return true;
			
			if (msTrackSmell_AnimState == "LostTrack" || msTrackSmell_AnimState == "InitialSmell")
			{
				mvInvestigateSound_Goal = mpStateMachine.GetCurrentMessageData().mvX;
				mlInvestigateSound_Prio = mpStateMachine.GetCurrentMessageData().mlX;
				mbTrackSmell_QueueInvestigateSound = true;
				return true;
			}
			return false;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mbTracksMell_Unreachable)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Got as close as we could to unreachable smell");
				mpStateMachine.StopTimer("CheckGoal");
				mpStateMachine.AddTimer("CheckSmell", 0.0f);
			}
			mbTrackSmell_EndOfPath = true;
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_TrackSmell_TimerUp(uint64 alId)
	{
		if (alId == H64("InitialSmell"))
		{
			msTrackSmell_AnimState = "InitialSmell";
			TrackSmell_Smell();
		}
		
		else if (alId == H64("CheckSmell"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") CheckSmell");
			
			cBreadcrumb@ pBread = Blackboard_GetStrongestBreadcrumb(mBaseObj.GetPosition(), mfTrackSmell_SmellRadius);
			if (GetSensesActive(false) && pBread !is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Found strongest breadcrumb");
				mvTrackSmell_CurrentSmell = pBread.mvPosition;
				mlTrackSmell_CurrentSmellId = pBread.mlId;
				mvTrackSmell_CurrentSmellRadius = pBread.mfRadius;
				
				cAINode@ pNode = mpPathfinder.GetNodeInPosLOS(mvTrackSmell_CurrentSmell, 3.0f, 6.0f, false);
				if (pNode !is null)
				{
					mbTracksMell_Unreachable = false;
				}
				else if (mbTracksMell_Unreachable == false)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Couldn't find node near breadcrumb, get closest");
					mbTracksMell_Unreachable = true;
					@pNode = mpPathfinder.GetNodeAtPos(mvTrackSmell_CurrentSmell, 0.0f, 10.0f, true, false, false, null);
				}
				
				if (pNode !is null)
				{
					mpPathfinder.BuildPathNodeArrayToPos(pNode.GetPosition());
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Path size: " + mpPathfinder.GetPathNodeArraySize() + " length: " + mpPathfinder.GetPathNodeArrayFullLength());
					if (mpPathfinder.GetPathNodeArraySize() == 0)
					{
						@pNode = null;
					}
				}
				
				if (pNode is null)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Couldn't find node anywhere near the breadcrumb, return to idle");
					TrackSmell_Disable(15.0f);
					mpStateMachine.ChangeState(eGhoulState_Idle);
					return;
				}
				
				mfTrackSmell_EndOfPathGiveUpTimer = 0;
				mbTrackSmell_EndOfPath = false;
				mbTrackSmell_Moving = true;
				mvTrackSmell_MoveTo = pNode.GetPosition();
				if (mbTrackSmell_CheckSmellRedirect == false) mBaseObj.PlaySound("SmellStartTracking", gsGhoulSound_SmellStartTracking, true, true);
				mbTrackSmell_CheckSmellRedirect = false;
				
				mpStateMachine.AddTimer("MoveToGoal", 0.5f);
				mpStateMachine.StopTimer("CheckGoal");
				mpStateMachine.AddTimer("CheckGoal", 1.0f);
			}
			else
			{
				TrackSmell_LostTrack();
			}
		}
		
		else if (alId == H64("MoveToGoal"))
		{
			if (mbTrackSmell_Moving == false) return;
						
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveToGoal");
			mpPathfinder.MoveTo(mvTrackSmell_MoveTo, 1.0f, false);
			mpStateMachine.AddTimer("MoveToGoal", 0.5f);
		}
		
		else if (alId == H64("CheckGoal"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Check goal");
			
			if (mbTrackSmell_EndOfPath)
			{
				mfTrackSmell_EndOfPathGiveUpTimer += 0.5f;
				if (mfTrackSmell_EndOfPathGiveUpTimer > 2)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Give up due to end of path counter");
					TrackSmell_LostTrack();
					return;
				}
			}
			
			float fPickupRadius = mbTrackSmell_EndOfPath ? 5.0f : 2.0f;
			if (mlTrackSmell_CurrentSmellId >= 0 && cMath_Vector3Dist(mvTrackSmell_CurrentSmell, mBaseObj.GetPosition()) < fPickupRadius && TrackSmell_SmellLOS())
			{
				mfTrackSmell_GiveUpCounter += mvTrackSmell_CurrentSmellRadius * 1.5f;
				TrackSmell_PickupBreadcrumb(mlTrackSmell_CurrentSmellId);
				mlTrackSmell_CurrentSmellId = -1;
			
				mbTrackSmell_Moving = false;
				mpPathfinder.Stop();
				
				mpStateMachine.AddTimer("CheckGoalReact", 0.2f);
				return;
			}
			
			cBreadcrumb@ pBread = Blackboard_GetStrongestBreadcrumb(mBaseObj.GetPosition(), mfTrackSmell_SmellRadius);
			if (pBread !is null && pBread.mlId >= 0 && pBread.mfRadius >= 1.2f * mvTrackSmell_CurrentSmellRadius)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Found really strong scent nearby, changing direction");
				mbTrackSmell_CheckSmellRedirect = true;
				mpStateMachine.AddTimer("CheckSmell", 0.0f);
				return;
			}
			
			mpStateMachine.AddTimer("PickupPeripherals", 0.1f);
			mpStateMachine.AddTimer("CheckGoal", 0.5f);
		}
		
		else if (alId == H64("PickupPeripherals"))
		{
			TrackSmell_PickupPeripheralBreadcrumb();
		}
		
		else if (alId == H64("CheckGoalReact"))
		{
			msTrackSmell_AnimState = "CheckGoal";
			TrackSmell_Smell();
		}
		
		else if (alId == H64("Smell"))
		{
			TrackSmell_Smell();
		}
	}
	
	//------------------------------------------------------------
	
	void TrackSmell_Smell()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Smell");
		PlayRandomAnimation(mvGhoulAnim_Sniff);
		mBaseObj.PlaySound("Smell", gsGhoulSound_Smell, true, true);
		
		cLuxMap@ pMap = mBaseObj.GetMap();
		tString sMethod = "void OnGhoulSmell(const tString &in asGhoul)";
		if (pMap.ScriptMethodExists(sMethod) && pMap.ScriptPrepare(sMethod))
		{
			pMap.SetArgString(0, mBaseObj.GetName());
			pMap.ScriptExecute();
		}
	}
	
	//------------------------------------------------------------
	
	void TrackSmell_PickupBreadcrumb(int alId)
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Pick up breadcrumb");
		Blackboard_RemoveBreadCrumb(alId);
	}
	
	//------------------------------------------------------------
	
	void TrackSmell_PickupPeripheralBreadcrumb()
	{
		cBreadcrumb@ pClosestBread = Blackboard_GetClosestBreadcrumb(mBaseObj.GetPosition());
		if (pClosestBread is null) return;
		if (pClosestBread.mlId == mlTrackSmell_CurrentSmellId) return;
		if (cMath_Vector3DistSqr(pClosestBread.mvPosition, mBaseObj.GetPosition()) > 4.0f * 4.0f) return;
		cVector3f vToBread = pClosestBread.mvPosition - mBaseObj.GetPosition();
		vToBread.Normalize();
		if (cMath_Vector3Angle(mBaseObj.GetCharBody().GetForward(), vToBread) <= cMath_ToRad(45.0f)) return;
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Pick up peripheral breadcrumb");
		TrackSmell_PickupBreadcrumb(pClosestBread.mlId);
	}
	
	//------------------------------------------------------------
	
	void TrackSmell_LostTrack()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Lost track");
		
		mpStateMachine.StopTimer("MoveToGoal");
		mpStateMachine.StopTimer("PickupPeripherals");
		mpStateMachine.StopTimer("CheckGoal");
		mpStateMachine.StopTimer("CheckGoalReact");

		mpPathfinder.Stop();
		mbTrackSmell_LostTrack = true;
		msTrackSmell_AnimState = "LostTrack";
		mpMover.PlayAnimation(gsGhoulAnim_Frustration);
		mBaseObj.PlaySound("LostTrack", gsGhoulSound_SmellLostTrack, true, true);
	}
	
	//------------------------------------------------------------
	
	void TrackSmell_Disable(float afTime)
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Disable smelling for " + afTime);
		
		mbTrackSmell_Enabled = false;
		mBaseObj.Timer_Remove("Timer_TrackSmell_Enable");
		mBaseObj.Timer_Add("Timer_TrackSmell_Enable", afTime, "OnTimer_TrackSmell_Enable");
	}
	
	bool TrackSmell_SmellLOS()
	{
		cVector3f vPos = mvTrackSmell_CurrentSmell;
		vPos.y += 1.0f;
		return mBaseObj.GetPointIsInLineOfSight(vPos);
		DrawTestRay(mBaseObj.GetEyePostion(), vPos, 1.0f);
	}
	
	//------------------------------------------------------------
	
	void CommandSmell_Complete()
	{
		if (mCommand == eGhoulCommand_Smell)
		{
			mCommand = eGhoulCommand_None;
			ExecuteEntityCallback(msCommandCompletedCallback);
		}
	}
	
	void OnTimer_TrackSmell_Enable(uint64 alID)
	{
		mbTrackSmell_Enabled = true;
	}
	
	//------------------------------------------------------------
	
	bool mbDetectSmell = false;
	float mfSmellDetection_Timer = 0.0f;
	float mfSmellDetection_SmellTimer = 0.0f;
	void UpdateSmellDetection(float afTimeStep)
	{
		if (GetSensesActive(false) == false) return;
		if (mbDetectSmell == false) return;
		
		mfSmellDetection_Timer += afTimeStep;
		if (mbTrackSmell_Enabled == false) return;
		
		if (mfSmellDetection_Timer >= 0.5f)
		{
			mfSmellDetection_Timer = 0.0f;
			
			cBreadcrumb@ pScent = Blackboard_GetStrongestBreadcrumbCenter(mBaseObj.GetPosition(), mfTrackSmell_SmellRadius);
			if (pScent !is null)
			{
				mfSmellDetection_SmellTimer += 0.5f;
				if (mfSmellDetection_SmellTimer >= 2.0f)
				{
					mfSmellDetection_SmellTimer = 0.0f;
					mpStateMachine.ChangeState(eGhoulState_TrackSmell);	
				}
			}
			else
			{
				mfSmellDetection_SmellTimer -= 0.5f;
			}
			
			mfSmellDetection_SmellTimer = cMath_Clamp(mfSmellDetection_SmellTimer, 0.0f, 2.0f);
		}
	}
	
	//------------------------------------------------------------

	//} END TRACK SMELL

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: SNIFF
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbSniff_InvestigateAfter = true;

	//------------------------------------------------------------

    void State_Sniff_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Sniff ------",false,true);
		
		mpPathfinder.Stop();
		
		if (UsesVoice() && msSmellSubject != "") mpBarkMachine.PlayVoice(msSmellSubject, 1);
		else mBaseObj.PlaySound("Sniff", gsGhoulSound_Smell, true, true);
		
		PlayRandomAnimation(mvGhoulAnim_Sniff, 0.0f, false, false, "");
		
		mpStateMachine.AddTimer("ConfirmSniffResult", cMath_RandRectf(2.5f, 3.5f));
        
        mfTimeSinceLastSniff = 0.f;
	}
	
	//------------------------------------------------------------

	void State_Sniff_Leave()
	{
	}
	
	//------------------------------------------------------------

	void State_Sniff_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Sniff_Message(int alMessageId)
	{
		return false;
	}
	
	//------------------------------------------------------------

	void State_Sniff_TimerUp(uint64 alId)
	{
		if (alId == H64("ConfirmSniffResult"))
		{
			if (mbSniff_InvestigateAfter == false)
			{
				mbSniff_InvestigateAfter = true;
				mpStateMachine.ChangeState(eGhoulState_Idle);
				return;
			}
			
			float fDist = mBaseObj.GetDistanceToPlayer();
			if (fDist < GetFinalSmellRange())
			{
				mBaseObj.PlaySound("SniffConfirm", gsGhoulSound_SmellStartTracking, true, true);
				mpStateMachine.ChangeState(eGhoulState_InvestigateSniff);
			}
			else
			{
				if (mpStateMachine.GetPrevState() == eGhoulState_SearchArea)
				{
					mpStateMachine.ChangeState(mpStateMachine.GetPrevState());
				}
				else
				{
					@mExitHole = GetClosestSpawn(mBaseObj.GetPosition());
					mpStateMachine.ChangeState(eGhoulState_Idle);
				}
			}
		}
	}
	
	//------------------------------------------------------------

	//} END SNIFF

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: INVESTIGATE SNIFF
	//{////////////////////////////////

	//------------------------------------------------------------

	cVector3f mvInvestigateSniff_Goal = cVector3f_Zero;
	float mfInvestigateSniff_MovedDist = 0.0f;
	float mfInvestigateSniff_Timeout = 0.0f;
	cVector3f mvInvestigateSniff_LastPos;
	bool mbInvestigateSniff_Continue = false;

	//------------------------------------------------------------

    void State_InvestigateSniff_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: InvestigateSniff ------",false,true);
		
		SetEyeColor(gGhoul_EyeColorAlerted);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearSpotted);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(mAlertState == eGhoulAlertState_None ? eGhoulSpeed_Walk : eGhoulSpeed_FastWalk);
		
		/////////////////////////////////////////////////////////////////////////////////////////////////////
		// When we investigate a smell, we do not go directly to the players position but somewhere nearby it
		// TODO: might be too precise
		mbAvoidingDeadEndPlayer = false;

		if (mbInvestigateSniff_Continue == false)
		{
			cVector3f vPos = mBaseObj.GetPlayerPos();
			if (mBaseObj.GetDistanceToPlayer() > 7.0f) vPos -= mBaseObj.GetPlayerDir() * 4.0f;
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(vPos, 3.0f, 5.0f, false, false, false, null);
			mvInvestigateSniff_Goal = pNode.GetPosition();
		}
		else
		{
			mbInvestigateSniff_Continue = false;
		}
		
		mpPathfinder.MoveTo(mvInvestigateSniff_Goal, 0.2f, false);
		mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
		mpStateMachine.AddTimer("LeaveSniffState", mbInvestigateSniff_Continue ? 10.0f : 20.0f);
		
		mAlertState = eGhoulAlertState_Investigating;
	}
	
	//------------------------------------------------------------

	void State_InvestigateSniff_Leave()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearDefault);
	}
	
	//------------------------------------------------------------

	void State_InvestigateSniff_Update(float afTimeStep)
	{
		mfInvestigateSniff_MovedDist = cMath_Vector3Dist(mBaseObj.GetPosition(), mvInvestigateSniff_LastPos);
		if (mfInvestigateSniff_MovedDist <= 0.01f)
			mfInvestigateSniff_Timeout += afTimeStep;
		else
			mfInvestigateSniff_Timeout = 0.0f;

		mvInvestigateSniff_LastPos = mBaseObj.GetPosition();

		if (mfInvestigateSniff_Timeout > 5.0f)
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}
	
	//------------------------------------------------------------

	bool State_InvestigateSniff_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_MovingAlert);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			cLux_AddTodoMessage("TODO-SOUND: look around");
			mBaseObj.PlaySound("LookAround", gsGhoulSound_LookAround, true, true);
				
			PlayRandomAnimation(mvGhoulAnim_LookAroundLong, 0.0f, false, false, "");
			
			mpStateMachine.StopTimer("LeaveSniffState");
			mpStateMachine.AddTimer("LeaveSniffState", cMath_RandRectf(1.5f, 2.5f));
		}

		return false;
	}
	
	//------------------------------------------------------------

	void State_InvestigateSniff_TimerUp(uint64 alId)
	{
		if (alId == H64("LeaveSniffState"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
		
		if (alId == H64("CheckDeadEnd"))
		{
			HandlePlayerDeadEnd(0.1f, 4.0f, 8.0f);
			mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
		}
	}
	
	//------------------------------------------------------------

	//} END INVESTIGATE SNIFF

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: INVESTIGATE SOUND
	//{////////////////////////////////

	//------------------------------------------------------------

	cVector3f mvInvestigateSound_Goal;
	int mlInvestigateSound_Prio;
	float mfInvestigateSound_Distance;
	float mfInvestigateSound_JustLookRadius = 10.0f;
	bool mbInvestigateSound_CanRequestBackup = false;
	bool mbInvestigateSound_BackupRequested = false;
	bool mbInvestigateSound_CanHear = false;
	bool mbInvestigateSound_QueueSound = false;
	tString msInvestigateSound_AnimState;

	//------------------------------------------------------------

	void State_InvestigateSound_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: InvestigateSound ------",false,true);
		
		msInvestigateSound_AnimState = "";
		mbInvestigateSound_CanHear = true;
		mbInvestigateSound_QueueSound = false;
		
		if (mAlertState == eGhoulAlertState_None)
		{
			mpPathfinder.Stop();
			mpMover.SetSpeedState(eGhoulSpeed_Walk);
		}
		else
		{
			mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
		}
		
		mbAvoidingDeadEndPlayer = false;
		mfInvestigateSound_Distance = -1.0f;
		mpSoundListener.SetSoundRadiusMul(1.2f);
		
		if (Blackboard_GetHuntingAgentCount() > 0)
		{
			mbInvestigateSound_CanRequestBackup = true;
			mfSoundCounter = 7.0f;
		}
		
		IncreaseSoundCounter(mlInvestigateSound_Prio);
		
		//////////////////////
		// Take action
		if (mAlertState == eGhoulAlertState_None)
		{
			mpStateMachine.AddTimer("SoundReaction", 0.3f);
			mpStateMachine.AddTimer("AnimReaction", 0.0f);
			mpStateMachine.AddTimer("TurnToGoal", 0.3f);
						
			mpPathfinder.BuildPathNodeArrayToPos(mvInvestigateSound_Goal);
			float fDist = mpPathfinder.GetPathNodeArrayFullLength();
			if (fDist > 30.0f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Investigate far away sound, just look");
				mbInvestigateSound_CanHear = false;
				mpStateMachine.AddTimer("EnableHearing", 1.0f);	
				mpStateMachine.AddTimer("NothingFound", 4.0f);
			}
			else
			{
				mpStateMachine.AddTimer("GoToSource", 3.0f);		
			}
		}
		else
		{
			mpStateMachine.AddTimer("GoToSource", 3.0f);	
		}
		
		mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
		EnterInvestigateState();
		
		mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkSearch);
		
		if (msAlertedCallback != "")
		{
			ExecuteEntityCallback(msAlertedCallback);
			msAlertedCallback = "";
		}
	}
	
	//------------------------------------------------------------

	void State_InvestigateSound_Leave()
	{
		mpMover.SetWalkAnimName(msOrigWalkAnim);
		LeaveInvesitgateState();
		
		mlInvestigateSound_Prio = -1;
		mpSoundListener.SetSoundRadiusMul(mfHearingMul);
	}
	
	//------------------------------------------------------------

	void State_InvestigateSound_Update(float afTimeStep)
	{			
		UpdateDoorDetection(afTimeStep);
		
		//////////////////////
		// Update move speed depending on sound counter
		int lSpeedState = eGhoulSpeed_Walk;
		int lCurrentSpeedState = mpMover.GetSpeedState();
		if (mfSoundCounter >= 6.0f || lCurrentSpeedState == eGhoulSpeed_Run) lSpeedState = eGhoulSpeed_Run;
		else if (mfSoundCounter >= 3.0f || lCurrentSpeedState == eGhoulSpeed_FastWalk) lSpeedState = eGhoulSpeed_FastWalk;
		if (mpMover.GetSpeedState() != lSpeedState)
			mpMover.SetSpeedState(lSpeedState);
		
		//////////////////////
		// Call for backup
		if (mbInvestigateSound_CanRequestBackup == false && mbInvestigateSound_BackupRequested == false && mfSoundCounter >= 6.0f)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Request backup");
			
			mbInvestigateSound_BackupRequested = true;
			Blackboard_RequestBackup(mBaseObj.GetID(), mvInvestigateSound_Goal, eGhoulState_InvestigateSound, 1, gfBlackboardMessageRange);
			
			cLux_AddTodoMessage("TODO-SOUND: call out backup");
			mBaseObj.PlaySound("StartHunt", gsGhoulSound_CallOutBackup, true, true);
		}
	}
	
	//------------------------------------------------------------

	bool State_InvestigateSound_Message(int alMessageId)
	{		
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msInvestigateSound_AnimState == "LookAroundEnd")
			{
				if (mbInvestigateSound_QueueSound)
				{
					mbInvestigateSound_QueueSound = false;
					mpStateMachine.AddTimer("GoToSource", 0.2f);
				}
				else mpStateMachine.AddTimer("NothingFound", 0.2f);
			}
			else if (msInvestigateSound_AnimState == "NothingFound")
			{
				if (mbInvestigateSound_QueueSound)
				{
					mbInvestigateSound_QueueSound = false;
					mpStateMachine.AddTimer("GoToSource", 0.2f);
				}
				else mpStateMachine.AddTimer("Exit", 1.0f);
			}
			msInvestigateSound_AnimState = "";
			return true;
		}
		
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_MovingAlert);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mlGhoulHoleNetworkId >= 0)
			{
				iLuxEntity@ pHole = cLux_ID_Entity(Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mvInvestigateSound_Goal));
				if (pHole !is null && mBaseObj.GetDistanceToPos(pHole.GetPosition()) <= 3.0f)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Go into hole because sound was close to it");
					m_idReturnToHole_Hole = pHole.GetID();
					mpStateMachine.ChangeState(eGhoulState_ReturnToHole);
					return true;
				}
			}
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reached end, look around");
			
			mpPathfinder.Stop();
			mpStateMachine.StopTimer("GoToSource");
			mpStateMachine.AddTimer("LookAroundEnd", 0.5f);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			if (mfSoundCounter >= 6.0f)
			{
				mpStateMachine.ChangeState(eGhoulState_Hunt);
				return true;
			}
			
			if (mfSoundCounter >= 3.0f)
			{
				mpStateMachine.ChangeState(eGhoulState_MovingAlert);
				return true;
			}
			
			mpStateMachine.ChangeState(eGhoulState_Alert);
			return true;
		}

		//////////////////////
		// Sound heard
		if(alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (mbInvestigateSound_CanHear == false) return true;
			if (GetSensesActive() == false) return true;
			
			mbInvestigateSound_CanHear = false;
			mpStateMachine.AddTimer("EnableHearing", 1.0f);
			
			mpStateMachine.StopTimer("NothingFound");
			
			int lPrio = mpStateMachine.GetCurrentMessageData().mlX;
			cVector3f vPos = mpStateMachine.GetCurrentMessageData().mvX;
			float fSoundDistSqr = cMath_Vector3DistSqr(vPos, mBaseObj.GetPosition());

			IncreaseSoundCounter(lPrio);
			
			if (msInvestigateSound_AnimState == "LookAroundEnd")
			{
				mfInvestigateSound_Distance = fSoundDistSqr;
				mvInvestigateSound_Goal = vPos;
				mlInvestigateSound_Prio = lPrio;
				mbInvestigateSound_QueueSound = true;
				return true;
			}
	
			//////////////////////
			// If a sound is coming from behind it gets higher priority
			bool bFromBehind = !mBaseObj.GetPointIsInFront(vPos);
			if (bFromBehind)
			{
				fSoundDistSqr *= 0.5f;
			}
			
			//////////////////////
			// Override investigate position
			if (mlInvestigateSound_Prio < lPrio || 
				mlInvestigateSound_Prio == lPrio && fSoundDistSqr < mfInvestigateSound_Distance || 
				mfInvestigateSound_Distance < 0.0f || mfSoundCounter >= 6.0f)
			{
				mfInvestigateSound_Distance = fSoundDistSqr;
				mvInvestigateSound_Goal = vPos;
				mlInvestigateSound_Prio = lPrio;
				
				mpStateMachine.AddTimer("SoundReaction", 0.3f);
				if (mpStateMachine.TimerExists("GoToSource") == false)
				{
					mpStateMachine.AddTimer("GoToSource", 3.0f);
				}
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Sound heard: (Prio: " + lPrio + " InvestigateSoundPrio: " + mlInvestigateSound_Prio + " " +  mpStateMachine.GetCurrentMessageData().msX + ")");					
			}

			return true;
		}

		return false;
	}
	
	//------------------------------------------------------------

	void State_InvestigateSound_TimerUp(uint64 alId)
	{
		///////////////////////
		// Walk towards the sound
		if (alId == H64("GoToSource"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") GoToSource");
			
			cVector3f vSoundDir = mvInvestigateSound_Goal - mBaseObj.GetPosition();
			vSoundDir.Normalize();
			cAINode@ pNode = mpPathfinder.GetNodeInPosLOS(mvInvestigateSound_Goal - vSoundDir * 2.0f, mvInvestigateSound_Goal, 0.0f, 4.0f);
			if(pNode !is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveTo");
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
			}
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Did not find path to source");
				mpStateMachine.ChangeState(eGhoulState_Idle);
			}
            //Set to 3 seconds for grunt alert animation to play
			mpStateMachine.AddTimer("GoToSource", 0.5f);
		}
		
		if (alId == H64("TurnToGoal"))
		{
			mpMover.TurnToPos(mvInvestigateSound_Goal);
		}
		
		if (alId == H64("SoundReaction"))
		{
			mBaseObj.PlaySound("PlayerHeard", gsGhoulSound_SoundHeard, true, true);
		}
		
		if (alId == H64("AnimReaction"))
		{
			mpMover.PlayAnimation(GetDetectedAnimation(mvInvestigateSound_Goal));
		}
		
		if (alId == H64("CheckDeadEnd"))
		{
			HandlePlayerDeadEnd(0.1f, 4.0f, 8.0f);
			mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
		}
		
		if (alId == H64("LookAroundEnd"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Look around");
			mpPathfinder.Stop();
			msInvestigateSound_AnimState = "LookAroundEnd";
			mBaseObj.PlaySound("LookAround", gsGhoulSound_LookAround, true, true);
			PlayRandomAnimation(mvGhoulAnim_LookAroundLong, 0.2f, false, false, "");
		}
		
		if (alId == H64("NothingFound"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Nothing found");
			mpPathfinder.Stop();
			msInvestigateSound_AnimState = "NothingFound";
			mBaseObj.PlaySound("LostTrackSmall", gsGhoulSound_LostTrackSmall, true, true);
			mpMover.PlayAnimation(gsGhoulAnim_ShrugOff, 0.2f, false, false, "");
		}
		
		if (alId == H64("Exit"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Exit");
			mpStateMachine.ChangeState(eGhoulState_TrackSmell);
		}
		
		if (alId == H64("EnableHearing"))
		{
			mbInvestigateSound_CanHear = true;
		}
	}
	
	//------------------------------------------------------------
	
	bool ShouldInvestigate(float afSoundDistSqr, const cVector3f &in avSoundPos)
	{
		return afSoundDistSqr < mfInvestigateSound_JustLookRadius * mfInvestigateSound_JustLookRadius;
	}
	
	//------------------------------------------------------------

	//} END INVESTIGATE SOUND

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: RETURN TO HOLE
	//{////////////////////////////////

	//------------------------------------------------------------
	
	tID m_idReturnToHole_Hole = tID_Invalid;
	eGhoulSpeed mReturnToHole_Speed = eGhoulSpeed_Walk;
	bool mbRetreatToHole_SensesActive = true;
	bool mbRetreatToHole_DeactivateAfter = false;
	
	tID m_idReturnToHole_MoveToHole = tID_Invalid;
	bool mbRetreatToHole_PlayerPassed = false;
	tString msReturnToHole_AnimState = "";
	
	tID m_idReturnToHole_CommandHole = tID_Invalid;
	eGhoulSpeed mReturnToHole_CommandSpeed = eGhoulSpeed_Walk;
	bool mbReturnToHole_CommandDeactivateAfter = false;
	bool mbReturnToHole_Smell = true;
	
	bool mbReturnToHole_Align = false;
	float mfReturnToHole_AlignTimer = 0;
	cVector3f mvReturnToHole_StartPos;
	cVector3f mvReturnToHole_EndPos;
	float mfReturnToHole_StartYaw = 0;
	float mfReturnToHole_EndYaw = 0;
	
	bool mbReturnToHole_CrawlIn = false;
	cVector3f mvReturnToHole_CrawlInPos;
	cVector3f mvReturnToHole_CrawlDir;
	tString msReturnToHole_ExitType = "Low";

	//------------------------------------------------------------
	
    void State_ReturnToHole_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ReturnToHole ------");
		
		if (UsesVoice()) mpBarkMachine.ChangeState(eGhoulBark_Wander);
		
		msReturnToHole_AnimState = "";
		mbRetreatToHole_PlayerPassed = false;
		m_idReturnToHole_MoveToHole = tID_Invalid;
		mbReturnToHole_Smell = true;
		mbReturnToHole_CrawlIn = false;
		mbReturnToHole_Align = false;
				
		if (m_idReturnToHole_Hole == tID_Invalid)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No exit hole specified, going to closest");
			m_idReturnToHole_Hole = Blackboard_GetClosestGhoulHole(mlGhoulHoleNetworkId, mBaseObj.GetPosition());
		}
		
		msReturnToHole_ExitType = "Low";
		cLuxArea@ pHole = cLux_ID_Area(m_idReturnToHole_Hole);
		if (pHole !is null)
		{
			bool bGlobal = cScript_RunGlobalFunc(pHole.GetName(), "cScrAreaGhoulHole", "_Global_GetExitAnimType");
			if (bGlobal && cScript_GetGlobalReturnString() == "High") msReturnToHole_ExitType = "High";
		}
		
		mpMover.SetSpeedState(mReturnToHole_Speed);
		
		Blackboard_SetGhoulHoleUsed(m_idReturnToHole_Hole, mBaseObj.GetID());
		
		mpStateMachine.AddTimer("MoveToHole", 0.0f);
		mpStateMachine.AddTimer("CheckIdle", 0.5f);		
	}
	
	//------------------------------------------------------------

	void State_ReturnToHole_Leave()
	{
		mpBarkMachine.ChangeState(eGhoulBark_Silent);
		
		mbProximityDetectionActive = true;
		mbBackupRequestsActive = true;
		
		Blackboard_RemoveGhoulHoleUsed(m_idReturnToHole_Hole);
//		m_idReturnToHole_Hole = tID_Invalid;
//		mReturnToHole_Speed = eGhoulSpeed_Walk;
		mbRetreatToHole_SensesActive = true;
		mbRetreatToHole_DeactivateAfter = false;
		
		mBaseObj.GetCharBody().SetActive(true);
		mBaseObj.GetCharBody().SetGravityActive(true);
	}
	
	//------------------------------------------------------------
	
	void State_ReturnToHole_Update(float afTimeStep)
	{
		if (mbReturnToHole_Align)
		{
			mfReturnToHole_AlignTimer += afTimeStep;
			float fT = cMath_Clamp(mfReturnToHole_AlignTimer / 0.5f, 0.f, 1.f);
			mBaseObj.GetCharBody().SetYaw(cMath_InterpolateLinear(mfReturnToHole_StartYaw, mfReturnToHole_EndYaw, fT));
			mBaseObj.GetCharBody().SetFeetPosition(mvReturnToHole_StartPos * (1.0f - fT) + mvReturnToHole_EndPos * fT, false);
		}
				
		if (mbReturnToHole_CrawlIn)
		{
			mBaseObj.GetCharBody().SetYaw(mfReturnToHole_EndYaw);
			cVector3f vNewPos = mBaseObj.GetCharBody().GetFeetPosition() + mvReturnToHole_CrawlDir * 3 * afTimeStep;
			cVector3f vToEndPos = mvReturnToHole_CrawlInPos - mBaseObj.GetCharBody().GetFeetPosition();
			if (cMath_Vector3Dot(vToEndPos, mvReturnToHole_CrawlDir) <= 0)
			{
				vNewPos = mvReturnToHole_CrawlInPos;
				mbReturnToHole_CrawlIn = false;
				mpStateMachine.AddTimer("Exit", 0.0f);
			}
			mBaseObj.GetCharBody().SetFeetPosition(vNewPos, false);
		}
		
		UpdateDoorDetection(afTimeStep);
		if (mbReturnToHole_Smell) UpdateSmellDetection(afTimeStep);
		UpdateQuickHoleReturn(afTimeStep, 14.0f, true);
	}
	
	//------------------------------------------------------------
	
	bool State_ReturnToHole_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") AnimationOver " + msReturnToHole_AnimState);
			if (msReturnToHole_AnimState == "EnterHole")
			{
				msReturnToHole_AnimState = "";
				
				mbReturnToHole_Align = false;
				
				cLuxArea@ pHole = cLux_ID_Area(m_idReturnToHole_Hole);
				if (msReturnToHole_ExitType == "Low" && pHole !is null)
				{
					mbReturnToHole_CrawlIn = true;
					mvReturnToHole_CrawlDir = pHole.GetMatrix().GetTranspose().GetForward() * -1;
					mvReturnToHole_CrawlInPos = mvReturnToHole_EndPos + mvReturnToHole_CrawlDir * 4;
					mpMover.PlayAnimation(gsGhoulAnim_CrawlLoop, 0.0, true);
				}
				else
				{
					mpStateMachine.AddTimer("Exit", 0.0f);
				}
			}
			else if (msReturnToHole_AnimState == "EnterHole")
			{
				msReturnToHole_AnimState = "";
				mpStateMachine.AddTimer("Exit", 0.0f);
			}
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EndOfPath, exit hole reached");
			
			mpStateMachine.StopTimer("MoveToHole");
			mpStateMachine.StopTimer("CheckIdle");
			mpStateMachine.AddTimer("EnterHole", 0.5f);
			return true;
		}
		
		if (mbRetreatToHole_SensesActive == false) return true;
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_ReturnToHole_TimerUp(uint64 alId)
	{
		if (alId == H64("MoveToHole"))
		{
			if (m_idReturnToHole_MoveToHole == tID_Invalid || m_idReturnToHole_MoveToHole != m_idReturnToHole_Hole)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveTo");
				m_idReturnToHole_MoveToHole = m_idReturnToHole_Hole;
				mpPathfinder.MoveTo(cLux_ID_Entity(m_idReturnToHole_MoveToHole).GetPosition(), 1.0f, true);
			}
			mpStateMachine.AddTimer("MoveToHole", 0.5f);
		}
		
		if (alId == H64("CheckIdle"))
		{
			Idle_DecideBehavior();
			mpStateMachine.AddTimer("CheckIdle", 0.5f);
		}

		if (alId == H64("EnterHole"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EnterHole");
			
			mbBackupRequestsActive = false;
			mbProximityDetectionActive = false;
			mbRetreatToHole_SensesActive = false;
			mbReturnToHole_Smell = false;
			
			msReturnToHole_AnimState = "EnterHole";
			mBaseObj.PlaySound("CrawlIn", gsGhoulSound_CrawlIn, true, true);			
			mBaseObj.PlaySound("CrawlInFoley", gsGhoulSound_CrawlInFoley, true, true);
			
			mBaseObj.GetCharBody().SetActive(false);
			mBaseObj.GetCharBody().SetGravityActive(false);
			
			cLuxArea@ pHole = cLux_ID_Area(m_idReturnToHole_Hole);
			if (pHole !is null)
			{
				mbReturnToHole_Align = true;
				mfReturnToHole_AlignTimer = 0;
				mvReturnToHole_StartPos = mBaseObj.GetCharBody().GetFeetPosition();
				mvReturnToHole_EndPos = pHole.GetPosition() + cVector3f_Down * pHole.GetSize().y / 2;
				
				cVector3f vHoleForward = pHole.GetMainBody().GetWorldMatrix().GetTranspose().GetForward();
				vHoleForward.y = 0;
				vHoleForward.Normalize();
				
				mfReturnToHole_StartYaw = cMath_GetAngleFromPoints3D(0.0f, mBaseObj.GetCharBody().GetForward()).y;
				mfReturnToHole_EndYaw = mfReturnToHole_StartYaw + cMath_GetAngleDistanceRad(mfReturnToHole_StartYaw, cMath_GetAngleFromPoints3D(0.0f, vHoleForward * -1).y);
				
				cVector3f vPSPos = mvReturnToHole_EndPos - vHoleForward * 0.3;
				vPSPos += cVector3f_Up * 0.5f;
				cParticleSystem@ pPS = mBaseObj.CreateParticleSystem("EmergeParticles", "ghoul_emerge", true, false);
				if (pPS !is null) pPS.SetPosition(vPSPos);
			}
			
			if (msReturnToHole_ExitType == "Low") mpMover.PlayAnimation(gsGhoulAnim_CrawlEnter, 0.1f, false, false, "");
			else if (msReturnToHole_ExitType == "High") mpMover.PlayAnimation(gsGhoulAnim_CrawlIn50cm, 0.1f, false, false, "");
		}

		if (alId == H64("Exit"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Exit");
			
			m_idHideInHole_Hole = m_idReturnToHole_Hole;
			mpStateMachine.ChangeState(eGhoulState_HideInHole);
			
			mlWanderToExitHole_CurrentWander = 0;
			
			mBaseObj.SetActive(!mbRetreatToHole_DeactivateAfter);
			mbRetreatToHole_DeactivateAfter = false;
		}
	}
	
	//------------------------------------------------------------
	
	void ReturnToHole(tID a_idHole, eGhoulSpeed aSpeed = eGhoulSpeed_Walk)
	{
		m_idReturnToHole_Hole = a_idHole;
		mReturnToHole_Speed = aSpeed;
		mpStateMachine.ChangeState(eGhoulState_ReturnToHole);
	}

	//------------------------------------------------------------

	//} END RETURN TO HOLE

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: MOVE TO
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvMoveTo_Goal;
	eGhoulSpeed mMoveTo_Speed = eGhoulSpeed_Walk;
	float mfMoveTo_MoveThroughAmount = 0.0f;
	tString msMoveTo_CompletedCallback = "";
	
	cVector3f mvMoveTo_CommandGoal;
	eGhoulSpeed mMoveTo_CommandSpeed = eGhoulSpeed_Walk;
	
	//------------------------------------------------------------
	
    void State_MoveTo_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: MoveTo ------");
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(mMoveTo_Speed);
				
		mpStateMachine.AddTimer("MoveTo", 0.0f);
	}
	
	//------------------------------------------------------------

	void State_MoveToe_Leave()
	{
	}
	
	//------------------------------------------------------------
	
	void State_MoveTo_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
	}
	
	//------------------------------------------------------------
	
	bool State_MoveTo_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reached goal, exit to idle");
			MoveTo_ExecuteCompletedCallback(msMoveTo_CompletedCallback);
			if (mCommand == eGhoulCommand_UseDoor)
			{
				mCommand = eGhoulCommand_None;
				MoveTo_ExecuteCompletedCallback(msCommandCompletedCallback);
				
				mMoveTo_Speed = eGhoulSpeed_Walk;
				mpMover.SetSpeedState(eGhoulSpeed_Walk);
				mfMoveTo_MoveThroughAmount = 0.0f;
			}
			mpStateMachine.ChangeState(eGhoulState_Idle);
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------
	
	void State_MoveTo_TimerUp(uint64 alId)
	{
		if (alId == H64("MoveTo"))
		{
			mpMover.SetSpeedState(mMoveTo_Speed);
			
			cVector3f vGoal = mvMoveTo_Goal + mBaseObj.GetCharBody().GetForward() * mfMoveTo_MoveThroughAmount;
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(vGoal , 0.0f, 5.0f, true, false, false, null);
		
			if (pNode is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Trying to reach with wider radius");
				@pNode = mpPathfinder.GetNodeAtPos(vGoal, 0.0f, 10.0f, true, false, false, null);
			}
			
			if (pNode is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Cannot reach goal, return to idle");
				mpStateMachine.ChangeState(eGhoulState_Idle);
				return;
			}
			
			mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
			
			mpStateMachine.AddTimer("MoveTo", 0.5f);
		}
	}
	
	//------------------------------------------------------------
	
	void MoveTo_ExecuteCompletedCallback(const tString &in asFunc)
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") MoveTo_ExecuteCompletedCallback function: " + asFunc);
		if (asFunc == "") return;
		
		tString sMethodName = "void " + asFunc + "()";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.ScriptExecute();
		}
	}
	
	//------------------------------------------------------------

	void MoveTo(const cVector3f &in avGoal, eGhoulSpeed aSpeed = eGhoulSpeed_Walk, float afMoveThroughAmount = 0.0f)
	{
		mvMoveTo_Goal = avGoal;
		mMoveTo_Speed = aSpeed;
		mfMoveTo_MoveThroughAmount = afMoveThroughAmount;
		mpStateMachine.ChangeState(eGhoulState_MoveTo);
	}

	//------------------------------------------------------------

	//} END RETREAT TO HOLE

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: PATROL
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cGhoulPatrol mPatrol_NextInstance;
	cGhoulPatrol mPatrol_CurrentInstance;
	
	int mlPatrol_InstanceCounter = 0;
	bool mbPatrol_SkipNextNode = false;
	bool mbPatrol_Random = true;
	int mlPatrol_LoopCount = 1;
	int mlPatrol_CurrentLoop = 0;
	bool mbPatrol_SmellPatrol = false;
	eGhoulSpeed mPatrol_Speed = eGhoulSpeed_Walk;
	cGhoulPatrol mPatrol_ModeInstance = cGhoulPatrol(0);
	cGhoulPatrol mPatrol_CommandInstance;

	//------------------------------------------------------------

	void State_Patrol_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Patrol ------");
		
		mpPathfinder.Stop();
		mBaseObj.ResetPlayerDetectionState();
		
		if (UsesVoice()) mpBarkMachine.ChangeState(eGhoulBark_Wander);
		
		if (mbPatrol_SmellPatrol)
		{
			EnterInvestigateState();
			mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkSearch);
		}			
		
		if (mPatrol_NextInstance.mlId != mPatrol_CurrentInstance.mlId)
		{
			Patrol_SetupTrack(mPatrol_NextInstance);
			mPatrol_CurrentInstance = mPatrol_NextInstance;
		}
		mpMover.SetSpeedState(mPatrol_CurrentInstance.mSpeed);
				
		mpStateMachine.AddTimer("StartPatrol", 0.0f);
		mpStateMachine.AddTimer("CheckIdle", 0.5f);
	}

	//------------------------------------------------------------

	void State_Patrol_Leave()
	{
		if (mbPatrol_SmellPatrol)
		{
			LeaveInvesitgateState();
			
			mbPatrol_SmellPatrol = false;
			Sound_Stop("Smell_TrackingLoop", 0.2f);
		}		
		
		mpMover.SetWalkAnimName(msWalkAnim);
		mpBarkMachine.ChangeState(eGhoulBark_Silent);
		mpPathfinder.SetTrackPaused(true);
	}

	//------------------------------------------------------------

	void State_Patrol_Update(float afTimeStep)
	{		
		UpdateDoorDetection(afTimeStep);
		UpdateSmellDetection(afTimeStep);

		if (mbPatrol_SmellPatrol)
		{
			if (Sound_Exists("Smell_TrackingLoop") == false)
			{
				Sound_CreateAtEntity("Smell_TrackingLoop", gsGhoulSound_SmellTrackingLoop, mBaseObj.GetName());
				Sound_SetParam("Smell_TrackingLoop", gsGhoulSound_SmellTrackingLoop_ParamIntensity, 0.0f);
			}
			else
			{
				Sound_SetParam("Smell_TrackingLoop", gsGhoulSound_SmellTrackingLoop_ParamIntensity, mBaseObj.GetDistanceToPlayer() > 8.0f ? 0.0f : 1.0f);
			}
			
		}
	}

	//------------------------------------------------------------

	bool State_Patrol_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Skipping a node due to getting blocked");
			mpPathfinder.GoToNextTrackNode();
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfTrack)
		{
			if (mpPathfinder.GetTrackLoop() == false)
			{
				if (mlPatrol_CurrentLoop < mPatrol_CurrentInstance.mlLoopCount)
				{
					++mlPatrol_CurrentLoop;
					mpStateMachine.AddTimer("StartPatrol", 0.0f);
				}
				else
				{
					mpStateMachine.AddTimer("StopPatrol", 1.0f);
				}
			}
			if (mpPathfinder.GetTrackNodeNum() == 1) mpPathfinder.StopTrack();
		}
		
		if (alMessageId == eLuxEntityMessage_AtTrackNode)
		{
			cLuxTrackNode@ pNode = mpPathfinder.GetTrackNode(mpStateMachine.GetCurrentMessageData().mlX);
			mpMover.PlayTrackAnimation(pNode);
		}
		
		return false;
	}

	//------------------------------------------------------------

	void State_Patrol_TimerUp(uint64 alId)
	{
		if (alId == H64("StartPatrol"))
		{
			if (mpPathfinder.GetTrackNodeNum() > 0)
			{
				mpPathfinder.SetTrackPaused(false);
				mpPathfinder.StartTrack(mPatrol_CurrentInstance.mlLoopCount < 0, 2.0f, "", mPatrol_CurrentInstance.mbRandom);
				return;
			}
			mpStateMachine.AddTimer("StartPatrol", 0.5f);
		}
		
		if (alId == H64("CheckIdle"))
		{
			Idle_DecideBehavior();
			mpStateMachine.AddTimer("CheckIdle", 0.5f);
		}
		
		if (alId == H64("StopPatrol"))
		{
			Patrol_Stop();
		}
	}
	
	//------------------------------------------------------------
	
	void Patrol_Stop()
	{
		if (mCommand == eGhoulCommand_Patrol)
		{
			ExecuteEntityCallback(mPatrol_CurrentInstance.msEndOfPatrolCallback);
			mPatrol_NextInstance = cGhoulPatrol();
			mCommand = eGhoulCommand_None;
		}
		mpStateMachine.ChangeState(eGhoulState_Idle);
	}
	
	//------------------------------------------------------------
	
	void Patrol_SetupTrack(cGhoulPatrol@ apPatrol)
	{
		mpPathfinder.ClearTrackNodes();
		for (int i = 0; i < apPatrol.mvNodes.size(); ++i)
		{
			cGhoulPatrolNode pNode = apPatrol.mvNodes[i];
			mpPathfinder.AddTrackNode(pNode.msName, pNode.mfMinWaitTime, pNode.mfMaxWaitTime, pNode.msAnimName, pNode.mbLoopAnim);
		}
	}
	
	//------------------------------------------------------------

	//} END PATROL

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: PLAYER DETECTED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvPlayerDetected_Pos;
	bool mbPlayerDetected_TurnFollow = false;
	bool mbPlayerDetected_TimerActive = true;
	float mfPlayerDetected_Timer = 0.0f;
	int mfPlayerDetected_Count = 0;
	tString msPlayerDetected_AnimState = "";
	
	//------------------------------------------------------------

    void State_PlayerDetected_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PlayerDetected ------",false,true);
		
		SetEyeColor(gGhoul_EyeColorAlerted);

		msPlayerDetected_AnimState = "";
		mbPreAlertActive = false;
		mbPlayerDetected_TimerActive = true;
		mfPlayerDetected_Timer = 0.0f;
		
		mBaseObj.Timer_Remove("Timer_PlayerDetected_ResetCount");
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		
		++mfPlayerDetected_Count;
		if (mfPlayerDetected_Count >= 2)
		{
			mpStateMachine.ChangeState(eGhoulState_Alert);
			return;
		}
		
		mBaseObj.PlaySound("PlayerDetected", gsGhoulSound_PlayerDetected, true, true);
		msPlayerDetected_AnimState = "PlayerDetected";
		
		tString sGlimpseAnim = GetDetectedAnimation(mBaseObj.GetPlayerPos());
		cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName(sGlimpseAnim);
		if (pAnim !is null) mpMover.PlayAnimation(sGlimpseAnim);
		
		mvPlayerDetected_Pos = mBaseObj.GetPlayerPos();
	}
	
	//------------------------------------------------------------

	void State_PlayerDetected_Leave()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		
		mpMover.SetIdleAnimName(msIdleAnim);
		
		mbPreAlertActive = true;
		mbPlayerDetected_TurnFollow = false;
		
		mBaseObj.Timer_Add("Timer_PlayerDetected_ResetCount", 5.0f, "OnTimer_PlayerDetected_ResetCount");
	}
	
	//------------------------------------------------------------

	void State_PlayerDetected_Update(float afTimeStep)
	{
		if (mbPlayerDetected_TimerActive)
		{
			mfPlayerDetected_Timer += afTimeStep;
		}
		
		if (mbPlayerDetected_TurnFollow)
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
		}
	}
	
	//------------------------------------------------------------

	bool State_PlayerDetected_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
		{
			if (GetSensesActive() == false) return true;
			if (mBaseObj.PlayerIsDetected()) return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_Alert);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msPlayerDetected_AnimState == "PlayerDetected")
			{
				mpStateMachine.AddTimer("TurnTo", 0.0f);
			}
			else if (msPlayerDetected_AnimState == "NothingFound")
			{
				mpStateMachine.AddTimer("Exit", 1.0f);
			}
			msPlayerDetected_AnimState = "";
			return true;
		}
		
		
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			mbPlayerDetected_TimerActive = false;
			Sound_FadeGuiVolume("player/UI/terror_meter/terror_meter_loop", 0.0f, 2.0f);
			mpStateMachine.StopTimer("EnterAlert");
			mpStateMachine.StopTimer("StepForward");
			mpStateMachine.AddTimer("StepForward", 1.3f);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpStateMachine.AddTimer("NothingFound", 1.0f);
		}
		

		return false;
	}
	
	//------------------------------------------------------------

	void State_PlayerDetected_TimerUp(uint64 alId)
	{
		if(alId == H64("TurnTo"))
		{
			if (mBaseObj.PlayerIsDetected())
			{
				mpMover.PlayAnimation(gsGhoulAnim_Move_IdleAggressive);
				mpMover.SetIdleAnimName(gsGhoulAnim_Move_IdleAggressive);
				mpStateMachine.AddTimer("EnterAlert", 2.0f);
				mbPlayerDetected_TurnFollow = true;
			}
			else
			{
				mpStateMachine.AddTimer("StepForward", 3.0f);
				mpMover.TurnToPos(mvPlayerDetected_Pos);
			}
		}
		
		if(alId == H64("EnterAlert"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EnterAlert");
			mpStateMachine.ChangeState(eGhoulState_Alert);
		}
		
		if(alId == H64("StepForward"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") StepForward DetectTimer: " + mfPlayerDetected_Timer);
			if (mfPlayerDetected_Timer > 0.8f)
			{
				cVector3f vDetectedDir = mvPlayerDetected_Pos - mBaseObj.GetPosition();
				vDetectedDir.y = 0;
				vDetectedDir.Normalize();
				
				float fDist;
				cVector3f vSurfaceNrm;
				if (cLux_GetClosestBody(mBaseObj.GetPosition(), vDetectedDir, 3.0f, fDist, vSurfaceNrm) is null)
				{
					cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + vDetectedDir * 3.0f, 0.0f, 4.0f, true, false, false, null);
					if (pNode !is null)
					{
						mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
						return;
					}
				}
			}
			mpStateMachine.AddTimer("NothingFound", 0.5f);
		}
		
		if (alId == H64("NothingFound"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") NothingFound");
			msPlayerDetected_AnimState = "NothingFound";
			mBaseObj.PlaySound("LostTrackSmall", gsGhoulSound_LostTrackSmall, true, true);
			mpMover.PlayAnimation(gsGhoulAnim_ShrugOff, 0.2f, false, false, "");
		}
		
		if (alId == H64("Exit"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Exit");
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}

	//------------------------------------------------------------
	
	void OnTimer_PlayerDetected_ResetCount(uint64 alID)
	{
		mfPlayerDetected_Count = 0;
	}
	
	//------------------------------------------------------------

	//} END PLAYER DETECTED
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: ALERT
	//{////////////////////////////////

	//------------------------------------------------------------

	cVector3f mvAlert_PlayerPosition;
	bool mbAlert_AnimationOver = false;
	bool mbAlert_Forced = false;
	float mfAlert_ForcedTime = 0.0f;
	
	//------------------------------------------------------------

    void State_Alert_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Alert ------",false,true);
		
		EnterAlertState();
		
		ResetRetreatFlags();
		mbAlert_AnimationOver = false;
		mvAlert_PlayerPosition = mBaseObj.GetPlayerPos();
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		mBaseObj.ResetPlayerDetectionState();
		
		float fAlertTime = gfAlertTime;
		if (mbAlert_Forced && mfAlert_ForcedTime >= 0.0f) fAlertTime = mfAlert_ForcedTime;
		
		if (cMath_RandRectf(0.0f, 1.0f) <= 0.7f) mpMover.PlayAnimation(gsGhoulAnim_Alert, 0.3f, false, false, "");
		else mpMover.PlayAnimation(gsGhoulAnim_Alert2, 0.3f, false, false, "");
		
		mpMover.SetIdleAnimName(gsGhoulAnim_Move_IdleAggressive);
		
		if (UsesVoice() && msAlertSubject != "") mpBarkMachine.PlayVoice(msAlertSubject, 1);
		else mBaseObj.PlaySound("PlayerSpotted", gsGhoulSound_PlayerSpotted, true, true);

		mpStateMachine.AddTimer("CheckLastKnownPosition", 2.0f);		
	}
	
	//------------------------------------------------------------

	void State_Alert_Leave()
	{
		LeaveAlertState();
		
		mpMover.SetIdleAnimName(msIdleAnim);
		
		mbAlert_Forced = false;
	}
	
	//------------------------------------------------------------

	void State_Alert_Update(float afTimeStep)
	{
		mpMover.TurnToPos(mvAlert_PlayerPosition);
		
		if (mbAlert_AnimationOver)
		{
			TryHunt();
		}
	}
	
	//------------------------------------------------------------

	bool State_Alert_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_AttractAgent) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_EndOfPath) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime * 0.3f);
			return true;
		}

		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			mbAlert_AnimationOver = true;
		}

		if (alMessageId == eLuxEntityMessage_PlayerDetected && mbAlert_Forced == false)
		{
			if (GetSensesActive() == false) return true;
			
			Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime * 0.5f);
			mpStateMachine.StopTimer("CheckLastKnownPosition");
			return true;
		}

		if (alMessageId == eLuxEntityMessage_PlayerUndetected && mbAlert_Forced == false)
		{
			Terror_RemoveEnemy(mBaseObj.GetID());
			mpStateMachine.AddTimer("CheckLastKnownPosition", 2.0f);
			return true;
		}

		return false;
	}
	
	//------------------------------------------------------------

	void State_Alert_TimerUp(uint64 alId)
	{
		if(alId == H64("CheckLastKnownPosition"))
		{
			if (mBaseObj.PlayerIsDetected() == false)
			{
				mpStateMachine.ChangeState(eGhoulState_CheckLastKnownPosition);
				return;
			}
			mpStateMachine.AddTimer("CheckLastKnownPosition", 0.2f);
		}
	}

	//------------------------------------------------------------

	//} END ALERT
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: MOVING ALERT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	// Move towards the last known position while increasing the terror meter. Used when the ghoul has already previously
	// spotted the player to avoid making the ghoul stop.

	//------------------------------------------------------------
	
	cVector3f mvMovingAlert_MoveToPos;
	
	//------------------------------------------------------------

    void State_MovingAlert_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: MovingAlert ------",false,true);
		
		EnterAlertState(0.8f);
		
		ResetRetreatFlags();
		
		mpMover.SetSpeedState(eGhoulSpeed_FastWalk);

		mBaseObj.PlaySound("PlayerSpotted", gsGhoulSound_PlayerSpotted, true, true);
		
		mBaseObj.RevealPlayerPos();
		
		///////////////////////////////
		// Move to the last known position
		mvMovingAlert_MoveToPos = mBaseObj.GetLastKnownPlayerPos();
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvMovingAlert_MoveToPos, 0.0f, 4.0f, true, false, false, null);
		if (pNode !is null)
		{
			mpPathfinder.MoveTo(pNode.GetPosition(), 2.0f, false);
		}
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Couldn't find last known position, returning to hole");
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}
	
	//------------------------------------------------------------

	void State_MovingAlert_Leave()
	{
		LeaveAlertState();
	}
	
	//------------------------------------------------------------

	void State_MovingAlert_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
		TryHunt();
	}
	
	//------------------------------------------------------------

	bool State_MovingAlert_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo && mbPlayerIsInLos) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			return cMath_Vector3Dist(mvMovingAlert_MoveToPos, mpStateMachine.GetCurrentMessageData().mvX) < 2.0f;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime * 0.5f);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			Terror_RemoveEnemy(mBaseObj.GetID());
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mbSearchArea_SearchBehind = false;
			mvSearchArea_SearchPos = mBaseObj.GetPosition() + mBaseObj.GetCharBody().GetForward() * 2.0f;
			mpStateMachine.ChangeState(eGhoulState_SearchArea);
			return true;
		}

		return false;
	}
	
	//------------------------------------------------------------

	void State_MovingAlert_TimerUp(uint64 alId)
	{
	}

	//------------------------------------------------------------

	//} END MOVING ALERT
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: HUNT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbHunt_PredictedPos = false;
	int mlHunt_AttackCount = 0;
	float mfHunt_PlayerStartHealth = 0;
	bool mbHunt_ToRetreat = false;
	bool mbHunt_HuntedRecently = false;
	bool mbHunt_Unreachable = false;
	cVector3f mvHunt_GoingAroundPos;
	float mfHunt_SuperHuntCounter = 0;
	bool mbHunt_SuperHunt = false;
	bool mbHunt_SuperHuntEnabled = true;
    bool mbHunt_AdaptiveSpeed = false;
    float mfHunt_AdaptiveSpeed = 5.2f;
    float mfHunt_AdaptiveSpeedTarDist = 15.f;
    float mfHunt_AdaptiveSpeedResetCount = 0.f;
	bool mbHunt_AdjustSpeed = true;
	float mfHunt_AdjustSpeedMul = 0.8f;
	cVector3f mvHunt_LastPlayerDir;
	
	tString msHunt_EnterCallback = "";
	bool mbHunt_EnterCallbackAutoRemove = false;

	//------------------------------------------------------------

	void State_Hunt_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Hunt ------",false,true);
		
		mpMover.SetSpeedState(mbHunt_SuperHunt ? eGhoulSpeed_FastRun : eGhoulSpeed_Run);
		
		//////////////
		// Reset values
		mbHunt_HuntedRecently = true;
		mbHunt_ToRetreat = false;
		mbHunt_PredictedPos = false;
		mbHunt_Unreachable = false;
		mpProximitySensor.ResetAllStates();
		
		////////////
		// Keep track of how many times we have attacked the player without dealing damage
		int lPrevState = mpStateMachine.GetPrevState();
		bool bWasAttacking = lPrevState == eGhoulState_AttackLunge || lPrevState == eGhoulState_AttackClose;
		if (bWasAttacking)
		{
			if (cLux_GetPlayer().GetAverageMoveSpeed() <= 1.0f)
			{
				++mlHunt_AttackCount;
			}
		}
		else
		{
			mbHunt_SuperHunt = false;
			mfHunt_SuperHuntCounter = 0;
			mlHunt_AttackCount = 0;
		}
		mfHunt_PlayerStartHealth = Player_GetHealth();
		
		////////////
		// Retreat if the player cannot be reached
		if (cLux_GetGodModeActivated() == false && mlHunt_AttackCount >= 3)
		{
			if (Player_GetHealth() >= mfHunt_PlayerStartHealth)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Can't hit player, retreat");
				mbRetreat_CalculatePos = true;
				mpStateMachine.ChangeState(eGhoulState_Retreat);
				mbHunt_ToRetreat = true;
			}
		}

		////////////
		// Visual senses increased during hunt mode
		mBaseObj.SetFOVMul(2.0f);
		mBaseObj.SetSightRangeMul(2.0f * mfSightMul);
		
		mpPathfinder.SetDirectPathMaxDistanceMul(1.0f);
        
		Terror_AddHuntingEnemy(mBaseObj.GetID());
		Blackboard_SetEnemyHunt(mBaseObj.GetID(), true);
        

		if (mAlertState < eGhoulAlertState_Hunting)
		{
			Blackboard_RequestBackup(mBaseObj.GetID(), mBaseObj.GetPlayerPos(), eGhoulState_Hunt, -1, gfBlackboardMessageRange, false, false);
			mBaseObj.RevealPlayerPos();
		}
		
		mBaseObj.ResetPlayerDetectionState();
		
		mBaseObj.PlaySound("StartHunt", gsGhoulSound_StartHunt, true, true);
		mpMover.PlayAnimation(gsGhoulAnim_StartHunt, 0.0f, false, false, "");
		
		mpStateMachine.AddTimer("Pursuit", 0.5f);
		mpStateMachine.AddTimer("SuperHuntTryTeleport", 3.0f);
		
		EnterHuntState();
		ResetRetreatFlags();
        
		Hunt_ExecuteEnterCallback();
	}

	//------------------------------------------------------------

	void State_Hunt_Leave()
	{
		LeaveHuntState();
		
		mBaseObj.SetFOVMul(1.0f);
		mBaseObj.SetSightRangeMul(1.0f);
		
		mpPathfinder.SetDirectPathMaxDistanceMul(mfDirectPathMaxDistanceMul);
		
		mpMover.SetSpeedState(eGhoulSpeed_Run);
		mBaseObj.GetCharBody().SetMaxPositiveMoveSpeed(eCharDir_Forward, gfGhoul_SpeedRun);
		
		mbHunt_ToRetreat = false;
		
		mvHunt_LastPlayerDir = mBaseObj.GetPlayerPos() - mBaseObj.GetLastKnownPlayerPos();
		mvHunt_LastPlayerDir.y = 0;
		mvHunt_LastPlayerDir.Normalize();

		int lNextState = mpStateMachine.GetNextState();
		if (lNextState != eGhoulState_AttackClose && 
			lNextState != eGhoulState_AttackLunge &&
			lNextState != eGhoulState_ThrowPlayer &&
			lNextState != eGhoulState_Stunned)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
		mpMover.SetDynamicObjectAvoidanceActive(true);
	}

	//------------------------------------------------------------

	void State_Hunt_Update(float afTimeStep)
	{
		if (mpStateMachine.GetNextState() != eGhoulState_Hunt) return;
		if (mpPathfinder.IsClimbing()) return;
		
		UpdateDoorDetection(afTimeStep);
		
		mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
		
		if (mBaseObj.GetDistanceToPlayer() <= 5.0f)
		{
			mpMover.SetDynamicObjectAvoidanceActive(false);
		}
		
		////////////////////////
		// Enter super hunt if chase is going on too long, try to kill player asap
		if (mbHunt_SuperHuntEnabled)
		{
			float fSuperHuntChange = mBaseObj.PlayerIsSeen() ? afTimeStep : - (0.2f * afTimeStep);
			mfHunt_SuperHuntCounter += fSuperHuntChange;
			if (mfHunt_SuperHuntCounter < 0.0f) mfHunt_SuperHuntCounter = 0;
			if (mbHunt_SuperHunt == false && mbHunt_Unreachable == false && mfHunt_SuperHuntCounter >= 10.0f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Enter Super-Hunt",false,true);
				
				mbHunt_SuperHunt = true;
				mfHunt_SuperHuntCounter += 10.0f;
				mpMover.SetSpeedState(eGhoulSpeed_FastRun);
				
				mBaseObj.PlaySound("EnterSuperHunt", gsGhoulSound_EnterSuperHunt, true, true);
				
				mpStateMachine.StopTimer("SuperHuntTryTeleport");
				mpStateMachine.AddTimer("SuperHuntTryTeleport", 3.0f);
			}
			else if (mfHunt_SuperHuntCounter < 8.0f)
			{
				mbHunt_SuperHunt = false;
				mpMover.SetSpeedState(eGhoulSpeed_Run);
				mpStateMachine.StopTimer("SuperHuntTryTeleport");
			}
		}
        
        ////////////////////////
		// If enabled, updates speed based on player speed and proximity
        if (mbHunt_AdaptiveSpeed)
        {            
            float fDistSqr = cMath_Vector3DistSqr(mBaseObj.GetCharBody().GetFeetPosition(), mBaseObj.GetPlayerFeetPos());
            float fMul = fDistSqr / (mfHunt_AdaptiveSpeedTarDist * mfHunt_AdaptiveSpeedTarDist);
            
            float fTarSpeed = cMath_Clamp((Player_GetSpeed() - 2.f) * fMul, 2.f, 6.2f);
            
            if (Player_GetRunning() == false)	mfHunt_AdaptiveSpeedResetCount -= afTimeStep;
            else							 	mfHunt_AdaptiveSpeedResetCount = 2.f;            
            
            if (mBaseObj.CheckIsOnScreen(true) ||
                mfHunt_AdaptiveSpeedResetCount < 0.f && Player_IsInteracting() == false)
            {                    
                fTarSpeed = 5.2f;
                mfHunt_AdaptiveSpeed = fTarSpeed;
            }
            
            mfHunt_AdaptiveSpeed = cMath_IncreaseTo(mfHunt_AdaptiveSpeed, afTimeStep * 2.f, fTarSpeed);
            mpMover.SetMaxForwardSpeed(mfHunt_AdaptiveSpeed);
        }
		else
		{		
			////////////////////////
			// Slow down if the player isn't looking at us
			if (mbHunt_SuperHunt == false && mbHunt_AdjustSpeed)
			{
				float fFwdSpeed = mBaseObj.CheckIsOnScreen(true) ? gfGhoul_SpeedRun * mpMover.GetSpeedMul() : gfGhoul_SpeedRun * mfHunt_AdjustSpeedMul * mpMover.GetSpeedMul();
				mBaseObj.GetCharBody().SetMaxPositiveMoveSpeed(eCharDir_Forward, fFwdSpeed);
			}
		}

		////////////////////////
		// Check attack range
		if (mbPlayerIsInLos == false) return;

		////////////////////////
		// Determine attack
//		if (mbHunt_Unreachable) return;
		if (mbHunt_ToRetreat) return;
		if (IsAttacking()) return;
		int lWishAttackState = DetermineDesiredAttackState();
		if (lWishAttackState < 0) return;
		mpStateMachine.ChangeState(lWishAttackState);
	}

	//------------------------------------------------------------

	bool State_Hunt_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_AttractAgent) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_EnterProximity) return true;
		if (alMessageId == eLuxEntityMessage_LeaveProximity) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			////////////////////////
			// If player is in sight cancel giving up and reset last prediction
			if (mbPlayerIsInLos)
			{
				mpStateMachine.StopTimer("GiveUpHuntEndOfPath");
				mpStateMachine.StopTimer("GiveUpHuntUndetected");
				mbHunt_PredictedPos = false;
				
				////////////////////////
				// Restart pursuit if it has been cancelled by last pursuit
				if (mpStateMachine.TimerExists("Pursuit") == false)
				{
					mpStateMachine.AddTimer("Pursuit", 0.0f);
				}
			}
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			if (mMode == eGhoulMode_Hunt) return true;
			
            ////////////////////////
            // Give up if ghoul shouldn't predict player pos
            if (gbGhoul_PredictPlayerPos == false)
            {
				mpStateMachine.StopTimer("GiveUpHuntEndOfPath");
                mpStateMachine.AddTimer("GiveUpHuntUndetected", 3.0f);
                return true;
            }
            
            ////////////////////////
			// When losing sight of the player, reveal the position once to simulate
			// the ghoul predicting/hearing where the player moved
			if (mbHunt_PredictedPos == false)
			{
				mbHunt_PredictedPos = true;
				mpStateMachine.AddTimer("RevealPlayerPos", 1.3f);
			}
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mMode == eGhoulMode_Hunt) return true;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EndOfPath");
			
			mpStateMachine.StopTimer("GiveUpHuntUndetected");
			mpStateMachine.StopTimer("Pursuit");
			if (mbHunt_Unreachable)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EndOfPath: can't reach the player, retreat");
				mpStateMachine.AddTimer("Retreat", 1.0f);
			}
			else if (mBaseObj.PlayerIsDetected() == false)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") EndOfPath: player undetected");
				mpStateMachine.AddTimer("GiveUpHuntEndOfPath", 3.0f);
			}
			else
			{
				mpStateMachine.AddTimer("Pursuit", 0.5f);
			}
			return true;
		}

		return false;
	}

	//---------------------------------------------------------

	void State_Hunt_TimerUp(uint64 alId)
	{
		if(alId == H64("Pursuit"))
		{
			if (Blackboard_GetWraithStruggleOwner() != mBaseObj.GetID() && Blackboard_GetWraithStruggleOwner() != tID_Invalid)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Another agent is already struggling");
				mpStateMachine.ChangeState(eGhoulState_StruggleStandBy);
				return;
			}
			
			if (mMode == eGhoulMode_Hunt) mBaseObj.RevealPlayerPos();
			
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetLastKnownPlayerPos(), 0.0f, 5.0f, true, true, false, null);
			cVector3f vLastKnownFeetPos = mBaseObj.GetLastKnownPlayerPos() - cVector3f(0, cLux_GetPlayer().GetCharacterBody().GetSize().y / 2.0f, 0);
			if (pNode !is null && cMath_Vector3Dist(pNode.GetPosition(), vLastKnownFeetPos) <= 2.5f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Pursuit: MoveTo");
				mbHunt_Unreachable = false;
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
			}
			else
			{
				mbHunt_Unreachable = true;
				@pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetLastKnownPlayerPos(), 0.0f, 10.0f, true, false, false, null);
				if (pNode is null)
				{
					@pNode = mpPathfinder.GetNodeAtPos((mBaseObj.GetPosition() + mBaseObj.GetPlayerPos()) / 2.0f, 0.0f, 10.0f, true, false, false, null);
				}
				
				if (pNode is null)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Pursuit: Unreachable, retreat");
					mpStateMachine.AddTimer("Retreat", 0.5);
					return;
				}
				
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Pursuit: Unreachable, move to closest");
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
			}
			
			mpStateMachine.AddTimer("Pursuit", 0.5f);
		}
		
		/////////////////////
		// During SuperHunt teleport towards the player when they're not looking at us
		if(alId == H64("SuperHuntTryTeleport"))
		{
			if (mbHunt_SuperHunt == false)
			{
				mpStateMachine.AddTimer("SuperHuntTryTeleport", 0.5f);
				return;
			}
			
			if (mBaseObj.GetEntityIsInPlayerFOV() == false)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Super-Hunt teleport");
				mBaseObj.SetPosition(mBaseObj.GetPlayerPos() - cLux_GetPlayer().GetCharacterBody().GetForward() * 1.0f);
				mpStateMachine.AddTimer("SuperHuntTryTeleport", 5.0f);
			}
			else
			{
				mpStateMachine.AddTimer("SuperHuntTryTeleport", 0.5f);
			}
		}
		
		if(alId == H64("Retreat"))
		{
			mbRetreat_CalculatePos = true;
			mbRetreat_ProximityActive = false;
			mpStateMachine.ChangeState(eGhoulState_Retreat);
		}

		if(alId == H64("GiveUpHuntEndOfPath") || alId == H64("GiveUpHuntUndetected"))
		{
			if (mBaseObj.PlayerIsDetected() == false)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Give up hunt, lost player");
				mpStateMachine.ChangeState(eGhoulState_PostHunt);
			}
		}
		
		if(alId == H64("RevealPlayerPos"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Reveal player position");
			mBaseObj.RevealPlayerPos();
		}
	}
	
	//------------------------------------------------------------
    
    void Hunt_ExecuteEnterCallback()
    {
		if (msHunt_EnterCallback == "") return;
		
        tString sMethodName = "void " + msHunt_EnterCallback + "()";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.ScriptExecute();
		}
		
		if (mbHunt_EnterCallbackAutoRemove) msHunt_EnterCallback = "";
    }
    
    //------------------------------------------------------------

	//} END HUNT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: POST HUNT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlPostHunt_CheckCount = 0;
	cVector3f mvPostHunt_SoundPos;
	int mlPostHunt_SoundPrio = -1;
	bool mbPostHunt_SensesEnabled = true;

	//------------------------------------------------------------

	void State_PostHunt_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PostHunt ------",false,true);
		
		EnterInvestigateState(false);

		mlPostHunt_CheckCount = 0;
		mlPostHunt_SoundPrio = -1;
		mbPostHunt_SensesEnabled = false;
		
		mBaseObj.ResetPlayerDetectionState();
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		
		mpStateMachine.AddTimer("Scream", 0.5f);
		mpStateMachine.AddTimer("TurnToPlayer", 2.0f);
		mpStateMachine.AddTimer("EnableSenses", 2.0f);
		mpStateMachine.AddTimer("SearchForPlayer", 4.0f);
	}
	
	//------------------------------------------------------------

	void State_PostHunt_Leave()
	{
		LeaveInvesitgateState();
	}
	
	//------------------------------------------------------------

	void State_PostHunt_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_PostHunt_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_PlayerDead) return false;
		if (mbPostHunt_SensesEnabled == false) return true;
		if (GetSensesActive(false) == false) return true;
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_Hunt);
			return true;
		}
		
		if (alMessageId == eCustomEntityMessage_AttractAgent) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetSensesActive() == false) return true;
			
			mvPostHunt_SoundPos = mpStateMachine.GetCurrentMessageData().mvX;
			mlPostHunt_SoundPrio = mpStateMachine.GetCurrentMessageData().mlX;
			return true;
		}
		return false;
	}
	
	//------------------------------------------------------------

	void State_PostHunt_TimerUp(uint64 alId)
	{
		if(alId == H64("Scream"))
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
			if (mpStateMachine.GetPrevState() != eGhoulState_Blocked || mpStateMachine.GetPrevState() != eGhoulState_BlockedByProp)
			{
				mBaseObj.PlaySound("Scream", gsGhoulSound_Scream, true, true);
				PlayRandomAnimation(mvGhoulAnim_Scream, 0.0f, false, false, "");
			}
		}
		
		///////////////////////
		// Restart hunt if player is spotted
		if(alId == H64("EnableSenses"))
		{
			mbPostHunt_SensesEnabled = true;
		}
		
		if(alId == H64("TurnToPlayer"))
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
			mpStateMachine.AddTimer("TurnToPlayer", 0.5f);
		}
		
		if(alId == H64("SearchForPlayer"))
		{
			if (mBaseObj.PlayerIsDetected() == false)
			{
				if (mlPostHunt_SoundPrio < 0)
				{
					mvSearchArea_SearchPos = mBaseObj.GetPosition() + mvHunt_LastPlayerDir * 4.0f;
					mpStateMachine.ChangeState(eGhoulState_SearchArea);
				}
				else
				{
					mvInvestigateSound_Goal = mvPostHunt_SoundPos;
					mlInvestigateSound_Prio = mlPostHunt_SoundPrio;
					mpStateMachine.ChangeState(eGhoulState_InvestigateSound);
				}
			}
			else
			{
				mpStateMachine.ChangeState(eGhoulState_Hunt);
			}
		}
	}
	
	//------------------------------------------------------------

	//} END POSTHUNT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: SEARCH FOR PLAYER
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlSearchForPlayer_SearchCount = 0;
	int mlSearchForPlayer_SearchesToPerform = 0;
	bool mbSearchForPlayer_Searching = false;
	cVector3f mvSearchForPlayer_AssumedPlayerPos;

	//------------------------------------------------------------

	void State_SearchForPlayer_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: SearchForPlayer ------",false,true);
		
		SetEyeColor(gGhoul_EyeColorAlerted);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearSpotted);
		
		mpPathfinder.Stop();
		
		mbAvoidingDeadEndPlayer = false;
		
		if (mbSearchForPlayer_Searching == false)
		{
			mbSearchForPlayer_Searching = true;
			mlSearchForPlayer_SearchCount = 0;
			mlSearchForPlayer_SearchesToPerform = cMath_RandRectl(glMinSearches, glMaxSearches);
			
			mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
			mpStateMachine.AddTimer("MoveTowardsPlayer", 0.2f);
			
			mBaseObj.PlaySound("StartSearch", gsGhoulSound_StartSearch, true, true);
		}
		else
		{
			mpMover.SetSpeedState(eGhoulSpeed_Walk);
			mpStateMachine.AddTimer("MoveToSearchPos", cMath_RandRectf(1.0f, 2.5f));
		}
		
		mpStateMachine.AddTimer("PlaySearchSound", 4.0f);
		mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
	}
	
	//------------------------------------------------------------

	void State_SearchForPlayer_Leave()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearDefault);
	}
	
	//------------------------------------------------------------

	void State_SearchForPlayer_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_SearchForPlayer_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_MovingAlert);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			return StartNewSearch();
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_SearchForPlayer_TimerUp(uint64 alId)
	{
		if(alId == H64("MoveTowardsPlayer"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Move towards the player");
			
			cVector3f vClosePos = mBaseObj.GetPosition() + (mBaseObj.GetPlayerFeetPos() - mBaseObj.GetPosition()) * 0.5f;
			
			///////////////////////
			// Don't move too close to the player
			if (cMath_Vector3Dist(vClosePos, mBaseObj.GetPlayerPos()) < 5.0f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Would end up too close to the player, keeping distance");
				mlSearchForPlayer_SearchCount = -1;
				StartNewSearch();
				return;
			}
			
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(vClosePos, 0.0f, 4.0f, true, false, false, null);
			if (pNode !is null)
			{
				mpPathfinder.MoveTo(pNode.GetPosition(), 0.2f, false);
				mpStateMachine.AddTimer("SearchTookTooLong", 10.0f);
			}
		}
		
		if(alId == H64("MoveToSearchPos"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Search #" + (mlSearchForPlayer_SearchCount + 1));
			
			if (mlSearchForPlayer_SearchCount <= 1)
			{
				mvSearchForPlayer_AssumedPlayerPos = mBaseObj.GetPlayerPos();
			}
			
			cVector3f vExcludedSectorDir = mvSearchForPlayer_AssumedPlayerPos - mBaseObj.GetPosition();
			cAINode@ pNode = mpPathfinder.GetNodeInCircularSectorAroundPos(mvSearchForPlayer_AssumedPlayerPos, 7.0f, 12.0f, vExcludedSectorDir, 90.0f, false, false, false, null);
			if (pNode !is null)
			{
				mpPathfinder.MoveTo(pNode.GetPosition(), 0.2f, false);
				mpStateMachine.AddTimer("SearchTookTooLong", 10.0f);
				mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
			}
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Couldn't find a node to search, transition to sniff");
				mpStateMachine.ChangeState(eGhoulState_Sniff);
			}
		}
		
		if(alId == H64("SearchTookTooLong"))
		{
			if (mbAvoidingDeadEndPlayer && IsPlayerInDeadEnd()) return;
			
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Took to long to arrive, search elsewhere");
			StartNewSearch();
		}
		
		if(alId == H64("StopSearching"))
		{
			mbSearchForPlayer_Searching = false;
			mbHunt_HuntedRecently = false;
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
		
		if(alId == H64("PlaySearchSound"))
		{
			cLux_AddTodoMessage("TODO-SOUND: looping search sound for the ghoul, for example heavy breathing");
			if (cMath_RandRectf(0.0f, 1.0f) <= 0.7f)
			{
				mBaseObj.PlaySound("Searching", gsGhoulSound_Searching, true, true);
			}
			mpStateMachine.AddTimer("PlaySearchSound", 5.0f);
		}
		
		if(alId == H64("CheckDeadEnd"))
		{
			if (HandlePlayerDeadEnd(0.1f, 10.0f))
			{
				mpStateMachine.StopTimer("SearchTookTooLong");
				mpStateMachine.AddTimer("SearchTookTooLong", 10.0f);
			}
			mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
		}
	}
	
	//------------------------------------------------------------
	
	bool StartNewSearch()
	{
		mpStateMachine.StopTimer("SearchTookTooLong");
		mbAvoidingDeadEndPlayer = false;
		mpPathfinder.Stop();
				
		if (mlSearchForPlayer_SearchCount >= mlSearchForPlayer_SearchesToPerform)
		{
			mBaseObj.PlaySound("GiveUp", gsGhoulSound_GiveUp, true, true);
			mpMover.PlayAnimation(gsGhoulAnim_Frustration, 0.0f, false, false, "");
			
			mpStateMachine.AddTimer("StopSearching", cMath_RandRectf(1.0f, 2.5f));
			return true;
		}
		else
		{
			mBaseObj.PlaySound("LookAround", gsGhoulSound_LookAround, true, true);
			PlayRandomAnimation(mvGhoulAnim_LookAroundLong, 0.0f, false, false, "");
		}
		
		if (mlSearchForPlayer_SearchCount == 0)
		{
			mpMover.SetSpeedState(eGhoulSpeed_Walk);
		}

		///////////////////////
		// 30% chance to sniff
		if (mlSearchForPlayer_SearchCount >= 0 && cMath_RandRectf(0.0f, 1.0f) <= 0.3f)
		{
			mpStateMachine.ChangeState(eGhoulState_Sniff);
			return true;
		}
		
		mpStateMachine.AddTimer("MoveToSearchPos", cMath_RandRectf(1.0f, 2.5f));
		++mlSearchForPlayer_SearchCount;
		
		return false;
	}
	
	//------------------------------------------------------------

	//} END SEARCH FOR PLAYER
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: SEARCH AREA
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	///////////////////////
	// Settings - can be set from a different state
	cVector3f mvSearchArea_SearchPos;
	bool mbSearchArea_Sniff = true;
	bool mbSearchArea_SearchBehind = true;
	
	cVector3f mvSearchArea_ForwardDir;
	array<cVector3f> mvSearchArea_Positions;
	array<cVector3f> mvSearchArea_Directions;
	float mfSearchArea_Radius = 7.0f;
	int mlSearchArea_MoveIndex = 0;
	int mlSearchArea_RaycastIndex = 0;
	float mfSearchArea_SniffChance = 0.2f;
	
	//------------------------------------------------------------

	void State_SearchArea_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: SearchArea ------",false,true);
		
		EnterInvestigateState();
		
		if (mAlertState == eGhoulAlertState_None) mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
		
		if (UsesVoice()) mpBarkMachine.ChangeState(eGhoulBark_Search);
		
		if (mpStateMachine.GetPrevState() == eGhoulState_Sniff)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Continue search");
			mpStateMachine.AddTimer("MoveToNextPos", 1.0f);
			return;
		}
		
		mvSearchArea_Positions.resize(0);
		mvSearchArea_Directions.resize(0);
		mlSearchArea_MoveIndex = 0;
		mlSearchArea_RaycastIndex = 0;
		
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvSearchArea_SearchPos, 0.0f, 5.0f, true, false, false, null);
		if (pNode is null)
		{
			cVector3f vPosDir = mvSearchArea_SearchPos - mBaseObj.GetPosition();
			vPosDir.y = 0;
			vPosDir.Normalize();
			mvSearchArea_SearchPos = mBaseObj.GetPosition() + vPosDir * 2.0f;
			@pNode = mpPathfinder.GetNodeAtPos(mvSearchArea_SearchPos, 0.0f, 5.0f, true, false, false, null);
		}
		if (pNode is null)
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
				
		mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
		mvSearchArea_ForwardDir = pNode.GetPosition() - mBaseObj.GetPosition();
		mvSearchArea_ForwardDir.y = 0;
		mvSearchArea_ForwardDir.Normalize();
	}
	
	//------------------------------------------------------------

	void State_SearchArea_Leave()
	{
		LeaveInvesitgateState();
		
		mpBarkMachine.ChangeState(eGhoulBark_Silent);
		
		mbSearchArea_Sniff = true;
		mbSearchArea_SearchBehind = true;
	}
	
	//------------------------------------------------------------

	void State_SearchArea_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
		UpdateSmellDetection(afTimeStep);
//		UpdateQuickHoleReturn(afTimeStep, 18.0f);
	}
	
	//------------------------------------------------------------

	bool State_SearchArea_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mvSearchArea_Positions.length() == 0)
			{
				mpMover.PlayAnimation(gsGhoulAnim_LookAroundShort, 0.0f, false, false, "");
				mpStateMachine.AddTimer("DetermineSearchPositions", 1.8f);
			}
			else
			{
				mpMover.PlayAnimation(gsGhoulAnim_LookAroundShort, 0.0f, false, false, "");
				mpStateMachine.AddTimer("MoveToNextPos", 1.8f);
			}
			return true;
		}
		return false;
	}
	
	//------------------------------------------------------------
	
	void SearchArea_RaycastResult(bool abSuccesful, float afDistance, const cVector3f&in avNormal, iPhysicsBody@ apBody, int alUserValue)
	{
		float fDist = abSuccesful ? afDistance : mfSearchArea_Radius;
		cVector3f vSearchPos = mvSearchArea_SearchPos + mvSearchArea_Directions[mlSearchArea_RaycastIndex] * fDist;
		mvSearchArea_Positions.push_back(vSearchPos);
		++mlSearchArea_RaycastIndex;
		
		if (mvSearchArea_Positions.length() == mvSearchArea_Directions.length())
		{
			mpStateMachine.AddTimer("MoveToNextPos", 0.0f);
		}
	}
	
	//------------------------------------------------------------

	void State_SearchArea_TimerUp(uint64 alId)
	{
		if(alId == H64("DetermineSearchPositions"))
		{
			bool bClockwise = cMath_RandRectl(0, 1) == 0;
				
			tString sClockwise = bClockwise ? "clockwise" : "counter clockwise";
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Searching " + sClockwise);
			if (bClockwise)
			{
				mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(45.0f)), mvSearchArea_ForwardDir));
//				mvSearchArea_Directions.push_back(mvSearchArea_ForwardDir);
				mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-45.0f)), mvSearchArea_ForwardDir));
				if (mbSearchArea_SearchBehind)
				{
					mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-135.0f)), mvSearchArea_ForwardDir));
//					mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-180.0f)), mvSearchArea_ForwardDir));
					mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-225.0f)), mvSearchArea_ForwardDir));
				}
			}
			else
			{
				mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(-45.0f)), mvSearchArea_ForwardDir));
//				mvSearchArea_Directions.push_back(mvSearchArea_ForwardDir);
				mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(45.0f)), mvSearchArea_ForwardDir));
				if (mbSearchArea_SearchBehind)
				{
					mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(135.0f)), mvSearchArea_ForwardDir));
//					mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(180.0f)), mvSearchArea_ForwardDir));
					mvSearchArea_Directions.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_ToRad(225.0f)), mvSearchArea_ForwardDir));
				}
			}

			mvSearchArea_SearchPos = mBaseObj.GetPosition();
			
			for (int i = 0; i < mvSearchArea_Directions.length(); ++i)
			{
				cVector3f vRaycastFrom = mvSearchArea_SearchPos;
				vRaycastFrom.y += -mBaseObj.GetCharBody().GetSize().y / 2.0f + 0.2f;
				mBaseObj.GetClosestBody("SearchArea_RaycastResult", vRaycastFrom, mvSearchArea_Directions[i], mfSearchArea_Radius);
			}
		}
		
		if(alId == H64("MoveToNextPos"))
		{
			cAINode@ pNode;
			bool bNextPosFound = false;
			while (bNextPosFound == false && mlSearchArea_MoveIndex < mvSearchArea_Positions.length() && mBaseObj.GetDistanceToPlayer() <= 15.0f)
			{
				@pNode = mpPathfinder.GetNodeAtPos(mvSearchArea_Positions[mlSearchArea_MoveIndex], 0.0f, 5.0f, true, false, false, null);
				if (pNode !is null)
				{
					bNextPosFound = true;
				}
				++mlSearchArea_MoveIndex;
			}
			
			if (pNode !is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Searching position " + mlSearchArea_MoveIndex + "/" + mvSearchArea_Positions.length());
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
			}
			else
			{
				if (mBaseObj.GetDistanceToPlayer() > 15.0f)
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Stop search because the player is too far away");
				}
				else if (mlSearchArea_MoveIndex >= mvSearchArea_Positions.length())
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Search complete");
					
				}
				else
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No search node could be found");
				}
				
				if (UsesVoice() && msEndSearchSubject != "") mpBarkMachine.PlayVoice(msEndSearchSubject, 1);
				mpStateMachine.AddTimer("Exit", 2.0f);
			}
		}
		
		if(alId == H64("Exit"))
		{
			if (mbDetectSmell) mpStateMachine.ChangeState(eGhoulState_TrackSmell);
			else mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}
	
	//------------------------------------------------------------

	//} END SEARCH AREA
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: CHECK LAST KNOWN POSITION
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfCheckLastKnownPosition_StartPlayerDistance;
	bool mbCheckLastKnownPosition_FromBackupRequest = false;
	cVector3f mvCheckLastKnownPosition_Goal;
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: CheckLastKnownPosition ------",false,true);
		
		///////////////////////
		// Setup
		EnterInvestigateState();
		
		if (mAlertState == eGhoulAlertState_None) mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
		
		mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkSearch);
		
		mbAvoidingDeadEndPlayer = false;
		mfCheckLastKnownPosition_StartPlayerDistance = cMath_Vector3Dist(mBaseObj.GetPosition(), mBaseObj.GetLastKnownPlayerPos());
		
		///////////////////////
		// Action
		if (mbCheckLastKnownPosition_FromBackupRequest == false)
		{
			mvCheckLastKnownPosition_Goal = mBaseObj.GetLastKnownPlayerPos();
			
			///////////////////////
			// Request backup
			if (Terror_GetAmount() > 0.4f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Request backup");
				
				Blackboard_RequestBackup(mBaseObj.GetID(), mBaseObj.GetLastKnownPlayerPos(), eGhoulState_CheckLastKnownPosition, Terror_GetAmount() > 0.6f ? 2 : 1, gfBlackboardMessageRange);

				cLux_AddTodoMessage("TODO-SOUND: call out backup");
				mBaseObj.PlaySound("StartHunt", gsGhoulSound_CallOutBackup, true, true);

				cLux_AddTodoMessage("TODO-ANIM: call out");
				mpMover.PlayAnimation(gsGhoulAnim_CallOut, 0.0f, false, false, "");
			}
			
			mpStateMachine.AddTimer("MoveToLastKnownPos", mAlertState == eGhoulAlertState_None ? 0.5f : 0.0f);
		}
		///////////////////////
		// Don't propagate backup call to other ghouls
		else
		{
			mbCheckLastKnownPosition_FromBackupRequest = false;
			mpStateMachine.AddTimer("MoveToLastKnownPos", cMath_RandRectf(0.9f, 1.8f));
		}
		
		if (UsesVoice() && msCheckLastKnownPositionSubject != "") mpBarkMachine.PlayVoice(msCheckLastKnownPositionSubject, 1);
	
		mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
	}
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_Leave()
	{
		mpMover.SetWalkAnimName(msWalkAnim);
		LeaveInvesitgateState();
	}
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
	}
	
	//------------------------------------------------------------

	bool State_CheckLastKnownPosition_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo && mbPlayerIsInLos) return true;
		
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_MovingAlert);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_MovingAlert);
			return true;
		}
		
		///////////////////////
		// Ignore sound if it's too close to the last known position
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetSensesActive() == false) return true;
			if (cMath_Vector3Dist(mvCheckLastKnownPosition_Goal, mpStateMachine.GetCurrentMessageData().mvX) < 2.0f) return true;
		}	
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpStateMachine.AddTimer("Arrived", cMath_RandRectf(1.0f, 2.0f));
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_CheckLastKnownPosition_TimerUp(uint64 alId)
	{
		if(alId == H64("MoveToLastKnownPos"))
		{
			cAINode@ pNode = mpPathfinder.GetNodeInPosLOS(mvCheckLastKnownPosition_Goal - mBaseObj.GetPlayerDir() * 2.0f, mvCheckLastKnownPosition_Goal, 0.0f, 5.0f);
			if (pNode !is null)
			{
				mpPathfinder.MoveTo(pNode.GetPosition(), 0.2f, false);
			}
			else
			{
				mpStateMachine.ChangeState(eGhoulState_Idle);
			}
		}
		
		if(alId == H64("Arrived"))
		{
			mpStateMachine.ChangeState(eGhoulState_TrackSmell);
		}
		
		if (alId == H64("CheckDeadEnd"))
		{
			HandlePlayerDeadEnd(0.1f, 10.0f, 8.0f);
			mpStateMachine.AddTimer("CheckDeadEnd", 0.5f);
		}
	}
	
	//------------------------------------------------------------

	//} END CHECK LAST KNOWN POSITION
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: PLAYER LIGHT DETECTED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbPlayerLightDetected_LightDetection = false;
	bool mbPlayerLightDetected_DetectedGobo = false;
	bool mbPlayerLightDetected_DetectedFlash = false;
	int mlPlayerLightDetected_Count = 0;
	cVector3f mvPlayerLightDetected_LastPlayerPos;
	tString msPlayerLightdetected_AnimState = "";
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PlayerLightDetected ------");

		SetEyeColor(gGhoul_EyeColorAlerted);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		
		msPlayerLightdetected_AnimState = "";
		mbPlayerLightDetected_LightDetection = false;
		mbPlayerLightDetected_DetectedGobo = false;
		mbPlayerLightDetected_DetectedFlash = false;
		mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
		
		mBaseObj.Timer_Remove("Timer_PlayerLightDetected_ResetCount");
					
		++mlPlayerLightDetected_Count;
		if (mlPlayerLightDetected_Count >= 3)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Counter too high, go to hunt");
			mpStateMachine.ChangeState(eGhoulState_Hunt);
			return;
		}
		
		mBaseObj.PlaySound("PlayerDetected", gsGhoulSound_PlayerDetected, true, true);
		
		if (mBaseObj.GetMeshEntity().GetAnimationStateFromName(gsGhoulAnim_PlayerDetected) !is null) mpMover.PlayAnimation(gsGhoulAnim_PlayerDetected, 0.3f, false, false, "");
		
//		mpStateMachine.AddTimer("LightSwitchDetection", 1.0f);
		mpStateMachine.AddTimer("ActivateLightDetection", 2.0f);
		mpStateMachine.AddTimer("DecideAction", 3.5f);
	}
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_Leave()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		mBaseObj.Timer_Add("Timer_PlayerLightDetected_ResetCount", 5.0f, "OnTimer_PlayerLightDetected_ResetCount");
	}
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_Update(float afTimeStep)
	{
		if (mBaseObj.GetDistanceToPlayer() < 8.0f && mBaseObj.PlayerIsDetected())
		{
			mpStateMachine.ChangeState(eGhoulState_Alert);
		}
	}
	
	//------------------------------------------------------------

	bool State_PlayerLightDetected_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msPlayerLightdetected_AnimState == "NothingFound")
			{
				mpStateMachine.AddTimer("ExitIdle", 0.5f);
			}
			msPlayerLightdetected_AnimState = "";
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
//			if (mbPlayerLightDetected_LightDetection == false) return true;
//			mpStateMachine.ChangeState(eGhoulState_Alert);
			return false;
		}
		
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
		{
			if (mbPlayerLightDetected_LightDetection == false) return true;
			mbPlayerLightDetected_DetectedGobo = true;
			mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
			return true;
		}
		
		if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (mbPlayerLightDetected_LightDetection == false) return true;
			mbPlayerLightDetected_DetectedFlash = true;
			mvPlayerLightDetected_LastPlayerPos = mBaseObj.GetPlayerPos();
			return true;
		}
		
		return false;
	}
	
	//------------------------------------------------------------

	void State_PlayerLightDetected_TimerUp(uint64 alId)
	{
		if (alId == H64("ActivateLightDetection"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Light detection ON");
			mBaseObj.ResetPlayerDetectionState();
			mbPlayerLightDetected_LightDetection = true;
		}
		
		if (alId == H64("DecideAction"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") DecideAction");
			if (mBaseObj.PlayerIsDetected())
			{
				mpStateMachine.ChangeState(eGhoulState_Alert);
			}
			else if (mbPlayerLightDetected_DetectedFlash)
			{
				mpStateMachine.ChangeState(eGhoulState_CheckFlashlightHit);
			}
			else if (mbPlayerLightDetected_DetectedGobo)
			{
				mpStateMachine.ChangeState(eGhoulState_CheckGobo);
			}
			else
			{
				mpStateMachine.AddTimer("NothingFound", 0.0f);
			}
		}
		
		if (alId == H64("NothingFound"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") NothingFound");
			msPlayerLightdetected_AnimState = "NothingFound";
			mBaseObj.PlaySound("LostTrackSmall", gsGhoulSound_LostTrackSmall, true, true);
			mpMover.PlayAnimation(gsGhoulAnim_ShrugOff, 0.2f, false, false, "");
		}
		
		if (alId == H64("LightSwitchDetection"))
		{
			if (Player_GetLightSwitchCounter() > 2.0f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") LightSwitchDetection, flashed the light too much, hunt");
				mpStateMachine.ChangeState(eGhoulState_Hunt);
				return;
			}
			mpStateMachine.AddTimer("LightSwitchDetection", 0.2f);
		}
		
		
		
		if (alId == H64("ExitIdle"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ExitIdle");
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}
	
	void OnTimer_PlayerLightDetected_ResetCount(uint64 alID)
	{
		mlPlayerLightDetected_Count = 0;
	}
	
	//------------------------------------------------------------

	//} END PLAYER LIGHT DETECTED
	
	///////////////////////////////////
	// STATE: CHECK GOBO
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvCheckGobo_GoboToPlayer;
	cVector3f mvCheckGobo_GoboPos;
	
	//------------------------------------------------------------

	void State_CheckGobo_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: CheckGobo ------",false,true);
		
		EnterInvestigateState();
		
		if (mAlertState == eGhoulAlertState_None) mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
		
		mvCheckGobo_GoboPos = mvGoboPos;
		mvCheckGobo_GoboToPlayer = mvPlayerLightDetected_LastPlayerPos - mvGoboPos;
		mvCheckGobo_GoboToPlayer.y = 0;
		
		mpStateMachine.AddTimer("MoveTo", 0.2f);
	}
	
	//------------------------------------------------------------

	void State_CheckGobo_Leave()
	{
		LeaveInvesitgateState();
	}
	
	//------------------------------------------------------------

	void State_CheckGobo_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
	}
	
	//------------------------------------------------------------

	bool State_CheckGobo_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo)
		{
			if (mpStateMachine.TimerExists("MoveTo") == false)
			{
				mvCheckGobo_GoboPos = mvGoboPos;
				mvCheckGobo_GoboToPlayer = mBaseObj.GetPlayerPos() - mvGoboPos;
				mvCheckGobo_GoboToPlayer.y = 0;
				mpStateMachine.AddTimer("MoveTo", 0.2f);
			}
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			mpStateMachine.ChangeState(eGhoulState_Alert);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpMover.TurnToPos(mBaseObj.GetPosition() + mvCheckGobo_GoboToPlayer);
			mpStateMachine.AddTimer("Exit", 2.0f);
		}
		return false;
	}
	
	//------------------------------------------------------------

	void State_CheckGobo_TimerUp(uint64 alId)
	{
		if (alId == H64("MoveTo"))
		{
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvCheckGobo_GoboPos + mvCheckGobo_GoboToPlayer * 0.6f, 0.0f, 5.0f, true, false, false, null);
			cVector3f vMoveTo = pNode is null ? mvGoboPos : pNode.GetPosition();
			mpPathfinder.MoveTo(vMoveTo, 1.0f, false);
		}
		
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eGhoulState_TrackSmell);
		}
	}
	
	//------------------------------------------------------------

	//} END CHECK GOBO
	
	///////////////////////////////////
	// STATE: CHECK FLASHLIGHT HIT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvCheckFlashlightHit_PlayerPos;
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: CheckFlashlightHit ------",false,true);
		
		EnterInvestigateState();
		
		if (mAlertState == eGhoulAlertState_None) mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
		
		mvCheckFlashlightHit_PlayerPos = mvPlayerLightDetected_LastPlayerPos;
		
		mBaseObj.ResetPlayerDetectionState();
		
		mpStateMachine.AddTimer("Turn", 0.0f);
	}
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_Leave()
	{
		LeaveInvesitgateState();
	}
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
	}
	
	//------------------------------------------------------------

	bool State_CheckFlashlightHit_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			mpStateMachine.ChangeState(eGhoulState_Alert);
			return true;
		}

		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpStateMachine.AddTimer("Exit", 2.0f);
		}
		return false;
	}
	
	//------------------------------------------------------------

	void State_CheckFlashlightHit_TimerUp(uint64 alId)
	{
		if (alId == H64("Turn"))
		{
			mpMover.TurnToPos(mvCheckFlashlightHit_PlayerPos);
			mpStateMachine.AddTimer("MoveTo", 0.5f);
		}
		
		if (alId == H64("MoveTo"))
		{
			cVector3f vToPlayer = mvCheckFlashlightHit_PlayerPos - mBaseObj.GetPosition();
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + vToPlayer * 0.6f, 0.0f, 5.0f, true, false, false, null);
			if (pNode !is null)
			{
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
			}
			else
			{
				mpStateMachine.AddTimer("Exit", 2.0f);
			}
		}
		
		if (alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eGhoulState_TrackSmell);
		}
	}
	
	//------------------------------------------------------------

	//} END FLASHLIGHT HIT
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: ATTRACTED
	//{////////////////////////////////

	//------------------------------------------------------------
	
	bool mbAttracted_Enabled = true;
	cVector3f mvMeatAttractPos;

	//------------------------------------------------------------

	void ClearMeatAttraction()
	{
		mBaseObj.SetVarString("CurrentMeatAttraction","");
	}
	
	//------------------------------------------------------------

	void State_Attracted_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Attracted ------");

		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);

		mBaseObj.SetSightRangeMul(0.8f);
		mBaseObj.SetFOVMul(0.6f);
		mBaseObj.ResetPlayerDetectionState();

		mBaseObj.PlaySound("Sniff", gsGhoulSound_Smell, true, true);
		
		///////////////////////
		// Check if there's a node near the attraction, go to the closest
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvMeatAttractPos, 0.0f, 5.0f, true, false, false, null);
		if (pNode !is null)
		{
			cVector3f vMoveTo = cMath_Vector3Dist(pNode.GetPosition(), mvMeatAttractPos) <= 1.5f ? mvMeatAttractPos : pNode.GetPosition();
			mpPathfinder.MoveTo(vMoveTo, 1.0f, false);
		}
		else
		{
			mpStateMachine.AddTimer("ExitState", 0.4f);
		}	
	}

	//------------------------------------------------------------

	void State_Attracted_Leave()
	{
		mBaseObj.SetSightRangeMul(1.0f);
		mBaseObj.SetFOVMul(1.0f);
		Terror_RemoveEnemy(mBaseObj.GetID());
	}

	//------------------------------------------------------------

	void State_Attracted_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
		TryHunt();
	}

	//------------------------------------------------------------

	bool State_Attracted_Message(int alMessageId)
	{
		// Ignore additional attract messages once we're locked on to meat
		if (alMessageId == eCustomEntityMessage_AttractAgent) return true;

		// Ignore sounds while we're attracted to meat.
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;

		// Handle player detection slightly differently when ghoul is fascinated by meat
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			Terror_RemoveEnemy(mBaseObj.GetID());
			return true;
		}
		
		if (alMessageId == eCustomEntityMessage_SeeFlashlightGobo) return true;
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			///////////////////////
			// If the attraction isn't within reach, give up
			if (cMath_Vector3Dist(mBaseObj.GetPosition(), mvMeatAttractPos) > 1.5f)
			{
				mBaseObj.PlaySound("GiveUpSound", gsGhoulSound_GiveUp, true, true);
				PlayRandomAnimation(gvGhoulAnim_AngryGesture, 0.0f);
				
				mpStateMachine.AddTimer("ExitState", 0.4f);
			}
			return true;
		}

		return false;
	}

	//------------------------------------------------------------

	void State_Attracted_TimerUp(uint64 alId)
	{
		if (alId == H64("ExitState"))
		{
			cScript_RunGlobalFunc(mBaseObj.GetVarString("CurrentMeatAttraction"), "", "_Global_SetUnreachable");
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}

	//------------------------------------------------------------

	//} END ATTRACTED

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: EATMEAT
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_EatMeat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: EatMeat ------",false,true);
		mBaseObj.SetSightRangeMul(0.2f);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Stopped);
		
		if (UsesVoice()) mpBarkMachine.ChangeState(eGhoulBark_EatMeat);

		mpProximitySensor.ResetAllStates();

		mpStateMachine.AddTimer("KickProxSensors", 1.0f);

		if (cLux_ScriptDebugOn())
		{
			mpStateMachine.AddTimer("FinishEating", cMath_RandRectf(5.0f, 6.0f));
		}
		else
		{
			mpStateMachine.AddTimer("FinishEating", cMath_RandRectf(35.0f, 45.0f));
		}

		mpMover.PlayAnimation(gsGhoulAnim_EatLoop, 0.5f, true, true, "");
		SetEatVolume(0.5f);		
	}

	//------------------------------------------------------------

	void State_EatMeat_Leave()
	{
		mpBarkMachine.ChangeState(eGhoulBark_Silent);
		
		// Clear meat attraction
		ClearMeatAttraction();
		SetEatVolume(0.0f);
		SetGrowlVolume(0.0f, 0);
		
		mBaseObj.SetSightRangeMul(1.0f);
		mBaseObj.SetFOVMul(1.0f);
		
		mpMover.SetUseMoveStateAnimations(true);
		
		Terror_RemoveEnemy(mBaseObj.GetID());
	}

	//------------------------------------------------------------

	void State_EatMeat_Update(float afTimeStep)
	{
		TryHunt();
		
		///////////////////////
		// If player isn't in front of us and not in line of sight, just eat at full volume
		cVector3f vPlayerPos = mBaseObj.GetPlayerFeetPos();
		float fDist = mBaseObj.GetDistanceToPlayer();

		if (mBaseObj.GetPointIsInFront(vPlayerPos) == false || mbPlayerIsInLos == false || fDist > 6.0f)
		{
			mbAngryWhileEating=false;
			SetEatVolume(1.0f);
			SetGrowlVolume(0.0f, 0);
			return;
		}

		///////////////////////////
		// As the player gets closer, growl
		if (fDist <= 6.0f && fDist > 5.0f)
		{
			SetGrowlVolume(0.0f, afTimeStep);
			SetEatVolume(0.5f);
			mbAngryWhileEating = false;
			return;
		}
		else if (fDist > 3.0f)
		{
			SetEatVolume(0.0f);
			SetGrowlVolume(0.2f, afTimeStep);
			mbAngryWhileEating = false;
			return;
		}
		else if (fDist <= 2.0f)
		{
			SetEatVolume(0.0f);
			SetGrowlVolume(1.0f, afTimeStep);
			mbAngryWhileEating = true;
			return;
		}
	}

	//------------------------------------------------------------

	bool State_EatMeat_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_HitByProp) return false;
		
		int lProximityState = mpStateMachine.GetCurrentMessageData().mlX;
		
		if (alMessageId == eLuxEntityMessage_EnterProximity)
		{
			if (lProximityState == eGhoulProximity_Close)
			{
				Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime);
				return true;
			}
		}
		
		if (alMessageId == eLuxEntityMessage_LeaveProximity)
		{
			if (lProximityState == eGhoulProximity_Close)
			{
				Terror_RemoveEnemy(mBaseObj.GetID());
				return true;
			}
		}

		return true;
	}

	//------------------------------------------------------------

	void State_EatMeat_TimerUp(uint64 alId)
	{
		
		if (alId == H64("KickProxSensors"))
		{
			// TODO: figure out what it does
			//cLux_AddDebugMessage("Kicked");
			mpProximitySensor.ResetAllStates();
			mpStateMachine.AddTimer("KickProxSensors", 1.0f);
		}

		//////////////////////////////
		// Done eating!
		if (alId == H64("FinishEating"))
		{
			mBaseObj.SetVarString("CurrentMeatAttraction", "");

			mpMover.PlayAnimation(gsGhoulAnim_EatStop, 0.5f, false, false, "");
			mpStateMachine.AddTimer("GoToIdle", 0.4f);
		}

		//////////////////////////////
		// Return to idle state
		if (alId == H64("GoToIdle"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
		
	}

	//------------------------------------------------------------

	//} END EATMEAT
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// STATE: POST ATTACK RETREAT
	//{//////////////////////////////////////
	
	//------------------------------------------------------------
	
	cLuxArea@ mpPostAttack_Retreat_Spawn;
	
	//------------------------------------------------------------

    void State_PostAttack_Retreat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PostAttack_Retreat ------",false,true);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Run);
		
		mpMover.TurnToPos(mBaseObj.GetPlayerPos());
		mpStateMachine.AddTimer("StartRetreat", 0.0f);
	}
	
	//------------------------------------------------------------
	
	void State_PostAttack_Retreat_Leave()
	{
	}
	
	//------------------------------------------------------------
	
	void State_PostAttack_Retreat_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------
	
	bool State_PostAttack_Retreat_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
			return true;
		}
		return true;
	}
	
	//------------------------------------------------------------
	
	void State_PostAttack_Retreat_TimerUp(uint64 alId)
	{
		if (alId == H64("StartRetreat"))
		{
			cLux_AddTodoMessage("TODO-SOUND: scream");
			mBaseObj.PlaySound("Scream", gsGhoulSound_Scream, true, true);
			
			PlayRandomAnimation(mvGhoulAnim_Scream, 0.0f, false, false, "");
			
			mpStateMachine.AddTimer("Retreat", 1.2f);	
		}
		
		if (alId == H64("Retreat"))
		{
//			@mpPostAttack_Retreat_Spawn = GetRandomSpawn(null, false, false, "", true, false);
			mpPathfinder.MoveTo(mpPostAttack_Retreat_Spawn.GetPosition(), 0.2f, true);
		}
	}

	//------------------------------------------------------------
	
	//} END POST ATTACK RETREAT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: PROXIMITY EVENT: TALK
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_ProximityEvent_Talk_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ProximityEvent_Talk ------",false,true);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		mpMover.SetDynamicObjectAvoidanceActive(false);
		mbCollisionCourseDetection = false;
		
		mBaseObj.SetFOVMul(0.5f);
		mBaseObj.SetSightRangeMul(mfSightMul * 0.5f);
		
		mpStateMachine.AddTimer("MeetUp", 0.0f);
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Talk_Leave()
	{
		mpMover.SetDynamicObjectAvoidanceActive(true);
		mBaseObj.SetFOVMul(1.0f);
		mBaseObj.SetSightRangeMul(mfSightMul);
		mfTimeSinceLastEvent = 0.0f;
		mbCollisionCourseDetection = true;
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Talk_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_ProximityEvent_Talk_Message(int alMessageId)
	{
		return false;
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Talk_TimerUp(uint64 alId)
	{
		if (alId == H64("MeetUp"))
		{
			if (TryToMeetUp(m_idProximityEventOtherAgent, "AfterMeetUp")) return;
			mpStateMachine.AddTimer("MeetUp", 0.2f);
		}
		
		if (alId == H64("AfterMeetUp"))
		{
			mpMover.TurnToPos(cLux_ID_Agent(m_idProximityEventOtherAgent).GetPosition());
			if (mbProximityEventFirstAgent)
			{
				mpStateMachine.AddTimer("ConversationStart", cMath_RandRectf(0.4f, 0.6f));
			}
			else
			{
				mpStateMachine.AddTimer("ConversationReply", cMath_RandRectf(2.2f, 3.0f));
			}
			mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(4.5f, 6.5f));
		}
		
		if (alId == H64("ConversationStart"))
		{
			cLux_AddTodoMessage("TODO-SOUND: conversation start");
			mBaseObj.PlaySound("ConversationStart", gsGhoulSound_ConversationStart, true, true);
			
			cLux_AddTodoMessage("TODO-ANIM: speak variation 1");
			mpMover.PlayAnimation(gsGhoulAnim_SpeakVariation1, 0.0f, false, false, "");
		}
		
		if (alId == H64("ConversationReply"))
		{
			cLux_AddTodoMessage("TODO-SOUND: speak variation 2");
			mBaseObj.PlaySound("ConversationReply", gsGhoulSound_ConversationReply, true, true);
			
			cLux_AddTodoMessage("TODO-ANIM: look around");
			mpMover.PlayAnimation(gsGhoulAnim_SpeakVariation2, 0.0f, false, false, "");
		}
		
		if (alId == H64("ToIdle"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}

	//------------------------------------------------------------

	//} END PROXIMITY EVENT: TALK

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: PROXIMITY EVENT: FIGHT
	//{////////////////////////////////
	
	bool mbProximityEvent_Fight_BeHit = false;
	bool mbProximityEvent_Fight_RunAway = false;
	
	//------------------------------------------------------------

	void State_ProximityEvent_Fight_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ProximityEvent_Fight ------",false,true);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		mpMover.SetDynamicObjectAvoidanceActive(false);
		
		mBaseObj.SetFOVMul(0.5f);
		mBaseObj.SetSightRangeMul(mfSightMul * 0.5f);
		
		mbProximityEvent_Fight_BeHit = false;
		mbProximityEvent_Fight_RunAway = false;
		
		mpStateMachine.AddTimer("MeetUp", 0.0f);
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Fight_Leave()
	{
		mpMover.SetDynamicObjectAvoidanceActive(true);
		mBaseObj.SetFOVMul(1.0f);
		mBaseObj.SetSightRangeMul(mfSightMul);
		mfTimeSinceLastEvent = 0.0f;
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Fight_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_ProximityEvent_Fight_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mbProximityEvent_Fight_RunAway)
			{
				mbProximityEvent_Fight_RunAway = false;
				mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(0.5f, 1.5f));
				return true;
			}
		}
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (mbProximityEvent_Fight_BeHit)
			{
				mbProximityEvent_Fight_BeHit = false;
				mpStateMachine.AddTimer("RunAway", 0.2f);
			}
			return true;
		}
		return false;
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Fight_TimerUp(uint64 alId)
	{
		if (alId == H64("MeetUp"))
		{
			if (TryToMeetUp(m_idProximityEventOtherAgent, "AfterMeetUp")) return;
			mpStateMachine.AddTimer("MeetUp", 0.2f);
		}
		
		if (alId == H64("AfterMeetUp"))
		{
			mpMover.TurnToPos(cLux_ID_Agent(m_idProximityEventOtherAgent).GetPosition());
			
			if (mbProximityEventFirstAgent)
			{
				mpStateMachine.AddTimer("Attack", 1.6f);
				mpStateMachine.AddTimer("Celebrate", cMath_RandRectf(4.5f, 5.5f));
				mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(6.5f, 8.0f));
			}
			else
			{
				mpStateMachine.AddTimer("ConversationStart", 0.5f);
				mpStateMachine.AddTimer("BeHit", 2.0f);
			}
		}
		
		if (alId == H64("Attack"))
		{
			mBaseObj.PlaySound("Attack", gsGhoulSound_Attack, true, true);			
			mpMover.PlayAnimation(gsGhoulAnim_AttackClose2, 0.0f, false, false, "");
		}
		
		if (alId == H64("Celebrate"))
		{
			mpMover.TurnToPos(cLux_ID_Agent(m_idProximityEventOtherAgent).GetPosition());
			
			mBaseObj.PlaySound("AngryShout", gsGhoulSound_AngryShout, true, true);
			
			cLux_AddTodoMessage("TODO-ANIM: celebrate");
			mpMover.PlayAnimation(gsGhoulAnim_Celebrate, 0.0f, false, false, "");
		}
		
		if (alId == H64("ConversationStart"))
		{
			cLux_AddTodoMessage("TODO-SOUND: conversation start");
			mBaseObj.PlaySound("ConversationStart", gsGhoulSound_ConversationStart, true, true);
			
			cLux_AddTodoMessage("TODO-ANIM: speak variation 1");
			mpMover.PlayAnimation(gsGhoulAnim_SpeakVariation1, 0.0f, false, false, "");
		}
		
		if (alId == H64("BeHit"))
		{
			mbProximityEvent_Fight_BeHit = true;
			
			cLux_AddTodoMessage("TODO-SOUND: hit");
			mBaseObj.PlaySound("Hit", gsGhoulSound_BeHit, true, true);
			
			cLux_AddTodoMessage("TODO-ANIM: hit");
			mpMover.PlayAnimation(gsGhoulAnim_BeHit, 0.0f, false, false);
		}
		
		if (alId == H64("RunAway"))
		{
			mbProximityEvent_Fight_RunAway = true;
			
			cVector3f vAwayDir = mBaseObj.GetPosition() - cLux_ID_Agent(m_idProximityEventOtherAgent).GetPosition();
			vAwayDir.y = 0;
			vAwayDir.Normalize();
			
			/////////////////////
			// Don't go in the direction of the player
			if (mBaseObj.GetDistanceToPlayer() < 25.0f)
			{
				cVector3f vPlayerDir = mBaseObj.GetPlayerDir();
				vPlayerDir.y = 0;
				vPlayerDir.Normalize();

				float fAngle = cMath_ToDeg(cMath_Vector3Angle(vPlayerDir, vAwayDir));
				if (fAngle < 90.0f)
				{
					float fAngleDiff = 90.0f - fAngle;
					vAwayDir = cMath_MatrixMul(cMath_MatrixRotateY(cMath_Vector3Cross(vAwayDir, mBaseObj.GetPlayerDir()).y < 0 ? fAngleDiff : -fAngleDiff), vAwayDir);
				}
			}
			
			mpMover.TurnInstantlyToPos(mBaseObj.GetPosition() + vAwayDir);
			
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + vAwayDir * 15.0f, 0.0f, 10.0f, false, false, false, null);
			if (pNode is null)
			{
				@pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition(), 10.0f, 20.0f, false, false, false, null);
			}
			mpPathfinder.MoveTo(pNode.GetPosition(), 0.2f, false);
			mpMover.SetSpeedState(eGhoulSpeed_Run);
		}
		
		if (alId == H64("ToIdle"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}

	//------------------------------------------------------------

	//} END PROXIMITY EVENT: FIGHT
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: PROXIMITY EVENT: FOLLOW
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbProximityEvent_Follow_MovingAway = false;
	bool mbProximityEvent_Follow_MeetMidway = true;
	cVector3f mvProximityEvent_Follow_MeetPos;
	bool mbProximityEvent_Follow_MoveToSpecificPos = false;
	cVector3f mvProximityEvent_Follow_MoveToPos;
	bool mbProximityEvent_Follow_Met = false;

	//------------------------------------------------------------

	void State_ProximityEvent_Follow_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ProximityEvent_Follow ------",false,true);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		mpMover.SetDynamicObjectAvoidanceActive(false);
		mbCollisionCourseDetection = false;
		
		mbProximityEvent_Follow_MovingAway = false;
		mbProximityEvent_Follow_Met = false;
		
		if (mbProximityEventFirstAgent == false)
		{
			mBaseObj.SetFOVMul(0.5f);
			mBaseObj.SetSightRangeMul(mfSightMul * 0.5f);
		}
		
		mpStateMachine.AddTimer("MeetUp", 0.0f);
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Follow_Leave()
	{
		mpMover.SetDynamicObjectAvoidanceActive(true);
		mBaseObj.SetFOVMul(1.0f);
		mBaseObj.SetSightRangeMul(mfSightMul);
		mfTimeSinceLastEvent = 0.0f;
		mbCollisionCourseDetection = true;
		mbProximityEvent_Follow_MeetMidway = true;
		mbProximityEvent_Follow_MoveToSpecificPos = false;
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Follow_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_ProximityEvent_Follow_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{	
			if (mbProximityEvent_Follow_Met == false && mbProximityEvent_Follow_MeetMidway == false)
			{
				mbProximityEvent_Follow_Met = true;
				if (mbProximityEventFirstAgent == false) return true;
				cScript_RunGlobalFunc(cLux_ID_Agent(m_idProximityEventOtherAgent).GetName(), "", "_Global_StartFollow");
				mpStateMachine.AddTimer("AfterMeetUp", 0.2f);
				return true;
			}
			if (mbProximityEvent_Follow_MovingAway)
			{
				mbProximityEvent_Follow_MovingAway = false;
				mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(0.5f, 1.5f));
				return true;
			}
		}
		return false;
	}

	//------------------------------------------------------------

	void State_ProximityEvent_Follow_TimerUp(uint64 alId)
	{
		if (alId == H64("MeetUp"))
		{
			if (mbProximityEvent_Follow_MeetMidway == false)
			{
				if (mbProximityEvent_Follow_Met) return;
				
				cVector3f vMeetDir = mvProximityEvent_Follow_MeetPos - mBaseObj.GetPosition();
				vMeetDir.Normalize();
				mpPathfinder.MoveTo(mvProximityEvent_Follow_MeetPos - vMeetDir * 1.0f, 1.0f, false);
				mpStateMachine.AddTimer("MeetUp", 0.2f);
			}
			else
			{
				if (TryToMeetUp(m_idProximityEventOtherAgent, "AfterMeetUp")) return;
				mpStateMachine.AddTimer("MeetUp", 0.2f);
			}

		}
		
		if (alId == H64("AfterMeetUp"))
		{
			mpMover.TurnToPos(cLux_ID_Agent(m_idProximityEventOtherAgent).GetPosition());
			
			if (mbProximityEventFirstAgent)
			{
				mpStateMachine.AddTimer("RequestFollow", 0.5f);
				mpStateMachine.AddTimer("MoveAway", cMath_RandRectf(3.0f, 5.0f));
			}
			else
			{
				mpStateMachine.AddTimer("AcceptFollow", 2.0f);
				mpStateMachine.AddTimer("Follow", cMath_RandRectf(6.0f, 8.0f));
				mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(40.0f, 50.0f));
			}
		}
		
		if (alId == H64("RequestFollow"))
		{
			cLux_AddTodoMessage("TODO-SOUND: request help");
			mBaseObj.PlaySound("RequestHelp", gsGhoulSound_RequestHelp, true, true);
			
			cLux_AddTodoMessage("TODO-ANIM: speak variation 1");
			mpMover.PlayAnimation(gsGhoulAnim_SpeakVariation1, 0.0f, false, false, "");
		}
		
		if (alId == H64("AcceptFollow"))
		{
			cLux_AddTodoMessage("TODO-SOUND: agree");
			mBaseObj.PlaySound("RequestHelp", gsGhoulSound_Agree, true, true);
			
			cLux_AddTodoMessage("TODO-ANIM: agree");
			mpMover.PlayAnimation(gsGhoulAnim_Agree, 0.0f, false, false, "");
		}
		
		if (alId == H64("MoveAway"))
		{
			mbProximityEvent_Follow_MovingAway = true;
			mpMover.SetDynamicObjectAvoidanceActive(true);
			
			cVector3f vMoveToPos;
            if (mbProximityEvent_Follow_MoveToSpecificPos == false)
			{
				cVector3f vOtherAgentPos = cLux_ID_Agent(m_idProximityEventOtherAgent).GetPosition();
				cAINode@ pNode = mpPathfinder.GetNodeInCircularSectorAroundPos(mBaseObj.GetPosition(), 15.0f, 20.0f, vOtherAgentPos - mBaseObj.GetPosition(), 90.0f, false, false, false, null);
				vMoveToPos = pNode.GetPosition();
			}
			else
			{
				vMoveToPos = mvProximityEvent_Follow_MoveToPos;
			}
			mpPathfinder.MoveTo(vMoveToPos, 1.0f, false);
		}
		
		if (alId == H64("Follow"))
		{
			cVector3f vOtherAgentPos = cLux_ID_Agent(m_idProximityEventOtherAgent).GetPosition();
			if (mBaseObj.GetDistanceToPos(vOtherAgentPos) >= 2.0f)
			{
				cVector3f vOtherAgentDir = vOtherAgentPos - mBaseObj.GetPosition();
				vOtherAgentDir.Normalize();
				mpPathfinder.MoveTo(vOtherAgentPos - vOtherAgentDir * 1.0f, 0.2f, false);
			}
			mpStateMachine.AddTimer("Follow", 0.5f);
		}
		
		if (alId == H64("ToIdle"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}
	
	//------------------------------------------------------------
	
	void _Global_StartFollow()
	{
		mpStateMachine.AddTimer("AfterMeetUp", 0.2f);
	}

	//------------------------------------------------------------

	//} END PROXIMITY EVENT: FOLLOW
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: ENVIRONMENT EVENT: SNIFF
	//{////////////////////////////////

	//------------------------------------------------------------

	void State_EnvironmentEvent_SimpleAnimation_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: EnvironmentEvent_SimpleAnimation ------",false,true);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		mbCollisionCourseDetection = false;
		
		mBaseObj.SetFOVMul(0.5f);
		mBaseObj.SetSightRangeMul(mfSightMul * 0.5f);
		
		iLuxEntity@ pEnt = cLux_ID_Entity(m_idEnvironmentEventEntity);
		cVector3f vDir = pEnt.GetMatrix().GetForward();
		vDir.x = -vDir.x;
		cVector3f vGoalPos = cLux_ID_Entity(m_idEnvironmentEventEntity).GetPosition();
		mpPathfinder.MoveTo(vGoalPos - vDir * 1.0f, 0.2f, true);
	}

	//------------------------------------------------------------

	void State_EnvironmentEvent_SimpleAnimation_Leave()
	{
		mBaseObj.SetFOVMul(1.0f);
		mBaseObj.SetSightRangeMul(mfSightMul);
		mfTimeSinceLastEvent = 0.0f;
		mbCollisionCourseDetection = true;
	}

	//------------------------------------------------------------

	void State_EnvironmentEvent_SimpleAnimation_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_EnvironmentEvent_SimpleAnimation_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			iLuxEntity@ pEnt = cLux_ID_Entity(m_idEnvironmentEventEntity);
			mpMover.TurnToPos(pEnt.GetPosition());
			mpStateMachine.AddTimer("Animation", cMath_RandRectf(1.0f, 2.0f));
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (mlEnvironmentEventType == eAgentEnvironmentEvent_GhoulSearchGround)
			{
				mpStateMachine.AddTimer("ToSniff", cMath_RandRectf(0.2f, 0.5f));
			}
			else if (mlEnvironmentEventType == eAgentEnvironmentEvent_GhoulEat)
			{
				mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(5.0f, 6.0f));
			}
			else
			{
				mpStateMachine.AddTimer("ToIdle", cMath_RandRectf(0.2f, 0.5f));
			}
			
			return true;
		}
		
		return false;
	}

	//------------------------------------------------------------

	void State_EnvironmentEvent_SimpleAnimation_TimerUp(uint64 alId)
	{
		if (alId == H64("Animation"))
		{
			tString sSound = gsGhoulSound_AngryShout;
			tString sAnim = "";
			if (gvGhoulAnim_AngryGesture.size() != 0)
			{
				sAnim = gvGhoulAnim_AngryGesture[cMath_RandRectl(0, gvGhoulAnim_AngryGesture.size() - 1)];
			}
			switch (mlEnvironmentEventType)
			{
				case eAgentEnvironmentEvent_GhoulSearchGround:
				sSound = gsGhoulSound_SearchGround;
				sAnim = gsGhoulAnim_SearchGround;
				break;
				
				case eAgentEnvironmentEvent_GhoulInteractWithFetish:
				sSound = gsGhoulSound_InteractWithFetish;
				sAnim = gsGhoulAnim_InteractWithFetish;
				break;
				
				case eAgentEnvironmentEvent_GhoulEat:
				sSound = gsGhoulSound_EatQuick;
				sAnim = gsGhoulAnim_EatQuick;
				break;
			}
			mBaseObj.PlaySound("EnvSound", sSound, true, true);
			mpMover.PlayAnimation(sAnim, 0.0f, false, true, "");
		}
		
		if (alId == H64("ToSniff"))
		{
			mpStateMachine.ChangeState(eGhoulState_TrackSmell);
		}
		
		if (alId == H64("ToIdle"))
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}

	//------------------------------------------------------------

	//} END ENVIRONMENT EVENT: SNIFF
	
	//------------------------------------------------------------

	/////////////////////
	// ATTACK HELPERS  //
	//{//////////////////
	
	//------------------------------------------------------------
	
	//////////////////////////////
	// These function lives here at the top of our attacks rather than in hunt or with other helper functions
	// as from this point on most of our script is attack states
	int DetermineDesiredAttackState(bool abAllowThrow = true)
	{
		int lWishAttackState = -1;
		if (mbCanAttack == false) return lWishAttackState;
		if (FearHandler_GetIsPermaFailing()) return -1;
		
		float fDistance = cMath_Vector3Dist(cLux_GetPlayer().GetCharacterBody().GetPosition(), mBaseObj.GetPosition());
		float fPlayerSpeed = cLux_GetPlayer().GetAverageMoveSpeed();
		
		if (mbPlayerIsInLos && mbAllowPlayerThrow && abAllowThrow)
		{
			////////////////////////
			// Struggle
			if (FearHandler_GetLevel() >= (1.0f - mfThrowPlayer_Damage) || mbAttack_InstantKill)
			{
				if (fDistance > 2.f) return -1;
				lWishAttackState = eGhoulState_Struggle;
				return lWishAttackState;
			}
			
			////////////////////////
			// Throw player
			else if (abAllowThrow)
			{
				if (fDistance > 2.f) return -1;			
				lWishAttackState = eGhoulState_ThrowPlayer;
			}
		}
		////////////////////////
		// Queue swipe attack when player is close
		else if (fDistance < 2.25f && fPlayerSpeed > 0.5f || fDistance < 3.2f && fPlayerSpeed <= 0.5f)
		{
			lWishAttackState = eGhoulState_AttackClose;
		}
		////////////////////////
		// Lunge at the player if there is a large distance and the player is moving slowly
		else if (fDistance < 4.2f && mBaseObj.CheckIsOnScreen(true))
		{
			lWishAttackState = eGhoulState_AttackLunge;
		}

		/////////////////////////////
		// Ensure player is in front before launching in to an attack
		if (mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerFeetPos()) && mbPlayerIsInLos && lWishAttackState > -1)
			mpStateMachine.ChangeState(lWishAttackState);
		else if (lWishAttackState > -1)
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
		
		return lWishAttackState;
	}

	//------------------------------------------------------------

	void StartupAttack()
	{
		mlAttackAnimPhase = eGhoulAttackFrames_Startup;
	}

	//------------------------------------------------------------

	void ProcessAttackAnimationEvent(int alShape)
	{
		mlAttackAnimPhase++;
		if (mlAttackAnimPhase == eGhoulAttackFrames_Active)
		{
			mpAttackDamage.Start(alShape, 2.0f);
			
			if (cLux_GetGodModeActivated() == false && mbAttackClose_PushBlockage == false && (mbAttack_InstantKill == true || mbHunt_SuperHunt == true))
			{
				Player_GiveDamage(1.f, 0.9f, eDamageType_Silent, mBaseObj.GetName());
			}
            cLux_AddDebugMessage("Lunge attack Message function here, animation state 3");
            mBaseObj.PlaySound("AttackHitSound", gsGhoulSound_AttackHitPlayer, true, true);
		}
		else if (mlAttackAnimPhase == eGhoulAttackFrames_Recovery)
		{
			mpAttackDamage.Stop(alShape);
			//if (mbAllowPlayerThrow == false && FearHandler_GetLevel() >= 1) FearHandler_TriggerPermaFail(false, mBaseObj.GetName());
			ExecutePostAttackCallback();
		}
		else if (mlAttackAnimPhase == eGhoulAttackFrames_BecomeFree)
		{
			mlAttackAnimPhase = eGhoulAttackFrames_Idle;
		}
	}
	
	//------------------------------------------------------------
	
	void ExecutePostAttackCallback()
	{
		if (msPostAttackCallback == "") return;
		
		tString sMethodName = "void " + msPostAttackCallback + "()";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.ScriptExecute();
		}
	}

	//------------------------------------------------------------

	//} END ATTACK HELPERS

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: ATTACK (LUNGE)
	//{////////////////////////////////

	//------------------------------------------------------------

	bool mbLungeAttackStarted = false;
	int mlLunge_AnimState = 0;

	//------------------------------------------------------------

	tString GetRandomLungeAttack()
	{
		return msAttackLungeAnimName + "_" + cMath_RandRectl(1, mlNumAttackLungeAnims);
	}

	//------------------------------------------------------------

	void State_AttackLunge_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: AttackLunge ------",false,true);
		
		EnterHuntState();
		
		////////////////////////
		// 1 play animation
		// 2 start the attack for the duration
		// 3 set timer to go back to either hunt or another swipe?
		// 4 during update, move agent towards player
		
		mpProximitySensor.ResetAllStates();
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Lunge);
		mpMover.SetDynamicObjectAvoidanceActive(false);
		mpMover.SetIdleAnimName(gsGhoulAnim_Move_IdleAggressive);
		
		mbLungeAttackStarted = false;
		mlLunge_AnimState = 0;
		
		mBaseObj.PlaySound("AttackSound", gsGhoulSound_Attack, true, true);
		
		tString sAnim = GetRandomLungeAttack();
//		cLux_AddDebugMessage("LUNGE ANIM " + sAnim);
		mpMover.PlayAnimation(sAnim, 0.1f, false, false,"");
		
		mpStateMachine.AddTimer("Exit", 2.2);
	}

	//------------------------------------------------------------

	void State_AttackLunge_Leave()
	{
		mpMover.SetIdleAnimName(msIdleAnim);
		LeaveHuntState();
		
		if (mpStateMachine.GetPrevState() == eGhoulState_Hunt && mpStateMachine.GetNextState() != eGhoulState_Hunt)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
		mpMover.SetDynamicObjectAvoidanceActive(true);
		
		mpAttackDamage.Stop(3);
		mpAttackDamage.Stop(3);
	}

	//------------------------------------------------------------

	void State_AttackLunge_Update(float afTimeStep)
	{
		if (mlLunge_AnimState == 0 || mlLunge_AnimState == 1 || mlLunge_AnimState == 3)
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
			mpMover.MoveToPos(mBaseObj.GetPlayerFeetPos(), false);
		}
		else
		{
			mBaseObj.GetCharBody().SetMoveSpeed(eCharDir_Forward, 0);
		}
	}

	bool State_AttackLunge_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_PlayerDead) return false;
		if (alMessageId == eLuxEntityMessage_EnterProximity) return true;
		if (alMessageId == eLuxEntityMessage_LeaveProximity) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_PlayerDetected) return true;
		if (alMessageId == eLuxEntityMessage_PlayerUndetected) return true;
		if (alMessageId == eCustomEntityMessage_AttractAgent) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			++mlLunge_AnimState;
			if (mlLunge_AnimState == 1)
			{
				mpAttackDamage.Start(3, 2.0f);
				mpAttackDamage.SetDamage(3, 0.4, 0.4, true); // TODO: might want a better solution
				
				if (cLux_GetGodModeActivated() == false && (mbAttack_InstantKill == true || mbHunt_SuperHunt == true))
				{
					Player_GiveDamage(1.f, 0.9f, eDamageType_Silent, mBaseObj.GetName());
				}
                cLux_AddDebugMessage("Lunge attack Message function here, animation state 1");
                mBaseObj.PlaySound("AttackHitSound", gsGhoulSound_AttackHitPlayer, true, true);
			}
			else if (mlLunge_AnimState == 2)
			{
				mpAttackDamage.Stop(1);
			}
			else if (mlLunge_AnimState == 3)
			{
				mpAttackDamage.Start(4, 2.0f);
				mpAttackDamage.SetDamage(4, 0.0, 0.0, true); // TODO: might want a better solution
				
				if (cLux_GetGodModeActivated() == false && (mbAttack_InstantKill == true || mbHunt_SuperHunt == true))
				{
					Player_GiveDamage(1.f, 0.9f, eDamageType_Silent, mBaseObj.GetName());
				}
                cLux_AddDebugMessage("Lunge attack Message function here, animation state 3");
                mBaseObj.PlaySound("AttackHitSound", gsGhoulSound_AttackHitPlayer, true, true);
			}
			else if (mlLunge_AnimState == 4)
			{
				mpAttackDamage.Stop(2);
				//if (mbAllowPlayerThrow == false && FearHandler_GetLevel() >= 1) FearHandler_TriggerPermaFail(false, mBaseObj.GetName());
				ExecutePostAttackCallback();
			}
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			mpStateMachine.ChangeState(eGhoulState_PostAttack);
			return true;
		}
		
		return true;
	}

	void State_AttackLunge_TimerUp(uint64 alId)
	{
		if (alId == H64("Exit"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Backup exit, shouldn't happen");
			mpStateMachine.ChangeState(eGhoulState_PostAttack);
		}
	}

	//------------------------------------------------------------

	//} END ATTACK LUNGE

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: ATTACK (CLOSE)
	//{////////////////////////////////

	//------------------------------------------------------------

	tString msCloseAttackAnimName = "";
	bool mbAttackClose_PushBlockage = false;

	//------------------------------------------------------------

	tString GetRandomCloseAttack()
	{
		return msAttackAnimName + "_" + cMath_RandRectl(1,mlNumAttackAnims);
	}

	//------------------------------------------------------------

	bool GetPlayerOnRight()
	{
		cVector3f vTgt = mBaseObj.GetPlayerFeetPos();
		cVector3f vSrc = mBaseObj.GetCharBody().GetFeetPosition();
		cVector3f vTgtDir = cMath_Vector3Normalize(vTgt - vSrc);
		float fDot = cMath_Vector3Dot(vTgtDir, mBaseObj.GetCharBody().GetRight());	// get dot product of dir . agent right
		return fDot > 0.0f;	// positive should be right, negative should be left
	}

	//------------------------------------------------------------

	void State_AttackClose_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: AttackClose ------",false,true);
		
		EnterHuntState();
		
		mpProximitySensor.ResetAllStates();
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_TurnDuringAttack);
		mpMover.SetDynamicObjectAvoidanceActive(false);
		
		mpMover.SetIdleAnimName(gsGhoulAnim_Move_IdleAggressive);

		msCloseAttackAnimName = GetPlayerOnRight() ? "attack_close_2" : "attack_close_1";
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Attack: " + msCloseAttackAnimName);
		
		StartupAttack();
		
		mpStateMachine.AddTimer("Attack", 0.2);
		mpStateMachine.AddTimer("Exit", 2.0);
		
//		float fAttackTime = Blackboard_GetHuntingAgentCount() <= 0 ? 1.9f : cMath_RandRectf(1.9f, 2.5f);
//		mpStateMachine.AddTimer("EndAttack", fAttackTime);
	}

	//------------------------------------------------------------

	void State_AttackClose_Leave()
	{
		LeaveHuntState();
		mbAttackClose_PushBlockage = false;
				
		mpMover.SetIdleAnimName(msIdleAnim);
		
		if (msCloseAttackAnimName == "attack_close_1")
		{
			mpAttackDamage.Stop(1);
		}
		else if (msCloseAttackAnimName == "attack_close_2")
		{
			mpAttackDamage.Stop(2);
		}
		
		if (mpStateMachine.GetPrevState() == eGhoulState_Hunt && mpStateMachine.GetNextState() != eGhoulState_Hunt)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
		mpMover.SetDynamicObjectAvoidanceActive(true);
	}

	//------------------------------------------------------------

	void State_AttackClose_Update(float afTimeStep)
	{
		if (mlAttackAnimPhase >= eGhoulAttackFrames_Startup)
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
			mpMover.MoveToPos(mBaseObj.GetPlayerFeetPos(), false);
		}
	}
	
	//------------------------------------------------------------

	bool State_AttackClose_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_PlayerDead) return false;
		if (alMessageId == eLuxEntityMessage_EnterProximity) return true;
		if (alMessageId == eLuxEntityMessage_LeaveProximity) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		if (alMessageId == eLuxEntityMessage_PlayerDetected) return true;
		if (alMessageId == eLuxEntityMessage_PlayerUndetected) return true;
		if (alMessageId == eCustomEntityMessage_AttractAgent) return true;
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		
		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			if (msCloseAttackAnimName == "attack_close_1")
			{
				ProcessAttackAnimationEvent(1);

			}
			else if (msCloseAttackAnimName == "attack_close_2")
			{
				ProcessAttackAnimationEvent(2);
			}
			
			if (mbAttackClose_PushBlockage && mlAttackAnimPhase == eGhoulAttackFrames_Active)
			{
				mpStateMachine.AddTimer("PushBlockage", 0);
			}

			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (mbAttackClose_PushBlockage) mpStateMachine.ChangeState(mlBlocked_PrevState);
			else mpStateMachine.ChangeState(eGhoulState_PostAttack);
			return true;
		}

		return true;
	}
	
	//------------------------------------------------------------

	void State_AttackClose_TimerUp(uint64 alId)
	{
		if (alId == H64("Attack"))
		{
			mBaseObj.PlaySound("AttackSound", gsGhoulSound_Attack, true, true);
			mpMover.PlayAnimation(msCloseAttackAnimName, 0.1f, false, false, "");
		}
		
		else if (alId == H64("Exit"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Backup exit, shouldn't happen");
			if (mbAttackClose_PushBlockage) mpStateMachine.ChangeState(mlBlocked_PrevState);
			else mpStateMachine.ChangeState(eGhoulState_PostAttack);
		}
		
		else if (alId == H64("PushBlockage"))
		{
			cVector3f vPushPos = mBaseObj.GetCharBody().GetFeetPosition() + mBaseObj.GetCharBody().GetForward() * 0.5f;
			float fRadius = 2.0f;
			float fImpulse = 0.5;
			cVector3f vPushMin = vPushPos - cVector3f_One * fRadius;
			cVector3f vPushMax = vPushPos + cVector3f_One * fRadius;
			
			Debug_DrawSphere(vPushPos, fRadius, cColor_Red, 4);
			Debug_DrawSphere(vPushPos, 0.2, cColor_Red, 4);
			
			array<iPhysicsBody@> vBodies;
			cLux_GetCurrentMap().GetPhysicsWorld().GetBodiesInAABB(vPushMin, vPushMax, vBodies);
			
			for (int i = 0; i < vBodies.size(); ++i)
			{
				iPhysicsBody@ pBody = vBodies[i];
				if (pBody is null) continue;
				iLuxEntity@ pEnt = cLux_GetBodyEntity(pBody);
				if (pEnt is null) continue;
				if (pBody.GetMass() == 0) continue;
				cVector3f vToBody = pBody.GetWorldPosition() - vPushPos;
				if (vToBody.Length() > fRadius) continue;
				
				cVector3f vForceDir = cMath_Vector3Normalize(vToBody) + cVector3f_Up * 3;
				vForceDir.Normalize();
				float fFinalImpulse = fImpulse * cMath_Max(pBody.GetMass(), 0.5);
				
				pBody.AddImpulse(vForceDir * fFinalImpulse);
				pBody.SetCollideFlags(mBaseObj.GetMap().GetCollideFlag("-agent"));
				
				Debug_DrawLine(vPushPos, vPushPos + vForceDir * 5, cColor_Red, 4);
			}
		}
	}

	//------------------------------------------------------------

	//} END ATTACK CLOSE
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: THROW PLAYER
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfThrow_AnimDist = 1.4f;
	
	//------------------------------------------------------------
	
	bool mbThrowPlayer_Success = false;
	float mfThrowPlayer_PlayerPosTarY = 0.f;
	float mfThrow_GhoulGoalYaw = 0.f;
	cVector3f mvThrow_GhoulStartPos = 0.f;
	cVector3f mvThrow_GhoulGoalPos = 0.f;
	tString msThrowPlayer_ThrowAnim = "";
	tString msThrowPlayer_PlayerThrownAnim = "";
	int mlThrowPlayer_ForcedDirection = -1;
	bool mbThrowPlayer_Cancel = false;
	bool mbThrowPlayer_AnimationOverCallbackAutoRemove = false;
	tString msThrowPlayer_AnimationOverCallback = "";
	tString msThrowPlayer_AnimState = "";
	float mfThrowPlayer_Damage = 0.35f;

	//------------------------------------------------------------
	
	array<cVector3f> mvThrow_Dirs;
	array<cGhoulThrowCandidate> mvThrow_Candidates;
	cVector3f mvThrow_RaycastStart;
	int mlThrow_RaycastIndex = 0;
	int mlThrow_RaycastMaxIndex = 0;
	cVector3f mvThrow_PlayerDir;
	cVector3f mvThrow_PlayerGoalPos;
	cVector3f mvThrow_PlayerAfterThrowPos;
	
	void Throw_StartRaycasts()
	{
//		cLux_AddDebugMessage("START");
		mvThrow_PlayerDir = mBaseObj.GetPlayerDir();
		mvThrow_PlayerDir.y = 0;
		mvThrow_PlayerDir.Normalize();
		
		mvThrow_GhoulGoalPos = mBaseObj.GetCharBody().GetFeetPosition();
		mvThrow_PlayerGoalPos = mvThrow_GhoulGoalPos + mvThrow_PlayerDir * mfThrow_AnimDist;
		mvThrow_RaycastStart = mvThrow_PlayerGoalPos;
		mvThrow_RaycastStart.y += mBaseObj.GetCharBody().GetSize().y * 0.75f;
		
		mvThrow_Candidates.resize(0);
		mvThrow_Dirs.resize(0);
		
		if (mbThrowPlayer_Cancel) 
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Throw cancelled");
			Throw_EndRaycasts(false);
			return;
		}
		
		///////////////////
		// Forced direction
		if (mlThrowPlayer_ForcedDirection != -1)
		{
			for (int i = 0; i < 8; i++)
			{
				cVector3f vDir = cMath_MatrixMul(cMath_MatrixRotateY(cMath_PiDiv4 * i), mvThrow_PlayerDir);
				mvThrow_Dirs.push_back(vDir);
				
				if (i != mlThrowPlayer_ForcedDirection) continue;
				
				mBaseObj.GetClosestBody("OnRaycast_ThrowDirs", mvThrow_RaycastStart, vDir, gfMaxThrowDistance, i);
			}
			
		}
		else
		{
			///////////////////
			// Find best throw dir
			for (int i = 0; i < 8; i++)
			{
//				cVector3f vDir = cMath_MatrixMul(cMath_MatrixRotateY(cMath_PiDiv4 * i), pBody.GetForward());
				cVector3f vDir = cMath_MatrixMul(cMath_MatrixRotateY(cMath_PiDiv4 * i), mvThrow_PlayerDir);
				mvThrow_Dirs.push_back(vDir);
				mBaseObj.GetClosestBody("OnRaycast_ThrowDirs", mvThrow_RaycastStart, vDir, gfMaxThrowDistance, i);
				
				Debug_DrawLine(mvThrow_RaycastStart, mvThrow_RaycastStart + vDir * gfMaxThrowDistance, cColor(1, 1, 0) * 2, 10);
			}
		}
	}
	
	void OnRaycast_ThrowDirs(bool abSuccesful, float afDistance, const cVector3f&in avNormal, iPhysicsBody@ apBody, int alUservalue)
	{
//		cLux_AddDebugMessage("DIR RAYCAST " + alUservalue + " " + abSuccesful);
		float fDist = gfMaxThrowDistance;
		if (abSuccesful) fDist = afDistance;
		if (fDist >= gfMinThrowDistance)
		{
			cGhoulThrowCandidate newCandidate;
			newCandidate.mlId = alUservalue;
			newCandidate.mfDist = fDist;
			mvThrow_Candidates.push_back(newCandidate);
//			cLux_AddDebugMessage("ADDING");
		}
		if (alUservalue == 7 || mlThrowPlayer_ForcedDirection >= 0) Throw_CheckLanding();
	}
	
	void Throw_CheckLanding()
	{		
		if (mvThrow_Candidates.size() == 0)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No candidates after checking direction");
			Throw_EndRaycasts(false);
			return;
		}
		
		mlThrow_RaycastMaxIndex = mvThrow_Candidates.size();
		for (int i = 0; i < mvThrow_Candidates.size(); ++i)
		{
			cGhoulThrowCandidate@ pCandidate = mvThrow_Candidates[i];
			float fCandidateDist = pCandidate.mfDist - 1.5f;
			pCandidate.mvDownRaycast = mvThrow_RaycastStart + mvThrow_Dirs[pCandidate.mlId] * fCandidateDist;
			mBaseObj.GetClosestBody("OnRaycast_ThrowLanding", pCandidate.mvDownRaycast, cVector3f_Down, 10, i);

//			cLux_AddDebugMessage("LANDING RAYCAST " + pCandidate.mlId);
		}
	}
	
	
	void OnRaycast_ThrowLanding(bool abSuccesful, float afDistance, const cVector3f&in avNormal, iPhysicsBody@ apBody, int alUservalue)
	{
		if (abSuccesful)
		{
			mvThrow_Candidates[alUservalue].mfDownDist = afDistance;
		}
		
		if (alUservalue == mlThrow_RaycastMaxIndex - 1)
		{
			Throw_StartEnoughSpaceCheck();
		}
	}
	
	int mlThrow_EnoughSpaceIndex = 0;
	int mlThrow_EnoughSpaceSuccessCount = 0;
	
	void Throw_StartEnoughSpaceCheck()
	{
		for (int i = 0; i < mvThrow_Candidates.size(); ++i)
		{
			cGhoulThrowCandidate@ pCandidate = mvThrow_Candidates[i];
			if (pCandidate.mfDownDist < 0)
			{
				mvThrow_Candidates.removeAt(0);
				--i;
			}
		}
		
		if (mvThrow_Candidates.size() == 0)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") No candidates after checking landing");
			Throw_EndRaycasts(false);
			return;
		}
		
//		cLux_AddDebugMessage("START ENOUGH SPACE " + mvThrow_Candidates.size());
		mvThrow_Candidates.sortDesc();
		mlThrow_EnoughSpaceIndex = 0;
		Throw_CheckEnoughSpaceDir();
	}
	
	void Throw_CheckEnoughSpaceDir()
	{
		mlThrow_EnoughSpaceSuccessCount = 0;
		
		cGhoulThrowCandidate@ pCandidate = mvThrow_Candidates[mlThrow_EnoughSpaceIndex];

		cVector3f vDir = mvThrow_Dirs[pCandidate.mlId];
		cVector3f vDirLeft = cMath_Vector3Cross(vDir, cVector3f_Up);
		
		cVector3f vStart1 = mvThrow_RaycastStart + cVector3f_Down * 0.5f + vDirLeft * 0.3f;
		mBaseObj.GetClosestBody("OnRaycast_ThrowEnoughSpace", vStart1, vDir, gfMaxThrowDistance, 0);
		
		cVector3f vStart2 = mvThrow_RaycastStart + cVector3f_Down * 0.5f - vDirLeft * 0.3f;
		mBaseObj.GetClosestBody("OnRaycast_ThrowEnoughSpace", vStart2, vDir, gfMaxThrowDistance, 1);
		
		Debug_DrawLine(mvThrow_RaycastStart, mvThrow_RaycastStart + vDir * gfMaxThrowDistance, cColor_Blue, 10);
		Debug_DrawLine(vStart1, vStart1 + vDir * gfMaxThrowDistance, cColor_Blue, 10);
		Debug_DrawLine(vStart2, vStart2 + vDir * gfMaxThrowDistance, cColor_Blue, 10);
		
		++mlThrow_EnoughSpaceIndex;		
	}
	
	
	void OnRaycast_ThrowEnoughSpace(bool abSuccesful, float afDistance, const cVector3f&in avNormal, iPhysicsBody@ apBody, int alUservalue)
	{
		if (mbThrowPlayer_Success) return;
		
		cGhoulThrowCandidate@ pCandidate = mvThrow_Candidates[mlThrow_EnoughSpaceIndex - 1];
		
//		cLux_AddDebugMessage("ENOUGH SPACE RAY " + pCandidate.mlId + " " + alUservalue + " " + abSuccesful + " " + mlThrow_EnoughSpaceSuccessCount);

		bool bHitCloseEnough = cMath_Abs(afDistance - pCandidate.mfDist) <= 1.0f;
		if (abSuccesful == false || (abSuccesful && bHitCloseEnough)) ++mlThrow_EnoughSpaceSuccessCount;
		
		if (alUservalue == 1)
		{
			if (mlThrow_EnoughSpaceSuccessCount == 2)
			{
				cVector3f vThrowTarget = pCandidate.mvDownRaycast;
				vThrowTarget += cVector3f_Down * pCandidate.mfDownDist;
//				vThrowTarget += cVector3f_Up * 0.5f;
				
				cGhoulThrowInfo throwInfo;
				throwInfo.mlId = pCandidate.mlId;
				throwInfo.mfDownDist = pCandidate.mfDownDist;
				throwInfo.mvEnd = mvThrow_RaycastStart;
				throwInfo.mvThrowTarget = vThrowTarget;
				Throw_Start(throwInfo);
				
			}
			else
			{
				if (mlThrow_EnoughSpaceIndex < mvThrow_Candidates.size())
				{
					Throw_CheckEnoughSpaceDir();
				}
				else
				{
					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Not enough space");
					Throw_EndRaycasts(false);
				}
			}
		}
	}
	
	void Throw_Start(cGhoulThrowInfo@ apThrowInfo)
	{
		iCharacterBody@ pBody = mBaseObj.GetCharBody();
				
		///////////////////
		// Animation positioning
		mfThrowPlayer_PlayerPosTarY = (apThrowInfo.mvEnd - cVector3f(0.f, apThrowInfo.mfDownDist, 0.f)).y;
		
		float fAgentYawTarAdd = 0.f;
		if (apThrowInfo.mlId == 1 || apThrowInfo.mlId == 3)
			fAgentYawTarAdd = cMath_PiDiv4;
		else if (apThrowInfo.mlId == 5 || apThrowInfo.mlId == 7)
			fAgentYawTarAdd = -cMath_PiDiv4; 
		
		mfThrow_GhoulStartYaw = cMath_GetAngleFromPoints3D(0.0f, mBaseObj.GetCharBody().GetForward()).y;
		mfThrow_GhoulGoalYaw = cMath_GetAngleFromPoints3D(0.0f, mvThrow_PlayerDir).y + fAgentYawTarAdd;
		mfThrow_GhoulGoalYaw = cMath_GetAngleDistanceRad(mfThrow_GhoulStartYaw, mfThrow_GhoulGoalYaw) + mfThrow_GhoulStartYaw;
		
		mvThrow_PlayerAfterThrowPos = apThrowInfo.mvThrowTarget;
		
		mvThrow_GhoulStartPos = mBaseObj.GetCharBody().GetFeetPosition();
		if (apThrowInfo.mlId == 1 || apThrowInfo.mlId == 7)
		{
			mvThrow_GhoulGoalPos = mvThrow_PlayerGoalPos - mvThrow_Dirs[apThrowInfo.mlId] * mfThrow_AnimDist;
		}
		else if (apThrowInfo.mlId == 3)
		{
			cVector3f vToPlayerDir = cMath_Vector3Cross(mvThrow_Dirs[3], cVector3f_Up);
			mvThrow_GhoulGoalPos = mvThrow_PlayerGoalPos - vToPlayerDir * mfThrow_AnimDist;
		}
		else if (apThrowInfo.mlId == 5)
		{
			cVector3f vToPlayerDir = cMath_Vector3Cross(cVector3f_Up, mvThrow_Dirs[5]);
			mvThrow_GhoulGoalPos = mvThrow_PlayerGoalPos - vToPlayerDir * mfThrow_AnimDist;
		}
		else if (apThrowInfo.mlId == 4)
		{
			mvThrow_GhoulGoalPos = mvThrow_PlayerGoalPos + mvThrow_Dirs[apThrowInfo.mlId] * 1.0f;
		}
		
//		cLux_AddDebugMessage("THROW ID " + apThrowInfo.mlId + " dist: " + cMath_Vector3Dist(mvThrow_PlayerAfterThrowPos, mvThrow_PlayerGoalPos));
		
		Debug_DrawSphere(apThrowInfo.mvThrowTarget, 0.25, cColor(0, 1, 1) * 2, 5);
		Debug_DrawSphere(mvThrow_GhoulGoalPos, 0.25, cColor(0, 1, 1) * 2, 5);
		Debug_DrawLine(mBaseObj.GetPosition(), mBaseObj.GetPosition() + mvThrow_Dirs[apThrowInfo.mlId] * 10, cColor(0, 1, 0) * 2, 5);
		
		float fAnimAngle = mfThrow_GhoulGoalYaw + cMath_Pi;
		
		///////////////////
		// Get suitable anims for the dir
		switch (apThrowInfo.mlId)
		{
			case 0:
			case 1:
			case 7:
				msThrowPlayer_ThrowAnim = "throw_player_forward";
				msThrowPlayer_PlayerThrownAnim = "thrown_forward_by_ghoul";
				break;
			case 2:
			case 3:
				msThrowPlayer_ThrowAnim = "throw_player_left";
				msThrowPlayer_PlayerThrownAnim = "thrown_left_by_ghoul";
				break;
			case 4:
				msThrowPlayer_ThrowAnim = "throw_player_back";
				msThrowPlayer_PlayerThrownAnim = "thrown_back_by_ghoul";
				break;
			case 5:
			case 6: 
				msThrowPlayer_ThrowAnim = "throw_player_right";
				msThrowPlayer_PlayerThrownAnim = "thrown_right_by_ghoul";
				break;
		}
		
		///////////////////
		// Play anims
		mbThrow_Align = true;
		mpMover.StopTurning();
		
		Debug_DrawLine(mBaseObj.GetCharBody().GetPosition(), mBaseObj.GetCharBody().GetPosition() + mvThrow_PlayerDir * 5, cColor_Green * 2, 5);
		
		mpMover.PlayAnimation(msThrowPlayer_ThrowAnim, 0.5f, false);
		mBaseObj.GetMeshEntity().GetAnimationStateFromName(msThrowPlayer_ThrowAnim).SetSpeed(1.0);
		msThrowPlayer_AnimState = "throw";

		cLux_GetPlayer().ChangeState(ePlayerState_Normal);
		
		cScript_SetGlobalArgVector3f(0, apThrowInfo.mvThrowTarget);
		cScript_SetGlobalArgString(1, msThrowPlayer_PlayerThrownAnim);
		cScript_SetGlobalArgVector3f(2, mvThrow_PlayerGoalPos);
		cScript_SetGlobalArgFloat(3, fAnimAngle);
		cScript_RunGlobalFunc("State_Thrown", "", "_Global_SetupThrown");
		
		Player_SetCrouching(false, false, true);
				
		cAnimationState@ pState = mBaseObj.GetMeshEntity().GetAnimationStateFromName(msThrowPlayer_ThrowAnim);
		if (pState is null)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Missing throw animation!");
			mpStateMachine.AddTimer("EnterHunt", 3);
		}
				
		Throw_EndRaycasts(true);
	}
	
	//------------------------------------------------------------
	
	void Throw_EndRaycasts(bool abThrow)
	{
		mbThrowPlayer_Success = abThrow;
		if (abThrow)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Throw succeeded");
			mpMover.SetUseMoveStateAnimations(false);
			mpMover.SetDynamicObjectAvoidanceActive(false);
			
			mBaseObj.PlaySound("AttackSound", gsGhoulSound_Attack, true, true);
			
			mpMover.SetIdleAnimName(gsGhoulAnim_Move_IdleAggressive);
		}
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Throw failed");
			int lState = DetermineDesiredAttackState(false);
			mpStateMachine.ChangeState(lState);
		}
	}
	
	//------------------------------------------------------------
	
	float mfThrow_AlignTimer = 0;
	bool mbThrow_Align = false;
	float mfThrow_GhoulStartYaw = 0;
	
	void State_ThrowPlayer_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ThrowPlayer ------",false,true);
		
		if (Blackboard_GetWraithStruggleOwner() != mBaseObj.GetID() && Blackboard_GetWraithStruggleOwner() != tID_Invalid)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Another agent is already struggling");
			mpStateMachine.ChangeState(eGhoulState_StruggleStandBy);
			return;
		}
		
		Blackboard_SetWraithStruggleOwner(mBaseObj.GetID());
		
		EnterHuntState();
		
		mpPathfinder.Stop();
				
		mbProximityDetectionActive = false;
		msThrowPlayer_AnimState = "";
		mbThrow_Align = false;
		mfThrow_AlignTimer = 0;
		
		Throw_StartRaycasts();
	}

	//------------------------------------------------------------

	void State_ThrowPlayer_Leave()
	{				
		LeaveHuntState();
		
		mbProximityDetectionActive = true;
		
		if (mpStateMachine.GetPrevState() == eGhoulState_Hunt && mpStateMachine.GetNextState() != eGhoulState_Hunt)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
		
		if (Blackboard_GetWraithStruggleOwner() == mBaseObj.GetID())
			Blackboard_SetWraithStruggleOwner(tID_Invalid);
		
		if (mbThrowPlayer_Success == false) return;
		
		mbThrowPlayer_Success = false;

		mpMover.TurnInstantlyToPos(cLux_GetPlayer().GetCharacterBody().GetFeetPosition());
		
		mpMover.SetUseMoveStateAnimations(true);
		mpMover.SetDynamicObjectAvoidanceActive(true);
		
		mpMover.SetIdleAnimName(msIdleAnim);
	}

	//------------------------------------------------------------
	
	void State_ThrowPlayer_Update(float afTimeStep) 
	{
		if (mbThrow_Align)
		{
			mfThrow_AlignTimer += afTimeStep;
			float fT = cMath_Clamp(mfThrow_AlignTimer / 0.3f, 0.f, 1.f);
			mBaseObj.GetCharBody().SetYaw(cMath_InterpolateLinear(mfThrow_GhoulStartYaw, mfThrow_GhoulGoalYaw, fT));
			mBaseObj.GetCharBody().SetFeetPosition(mvThrow_GhoulStartPos * (1.f - fT) + mvThrow_GhoulGoalPos * fT, false);
		}
	}
	
	//------------------------------------------------------------

	bool State_ThrowPlayer_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_PlayerDead) return false;
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msThrowPlayer_AnimState == "throw")
			{
				msThrowPlayer_AnimState = "";
				
				mbThrow_Align = false;
				mpMover.TurnInstantlyToPos(mvThrow_PlayerAfterThrowPos);
				
				// raycast to ground to make sure the ghoul doesn't fall through the ground
				cVector3f vRaycastFrom = mvThrow_GhoulGoalPos + cVector3f_Up * 1;
				float fDist = 0;
				cVector3f vNrm = 0;
				iPhysicsBody@ pBody = cLux_GetClosestBody(vRaycastFrom, cVector3f_Down, 1.5f, fDist, vNrm);
				if (pBody !is null)
				{
					Debug_DrawSphere(vRaycastFrom + cVector3f_Down * fDist, 0.6, cColor(1, 1, 1) * 2, 5);
					Debug_DrawSphere(vRaycastFrom + cVector3f_Down * fDist, 0.15, cColor(1, 1, 1) * 2, 5);
					mBaseObj.GetCharBody().SetFeetPosition(vRaycastFrom + cVector3f_Down * fDist, false);
				}
				
				mpStateMachine.AddTimer("CheckExit", 0.5);
				
//				float fDist = 0;
//				cVector3f vNrm = 0;
//				cLux_GetClosestBody(mBaseObj.GetCharBody().GetPosition(), cVector3f_Down, 5, fDist, vNrm);
//				mBaseObj.GetCharBody().SetFeetPosition(mBaseObj.GetCharBody().GetPosition() + cVector3f_Down * fDist, true);
								
				///////////////////////
				// Map callback
				cLuxMap@ pMap = mBaseObj.GetMap();
				tString sMethod = "void " + msThrowPlayer_AnimationOverCallback + "()";
				if (pMap.ScriptMethodExists(sMethod) && pMap.ScriptPrepare(sMethod))
					pMap.ScriptExecute();
					
				if (mbThrowPlayer_AnimationOverCallbackAutoRemove)
					msThrowPlayer_AnimationOverCallback = "";
			}
			
		}
		
		else if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			// rumble
			if (mpStateMachine.GetCurrentMessageData().mlX == 10)
			{
				Effect_Rumble_Start(1, 0.5, 0, 0.4);
			}
		}
		return true;
	}
	
	//------------------------------------------------------------

	void State_ThrowPlayer_TimerUp(uint64 alId) 
	{
		if (alId == H64("CheckExit"))
		{
			if (cLux_GetPlayer().GetCurrentStateId() != ePlayerState_Custom_Thrown)
			{
				mBaseObj.GetCharBody().SetFeetPosition(mvThrow_GhoulStartPos, false);
				if (GetSensesActive()) mpStateMachine.ChangeState(eGhoulState_PostAttack);
				else mpStateMachine.ChangeState(eGhoulState_Idle);
				return;
			}
			mpStateMachine.AddTimer("CheckExit", cMath_RandRectf(0.1, 0.4));
		}
	}

	//------------------------------------------------------------

	//} END THROW PLAYER
	
	//------------------------------------------------------------
		
	///////////////////////////////////
	// STATE: STRUGGLE
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	float mfStruggle_AlignTime = 0.2f;
	
	//------------------------------------------------------------
	
	cVector3f mvStruggle_PlayerStartPos = 0;
	cVector3f mvStruggle_PlayerTargetPos = 0;
	cVector3f mvStruggle_GhoulStartPos = 0;
	cVector3f mvStruggle_GhoulTargetPos = 0;
	float mfStruggle_PlayerStartYaw = 0;
	float mfStruggle_PlayerGoalYaw = 0;
	float mfStruggle_GhoulStartYaw = 0;
	float mfStruggle_GhoulGoalYaw = 0;
	float mfStruggle_AlignTimer = 0;
	bool mbStruggle_Aligned = false;
	bool mbStruggle_PlayerFailed = false;
	tID m_idStruggle_DummyEnt = tID_Invalid;
	tString msStruggle_AnimState = "";
	int mlStruggle_RadialBlurId = -1;

	//------------------------------------------------------------

	void State_Struggle_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Struggle ------",false,true);
		
		if (Struggle_IsActive(true) || (Blackboard_GetWraithStruggleOwner() != mBaseObj.GetID() && Blackboard_GetWraithStruggleOwner() != tID_Invalid))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Another agent is already struggling");
			mpStateMachine.ChangeState(eGhoulState_StruggleStandBy);
			mbStruggle_Aligned = true;
			return;
		}
		
		Blackboard_SetWraithStruggleOwner(mBaseObj.GetID());
		
		mbStruggle_PlayerFailed = false;
		mbProximityDetectionActive = false;
		mbStruggle_Aligned = false;
		mfStruggle_AlignTimer = 0;
		
		mpPathfinder.Stop();
		mpMover.StopTurning();
		
		mBaseObj.GetCharBody().SetTestCollision(false);
//		mBaseObj.GetCharBody().SetCollideCharacter(false);
//		mBaseObj.GetCharBody().SetActive(false);
		mBaseObj.GetCharBody().SetGravityActive(false);
		
		mpMover.PlayAnimation("alert", 0.3);
		
		iLuxEntity@ pDummyTar = cLux_ID_Entity(m_idStruggle_DummyEnt);
		if (pDummyTar is null)
		{
			mBaseObj.GetMap().CreateEntity("GhoulStruggle_DummyTar_" + mBaseObj.GetName(), "block_box.ent", cMatrixf_Identity, cVector3f_One);
			@pDummyTar = mBaseObj.GetMap().GetLatestEntity();
			m_idStruggle_DummyEnt = pDummyTar.GetID();
		}
		
		Player_SetLookSpeedMul(0);
	
		pDummyTar.SetActive(false);
		pDummyTar.GetMeshEntity().SetVisible(false);
		
		cVector3f vDummyUp = cVector3f_Up;
		cVector3f vDummyForward = mBaseObj.GetCharBody().GetFeetPosition() - mBaseObj.GetPlayerFeetPos();
		vDummyForward.y = 0;
		vDummyForward.Normalize();
		cVector3f vDummyRight = cMath_Vector3Cross(vDummyUp, vDummyForward);
		cVector3f vDummyPos = mBaseObj.GetPlayerFeetPos();
		vDummyPos.y = mBaseObj.GetCharBody().GetFeetPosition().y;
		cMatrixf mtxDummy = cMath_MatrixUnitVectors(vDummyRight, vDummyUp, vDummyForward, vDummyPos);
		
		cVector3f vFeetRootDelta = mBaseObj.GetCharBody().GetFeetPosition() - mBaseObj.GetMeshEntity().GetBoneStateFromName("j_Char_Root").GetWorldPosition();
		
		Debug_DrawSphere(vDummyPos, 0.24, cColor_Green * 2, 5);
//		Debug_DrawSphere(mBaseObj.GetCharBody().GetFeetPosition(), 0.25, cColor_Green * 2, 5);
//		Debug_DrawLine(vDummyPos, vDummyPos + vDummyForward * 10, cColor_Green * 2, 5);
		
		pDummyTar.SetMatrix(mtxDummy);	
		
		mvStruggle_PlayerStartPos = mBaseObj.GetPlayerFeetPos();
		mvStruggle_PlayerTargetPos = vDummyPos;
		mvStruggle_GhoulStartPos = mBaseObj.GetCharBody().GetFeetPosition();
		mvStruggle_GhoulTargetPos = vDummyPos + vDummyForward * 1.86347 + vFeetRootDelta;
		
//		Debug_DrawSphere(mvStruggle_GhoulTargetPos, 0.25, cColor_Green * 2, 5);
		
		mfStruggle_PlayerStartYaw = cMath_GetAngleFromPoints3D(0.0f, cLux_GetPlayer().GetCharacterBody().GetForward()).y;
		mfStruggle_PlayerGoalYaw = mfStruggle_PlayerStartYaw + cMath_GetAngleDistanceRad(mfStruggle_PlayerStartYaw, cMath_GetAngleFromPoints3D(0.0f, vDummyForward).y);
		
		mfStruggle_GhoulStartYaw = cMath_GetAngleFromPoints3D(0.0f, mBaseObj.GetCharBody().GetForward()).y;
		mfStruggle_GhoulGoalYaw = mfStruggle_GhoulStartYaw + cMath_GetAngleDistanceRad(mfStruggle_GhoulStartYaw, cMath_GetAngleFromPoints3D(0.0f, vDummyForward * -1).y);
		
		Player_SetCrouching(false, false, true);
		mpStateMachine.AddTimer("StartAnimations", mfStruggle_AlignTime);
//		mpStateMachine.AddTimer("StartAnimations", 4);
		
	}

	//------------------------------------------------------------

	void State_Struggle_Leave()
	{
		mbProximityDetectionActive = true;
		
		mBaseObj.GetCharBody().SetTestCollision(true);
		mBaseObj.GetCharBody().SetCollideCharacter(true);
		mBaseObj.GetCharBody().SetActive(true);
		mBaseObj.GetCharBody().SetGravityActive(true);
		
		mBaseObj.Timer_Add("OnTimer_Struggle_CheckDummyRemoval", 0, "OnTimer_Struggle_CheckDummyRemoval");
		
		FearHandler_SetStruggleGradingTextureActive(false);
		Effect_RadialBlur_FadeOut(mlStruggle_RadialBlurId, 0.5);
		Effect_FearTentacles_FadeMinVignette(0.f, 0.5);
		
		if (mbStruggle_PlayerFailed)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
		
		if (Blackboard_GetWraithStruggleOwner() == mBaseObj.GetID())
			Blackboard_SetWraithStruggleOwner(tID_Invalid);
	}

	//------------------------------------------------------------

	void State_Struggle_Update(float afTimeStep)
	{
		if (mbStruggle_Aligned == false)
		{
			mfStruggle_AlignTimer += afTimeStep;
			float fTRaw = mfStruggle_AlignTimer / mfStruggle_AlignTime;
			float fT = cMath_Clamp(fTRaw, 0.0f, 1.0f);
			
			mBaseObj.GetCharBody().StopMovement();
			mpPathfinder.Stop();
			mpMover.StopTurning();
			
			// set positions
			{
				cVector3f vPlayerPos = mvStruggle_PlayerStartPos * (1 - fT) + mvStruggle_PlayerTargetPos * fT;
				cLux_GetPlayer().GetCharacterBody().SetFeetPosition(vPlayerPos, false);
				
				cVector3f vGhoulPos = mvStruggle_GhoulStartPos * (1 - fT) + mvStruggle_GhoulTargetPos * fT;
				mBaseObj.GetCharBody().SetFeetPosition(vGhoulPos, false);
			}
			
			// set rotations
			{
				float fPlayerYaw = cMath_InterpolateLinear(mfStruggle_PlayerStartYaw, mfStruggle_PlayerGoalYaw, fT);
				cLux_GetPlayer().GetCharacterBody().SetYaw(fPlayerYaw);
				PlayerBody_ResetYaw();
				
				float fGhoulYaw = cMath_InterpolateLinear(mfStruggle_GhoulStartYaw, mfStruggle_GhoulGoalYaw, fT);
				mBaseObj.GetCharBody().SetYaw(fGhoulYaw);
			}
						
			if (fTRaw >= 1.5)
			{
				mbStruggle_Aligned = true;
			}
		}
		
		float fPlayerYawDiff = cMath_Abs(cLux_GetPlayer().GetCharacterBody().GetYaw() - mfStruggle_PlayerGoalYaw);
		float fGhoulYawDiff = cMath_Abs(mBaseObj.GetCharBody().GetYaw() - mfStruggle_GhoulGoalYaw);
		cVector3f vPlayDiff = mvStruggle_PlayerTargetPos - cLux_GetPlayer().GetCharacterBody().GetFeetPosition();
//		cLux_AddDebugMessage("A " + cMath_Vector3Dist(mvStruggle_PlayerTargetPos, cLux_GetPlayer().GetCharacterBody().GetFeetPosition()) + " " + vPlayDiff + " | " + cMath_Vector3Dist(mvStruggle_GhoulTargetPos, mBaseObj.GetCharBody().GetFeetPosition()));
//		cLux_AddDebugMessage("B " + fPlayerYawDiff + " | " + fGhoulYawDiff);
		
		Debug_DrawSphere(cLux_GetPlayer().GetCharacterBody().GetFeetPosition(), 0.25f, cColor(0.6, 1, 0) * 2);
		Debug_DrawLine(cLux_GetPlayer().GetCharacterBody().GetFeetPosition(), cLux_GetPlayer().GetCharacterBody().GetFeetPosition() + cLux_GetPlayer().GetCharacterBody().GetForward() * 2, cColor(0.6, 1, 0) * 2);
		Debug_DrawSphere(mBaseObj.GetCharBody().GetFeetPosition(), 0.25f, cColor(1, 0.6, 0) * 2);
		Debug_DrawLine(mBaseObj.GetCharBody().GetFeetPosition(), mBaseObj.GetCharBody().GetFeetPosition() + mBaseObj.GetCharBody().GetForward() * 2, cColor(1, 0.6, 0) * 2);
		
		iLuxEntity@ pDummyEnt = cLux_ID_Entity(m_idStruggle_DummyEnt);
		if (pDummyEnt !is null) Debug_DrawSphere(pDummyEnt.GetPosition(), 0.1, cColor_Green * 2);
	}
	
	//------------------------------------------------------------

	bool State_Struggle_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msStruggle_AnimState == "lift")
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") HoldIdle");
				mpMover.PlayAnimation("ghoul_struggle_hold_idle", 0, true);
//				mbStruggle_Aligned = true;
			}
			else if (msStruggle_AnimState == "success")
			{
				mpStateMachine.AddTimer("ToPostAttack", 0);
			}
			msStruggle_AnimState = "";
		}
		
		else if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			// scream hit
			if (mpStateMachine.GetCurrentMessageData().mlX == 0)
			{
				mlStruggle_RadialBlurId = Effect_RadialBlur_Start(0.4f, 1.f, 0.6f, 0.15f);
				
				Effect_FOV_Shake_Start(0.15, 1, 0.25, 1);
				Effect_Rumble_Start(1, 2.0f, 0, 0.5);
			}
			// shake
			else if (mpStateMachine.GetCurrentMessageData().mlX == 8)
			{
				Effect_FOV_Shake_Start(0.1, 0.1, 4, 0);
				Effect_Rumble_Start(0.2, 5, 0.5, 2);
				
				FearHandler_PlayStruggleSoundLoop(1.f, 0.5f, false);
				Sound_PlayGui("player/foley/damage/player_permafail", 1);
			}
			// rumble
			else if (mpStateMachine.GetCurrentMessageData().mlX == 10)
			{
				Effect_Rumble_Start(1, 0.5, 0, 0.4);
			}
		}
		else if (alMessageId == eLuxEntityMessage_PlayerDead) return false;
		return true;
	}
	
	//------------------------------------------------------------

	void State_Struggle_TimerUp(uint64 alId)
	{
		if (alId == H64("StartAnimations"))
		{
			Player_SetLookSpeedMul(1);
			
			bool bNotWinnable = mbAttack_InstantKill ||
								Blackboard_GetStruggleCooldown() > 0 ||
								Blackboard_GetHuntingAgentCountInRadius(mBaseObj.GetPlayerFeetPos(), 7) > 1;
								
			float fDuration = bNotWinnable ? 2 : 6;
									
			tString sDummy = "";
			iLuxEntity@ pEnt = cLux_ID_Entity(m_idStruggle_DummyEnt);
			if (pEnt !is null) sDummy = pEnt.GetName();
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Dummy ent doesn't exit, this shouldn't happen");
			}
			
			Struggle_SetReverseAnimWhenStruggling(false);
			Struggle_StartGhoul(mBaseObj.GetName(), cLux_ID_Entity(m_idStruggle_DummyEnt).GetName(), "player_ghoul_struggle_hold_idle", "", "player_ghoul_struggle_lift_up", "player_ghoul_struggle_success", "player_ghoul_struggle_scream_permafail", true, "", "", "", "", fDuration, !bNotWinnable, 2, 0.9);
			
			msStruggle_AnimState = "lift";
			mpMover.PlayAnimation("ghoul_struggle_lift_up", 0.3);
			
			FearHandler_PlayStruggleSoundLoop(4.f, 0.75f, false);
		}
		
		else if (alId == H64("ToPostAttack"))
		{
			if (Struggle_IsActive(true) == false)
			{
				mpStateMachine.ChangeState(eGhoulState_PostAttack);
				return;
			}
			mpStateMachine.AddTimer("ToPostAttack", cMath_RandRectf(0.2, 0.4));
		}
		
		else if (alId == H64("PlayerPermafail"))
		{
			FearHandler_TriggerPermaFail(false, mBaseObj.GetName());
		}
	}

	//------------------------------------------------------------
	
	void _Global_StruggleSuccess()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") StruggleSuccess");
		if (Blackboard_GetWraithStruggleOwner() != mBaseObj.GetID()) return;
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") StruggleSuccess2");
		
		Blackboard_SetStruggleCooldown(120);
		mpMover.PlayAnimation("ghoul_struggle_success", 0.3f);
		msStruggle_AnimState = "success";
		
		Terror_AddHuntingEnemy(mBaseObj.GetID());
		Blackboard_SetEnemyHunt(mBaseObj.GetID(), true);
	}
	
	//------------------------------------------------------------
	
	void _Global_StruggleFail()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") StruggleFail");
		if (Blackboard_GetWraithStruggleOwner() != mBaseObj.GetID()) return;
		
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") StruggleFail2");
		
		FearHandler_FadeTentacleSizeAddTo(0, 0.5);
		FearHandler_SetStruggleGradingTextureActive(true);
		//FearHandler_PlayStruggleSoundLoop(3.0f, 1.0f, false);
		
		mpMover.PlayAnimation("ghoul_struggle_scream_permafail", 0.3f);
		mpStateMachine.AddTimer("PlayerPermafail", 6.1);
		
		mbStruggle_PlayerFailed = true;
	}
	
	//------------------------------------------------------------
	
	void OnTimer_Struggle_CheckDummyRemoval(uint64 alID)
	{
		if (Struggle_IsActive(true) == false)
		{
			iLuxEntity@ pDummyEnt = cLux_ID_Entity(m_idStruggle_DummyEnt);
			if (pDummyEnt !is null) mBaseObj.GetMap().DestroyEntity(pDummyEnt);
			m_idStruggle_DummyEnt = tID_Invalid;
			return;
		}
		mBaseObj.Timer_Add("OnTimer_Struggle_CheckDummyRemoval", cMath_RandRectf(0.2, 0.4), "OnTimer_Struggle_CheckDummyRemoval");
	}
	
	//------------------------------------------------------------

	//} END STRUGGLE
	
	//------------------------------------------------------------
		
	///////////////////////////////////
	// STATE: STRUGGLE STAND BY
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_StruggleStandBy_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: StruggleStandBy ------",false,true);
		
		mpPathfinder.Stop();
		
		mpMover.TurnToPos(mBaseObj.GetPlayerPos());
		
		mbProximityDetectionActive = false;
		
		mpStateMachine.AddTimer("CheckIdle", 0);
	}

	//------------------------------------------------------------

	void State_StruggleStandBy_Leave()
	{
		mbProximityDetectionActive = true;
	}

	//------------------------------------------------------------

	void State_StruggleStandBy_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_StruggleStandBy_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_PlayerDead) return false;
		return true;
	}
	
	//------------------------------------------------------------

	void State_StruggleStandBy_TimerUp(uint64 alId)
	{
		if (alId == H64("CheckIdle"))
		{
			if (Blackboard_GetWraithStruggleOwner() == tID_Invalid && Struggle_IsActive(true) == false)
			{
				mpStateMachine.ChangeState(eGhoulState_PostAttack);
				return;
			}
			mpStateMachine.AddTimer("CheckIdle", cMath_RandRectf(0.2, 0.4));
		}
	}
	
	//------------------------------------------------------------

	//} END STRUGGLE STAND BY
	
	///////////////////////////////////
	// STATE: POST ATTACK
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbPostAttack_UseCustomStartPos = false;
	cVector3f mvPostAttack_CustomStartPost;
	float mfPostAttack_PlayerStartDist = 0;
	float mfPostAttack_WaitTime = 0;

	//------------------------------------------------------------

	void State_PostAttack_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PostAttack ------",false,true);
		
		mfPostAttack_WaitTime = 0;
		
		mpPathfinder.Stop();
		mpMover.SetIdleAnimName(gsGhoulAnim_Move_IdleAggressive);
		mpMover.SetIdleExtraAnimActive(false);
		mpMover.PlayAnimation("aggressive_idle_stand", 0.3f, false);
		
		cVector3f vPlayerPos = mbPostAttack_UseCustomStartPos ? mvPostAttack_CustomStartPost : mBaseObj.GetPlayerPos();
		mfPostAttack_PlayerStartDist = mBaseObj.GetDistanceToPos(vPlayerPos);
		
		Debug_DrawSphere(mBaseObj.GetPlayerPos(), 0.5, cColor_Red, 5);
		
		mpStateMachine.AddTimer("CheckDistance", 1.0f);
		mpStateMachine.AddTimer("CheckWaitTime", 0.2f);
		
		mpStateMachine.AddTimer("PlayCalm", 0.5f);
		
		float fRand = cMath_RandRectf(0.0f, 1.0f);
		if (fRand <= 0.7f) mpStateMachine.AddTimer("PlayScream", cMath_RandRectf(1, 3));
	}

	//------------------------------------------------------------

	void State_PostAttack_Leave()
	{
		mpMover.SetIdleAnimName(msIdleAnim);
		mpMover.SetIdleExtraAnimActive(true);
		mpMover.SetUseMoveStateAnimations(true);
		
		mbPostAttack_UseCustomStartPos = false;
	}

	//------------------------------------------------------------

	void State_PostAttack_Update(float afTimeStep)
	{
		mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
	}
	
	//------------------------------------------------------------

	bool State_PostAttack_Message(int alMessageId)
	{
		return true;
	}
	
	//------------------------------------------------------------

	void State_PostAttack_TimerUp(uint64 alId)
	{
		if (alId == H64("CheckDistance"))
		{
			float fDist = mBaseObj.GetDistanceToPlayer();
			if (fDist >= mfPostAttack_PlayerStartDist + 2.5f || fDist <= mfPostAttack_PlayerStartDist - 2.0f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Resume hunt because of distance, start: " + mfPostAttack_PlayerStartDist + " current: " + fDist ,false,true);
				mpStateMachine.ChangeState(eGhoulState_Hunt);
				return;
			}
			mpStateMachine.AddTimer("CheckDistance", cMath_RandRectf(0.1, 0.2));
		}
		
		else if (alId == H64("CheckWaitTime"))
		{
			float fTickRate = 0.2;
			if (mbPlayerIsInLos == false) fTickRate = 0.6;
			else if (mBaseObj.CheckIsOnScreen(true)) fTickRate = 0.4;
			
			mfPostAttack_WaitTime += fTickRate;
				
			if (mfPostAttack_WaitTime >= 8.0)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Resume hunt after waiting",false,true);
				mpStateMachine.ChangeState(eGhoulState_Hunt);
				return;
			}
			mpStateMachine.AddTimer("CheckWaitTime", 0.2);
		}
		
		else if (alId == H64("PlayCalm"))
		{
			mBaseObj.PlaySound("Calm", gsGhoulSound_LookAround, true, true);
			
			cAnimationState@ pAnim = mBaseObj.GetMeshEntity().GetAnimationStateFromName("glimpse_player_straight_ahead");
			if (pAnim !is null)
			{
				mpMover.PlayAnimation("glimpse_player_straight_ahead", 0.3f);
				mpMover.SetIdleAnimName("glimpse_player_straight_ahead");
			}
		}
		
		else if (alId == H64("PlayScream"))
		{
			mBaseObj.PlaySound("Scream", gsGhoulSound_Scream, true, true);
			PlayRandomAnimation(gvGhoulAnim_AngryGesture, 0.3f);
		}
	}

	//------------------------------------------------------------

	//} END POST ATTACK
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: STUNNED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	bool mbStunned_Stunned = false;
	bool mbStunned_Detected = false;
	float mfStunned_TurnGoal = 0.0f;
	bool mbStunned_TurnToPlayer = false;

	//------------------------------------------------------------

	void State_Stunned_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Stunned ------",false,true);
		
		SetEyeColor(gGhoul_EyeColorAlerted);
		
		mbStunned_Stunned = true;
		mbStunned_Detected = false;
		mbStunned_TurnToPlayer = false;
		
		mpPathfinder.Stop();
		
		mpMover.SetSpeedState(eGhoulSpeed_Stopped);
		
		mBaseObj.SetFOVMul(4.0f);
		mBaseObj.SetSightRangeMul(4.0f * mfSightMul);
				
		////////////////////////
		// Figure out where the player was when stunned began and prepare to turn towards that position
		cVector3f vForwardDir = mBaseObj.GetCharBody().GetForward();
		vForwardDir.y = 0;
		vForwardDir.Normalize();
		cVector3f vPlayerDir = mBaseObj.GetPlayerDir();
		vPlayerDir.y = 0;
		vPlayerDir.Normalize();
		float fSign = cMath_Vector3Cross(vForwardDir, vPlayerDir).y >= 0 ? 1.0f : -1.0f;
		mfStunned_TurnGoal = mBaseObj.GetCharBody().GetYaw() +  (fSign * cMath_Vector3Angle(vForwardDir, vPlayerDir));
		
		
		if (UsesVoice() && msHitByObjectSubject != "") mpBarkMachine.PlayVoice(msHitByObjectSubject, 1);
		else mBaseObj.PlaySound("Hit", gsGhoulSound_BeHit, true, true);
		
		mpMover.PlayAnimation(gsGhoulAnim_BeHit, 0.0f, false, false);
		
		
		mpStateMachine.AddTimer("StunnedOver", 1.0f);
	}

	//------------------------------------------------------------

	void State_Stunned_Leave()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		
		mBaseObj.SetFOVMul(1.0f);
		mBaseObj.SetSightRangeMul(1.0f);
		
		if (mpStateMachine.GetPrevState() == eGhoulState_Hunt && mpStateMachine.GetNextState() != eGhoulState_Hunt)
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		}
	}

	//------------------------------------------------------------

	void State_Stunned_Update(float afTimeStep)
	{
		////////////////////////
		// Turn towards the goal
		if (mbStunned_TurnToPlayer)
		{
			mBaseObj.GetCharBody().SetYaw(cMath_InterpolateLinear(mBaseObj.GetCharBody().GetYaw(), mfStunned_TurnGoal, afTimeStep * 5.0f));
		}
	}
	
	//------------------------------------------------------------

	bool State_Stunned_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_AttractAgent) return true;
		if (alMessageId == eLuxEntityMessage_EnterProximity) return true;
		if (alMessageId == eLuxEntityMessage_LeaveProximity) return true;
		if (alMessageId == eLuxEntityMessage_SoundHeard) return true;
		
		if(alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			mbStunned_Detected = true;
			if (mbStunned_Stunned == false)
			{
				mpStateMachine.ChangeState(eGhoulState_Hunt);
			}
			return true;
		}
		return false;
	}
	
	//------------------------------------------------------------

	void State_Stunned_TimerUp(uint64 alId)
	{
		if(alId == H64("TurnToPlayer"))
		{
			mbStunned_TurnToPlayer = true;
			
			cLux_AddTodoMessage("TODO-ANIM: turn to player animation");
			mpMover.PlayAnimation(gsGhoulAnim_TurnToPlayer, 0.0f, false, false, "");
		}

		if(alId == H64("StunnedOver"))
		{
			mbStunned_Stunned = false;
			if(mbStunned_Detected || mBaseObj.PlayerIsDetected() || mpStateMachine.GetPrevState() == eGhoulState_Hunt)
			{
				mpStateMachine.ChangeState(eGhoulState_Hunt);
			}
			else
			{
				mpStateMachine.AddTimer("SearchForPlayer", cMath_RandRectf(1.0f, 2.0f));
			}
		}
		
		if(alId == H64("SearchForPlayer"))
		{
			mvSearchArea_SearchPos = mBaseObj.GetPosition() + mBaseObj.GetPlayerDir() * 4.0f;
			mpStateMachine.ChangeState(eGhoulState_SearchArea);
		}
	}

	//------------------------------------------------------------

	//} END STUNNED
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: ENTHRALLED
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlEnthralled_DisturbedCount = 0;
	float mfEnthralled_PosCorrCount = 0.f;
	cVector3f mvEnthralled_LookAtPos;
	cVector3f mvEnthralled_StandPos;
    tString msEnthralled_IdleAnim = "";
	
	//------------------------------------------------------------

	void State_Enthralled_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Enthralled ------",false,true);
        
        Terror_RemoveHuntingEnemy(mBaseObj.GetID());
        Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		
		mpPathfinder.Stop();	
				
        mpStateMachine.AddTimer("MoveToPos", cMath_RandRectf(0.4f, 0.8f));
		
		mlEnthralled_DisturbedCount = 0;
		mfEnthralled_PosCorrCount = 0.f;
	}

	//------------------------------------------------------------

	void State_Enthralled_Leave()
	{
		mpMover.SetUseMoveStateAnimations(true);
		mbAttracted_Enabled = true;
	}

	//------------------------------------------------------------

	void State_Enthralled_Update(float afTimeStep)
	{		
		if (mfEnthralled_PosCorrCount > 0.f)
		{
			mfEnthralled_PosCorrCount -= afTimeStep;
			
			cVector3f vCurr = mBaseObj.GetCharBody().GetFeetPosition();
			cVector3f vTar = mvEnthralled_StandPos;
			vTar.y = vCurr.y;
			
			if (mfEnthralled_PosCorrCount < 0.f)
				mfEnthralled_PosCorrCount = 0.f;
			
			float fT = (0.8f - mfEnthralled_PosCorrCount) / 0.8f;			
			mBaseObj.GetCharBody().SetFeetPosition(vCurr * (1.f - fT) + vTar * fT, true);
			
			float fCurrYaw = mBaseObj.GetCharBody().GetYaw();
			cVector3f vDir = cMath_Vector3Normalize(mvEnthralled_LookAtPos -  mvEnthralled_StandPos);
			float fTarYaw = cMath_GetAngleFromPoints3D(0, vDir).y;
			float fDiff = cMath_GetAngleDistanceRad(fCurrYaw, fTarYaw);	
			mBaseObj.GetCharBody().SetYaw(fCurrYaw + fDiff * fT);
		}
	}
	
	//------------------------------------------------------------

	bool State_Enthralled_Message(int alMessageId)
	{
        if (alMessageId == eLuxEntityMessage_EnterProximity)
		{
			if (GetSensesActive() == false) return true;
			
			if ((mBaseObj.GetCharBody().GetFeetPosition() - mvEnthralled_StandPos).SqrLength() > 1.f) 
				return false; 
			
			int lProximityState = mpStateMachine.GetCurrentMessageData().mlX;
            if (lProximityState == eGhoulProximity_VeryClose)
            {
                mBaseObj.PlaySound("Enthralled_HearSound", gsGhoulSound_LookAround, true, true);
                mpMover.SetUseMoveStateAnimations(true);
                mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
            }
            else if (lProximityState == eGhoulProximity_Touching)
            {
                return false;
            }
		}
		else if (alMessageId == eLuxEntityMessage_HitByProp ||
				 alMessageId == eLuxEntityMessage_PlayerDetected ||
				 alMessageId == eCustomEntityMessage_StuckCounterHigh)
		{
			if (GetSensesActive() == false) return true;
			return false;
		}
		else if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if ((mBaseObj.GetCharBody().GetFeetPosition() - mvEnthralled_StandPos).SqrLength() > 1.f) 
			{
				mpStateMachine.AddTimer("MoveToPos", cMath_RandRectf(0.4f, 0.6f));
				return true;
			}
				
			mpStateMachine.AddTimer("PlayAnim", cMath_RandRectf(0.4f, 0.6f));
		}		
		else if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetSensesActive() == false) return true;
			
			if ((mBaseObj.GetCharBody().GetFeetPosition() - mvEnthralled_StandPos).SqrLength() > 1.f)
				return false;      
			if (mpStateMachine.TimerExists("ReactCD") || mpStateMachine.GetCurrentMessageData().mlX < 3) 
				return true;

            mpStateMachine.AddTimer("ReactCD", cMath_RandRectf(1.f, 2.f));            
            mpStateMachine.AddTimer("React", cMath_RandRectf(0.2f, 0.6f));
		}
		else if (alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (GetSensesActive() == false) return true;
			
			if ((mBaseObj.GetCharBody().GetFeetPosition() - mvEnthralled_StandPos).SqrLength() > 1.f) 
				return false;			
			if (mpStateMachine.TimerExists("ReactCD") || mBaseObj.GetDistanceToPlayer2D() > 7.f)
				return true;

            mpStateMachine.AddTimer("ReactCD", cMath_RandRectf(2.f, 3.f));            
            mpStateMachine.AddTimer("React", cMath_RandRectf(0.2f, 0.6f));
		}       
		return true; 
	}
	
	//------------------------------------------------------------

	void State_Enthralled_TimerUp(uint64 alId)
	{
        if (alId == H64("MoveToPos"))
		{			
            mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
			mpPathfinder.MoveTo(mvEnthralled_StandPos, 1.f, true);
		}			
        else if (alId == H64("PlayAnim"))
        {            
            mpMover.SetUseMoveStateAnimations(false);
            mBaseObj.PlayAnimation(msEnthralled_IdleAnim, 0.5f, true);
			
			mbAttracted_Enabled = false;
			mfEnthralled_PosCorrCount = 0.8f;
        }
        else if (alId == H64("React"))
        {            
            mBaseObj.PlaySound("Enthralled_Disturbed", gsGhoulSound_LookAround, true, true);
			
			mlEnthralled_DisturbedCount++;
			if (mlEnthralled_DisturbedCount > 1)
			{
				mpMover.SetUseMoveStateAnimations(true);
				mpStateMachine.ChangeState(eGhoulState_SearchArea);
			}			
			return;
        }
	}

	//------------------------------------------------------------

	//} END ENTHRALLED
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: THREATENING APPROACH
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlThreateningApproach_AggressivenessLevel = 1;
	bool mbThreateningApproach_Gestures = true;
	bool mbThreateningApproach_AdjustSpeed = false;
	
	bool mbThreateningApproach_InAlertRange = false;
	float mfThreateningApprach_AlertRange = 6.0f;
	float mfThreateningApproach_MinSpeedDist = 4;
	float mfThreateningApproach_MaxSpeedDist = 10;
	
	//------------------------------------------------------------

	void State_ThreateningApproach_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: ThreateningApproach ------",false,true);
		
		SetEyeColor(gGhoul_EyeColorAlerted);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearSpotted);
		
		mpPathfinder.Stop();
		
		ThreateningApproach_SetAggressiveness(mlThreateningApproach_AggressivenessLevel);
		
		mpStateMachine.AddTimer("MoveToPlayer", 0.0f);
		mpStateMachine.AddTimer("Threaten", 3.0f);
		
		mbThreateningApproach_InAlertRange = false;
	}

	//------------------------------------------------------------

	void State_ThreateningApproach_Leave()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		FearThreatAgent_SetBaseFearRate(mBaseObj.GetName(), mfFearDefault);
		mpMover.SetWalkAnimName(msWalkAnim);
		Terror_RemoveEnemy(mBaseObj.GetID());
		mpMover.SetSpeedMul(1);
		
		if (mCommand == eGhoulCommand_ThreatenPlayer)
		{
			ExecuteRetreatCompletedCallback(msCommandCompletedCallback);
			mCommand = eGhoulCommand_None;
		}
	}

	//------------------------------------------------------------

	void State_ThreateningApproach_Update(float afTimeStep)
	{
		if (mbThreateningApproach_InAlertRange == false && mBaseObj.GetDistanceToPlayer() <= mfThreateningApprach_AlertRange)
		{
			mbThreateningApproach_InAlertRange = true;
			Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime * 4.0f);
		}
		else if (mbThreateningApproach_InAlertRange && mBaseObj.GetDistanceToPlayer() > mfThreateningApprach_AlertRange)
		{
			mbThreateningApproach_InAlertRange = false;
			Terror_RemoveEnemy(mBaseObj.GetID());
		}
		
		TryHunt();
	}
	
	//------------------------------------------------------------

	bool State_ThreateningApproach_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EnterProximity) return false;
		if (alMessageId == eLuxEntityMessage_LeaveProximity) return false;
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return false;
		return true;
	}
	
	//------------------------------------------------------------

	void State_ThreateningApproach_TimerUp(uint64 alId)
	{
		if (alId == H64("MoveToPlayer"))
		{
			mpPathfinder.MoveTo(mBaseObj.GetPlayerPos(), 1.0f, false);
			
			if (mbThreateningApproach_AdjustSpeed)
			{
				float fMinDist = mfThreateningApproach_MinSpeedDist;
				if (fMinDist < 0) fMinDist = 4;
				
				float fMaxDist = mfThreateningApproach_MaxSpeedDist;
				if (fMaxDist < 0) fMaxDist = 10;
				
				float fDistMul = cMath_Clamp((mBaseObj.GetDistanceToPlayer() - fMinDist) / (fMaxDist - fMinDist), 0.0f, 1.0f);
				float fSpeed = 0.2 + fDistMul * 0.8;				
				mpMover.SetSpeedMul(fSpeed);
			}
			
			mpStateMachine.AddTimer("MoveToPlayer", 0.2f);
		}
		else if (alId == H64("Threaten"))
		{
			if (mbThreateningApproach_Gestures)
			{
				mBaseObj.PlaySound("Threaten", "creatures/vocalisations/creature/ghoul/ghoul_stalk_laugh", true, true);
				PlayRandomAnimation(gvGhoulAnim_Move_Threaten);
			}
			mpStateMachine.AddTimer("Threaten", cMath_RandRectf(5.0f, 6.0f));
		}
	}
	
	//------------------------------------------------------------
	
	void ThreateningApproach_SetAggressiveness(int alLevel)
	{
		cLux_AddDebugMessage("GHOUL AGGRO LEVEL"+alLevel);
		if (alLevel == 0)
		{
			mpMover.SetSpeedState(eGhoulSpeed_Stopped);
			mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkThreatening);
		}
		else if (alLevel == 1)
		{
			mpMover.SetSpeedState(eGhoulSpeed_SlowWalk);
			mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkThreatening);
		}
		else if (alLevel == 2)
		{
			mpMover.SetSpeedState(eGhoulSpeed_MediumWalk);
			mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkThreatening);
			
		}
		else if (alLevel == 3)
		{
			mpMover.SetSpeedState(eGhoulSpeed_Walk);
			mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkThreatening);
		}
		else if (alLevel == 4)
		{
			mpMover.SetSpeedState(eGhoulSpeed_FasterWalk);
			mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkThreatening);
		}
		else if (alLevel == 5)
		{
			mpMover.SetSpeedState(eGhoulSpeed_SlowRun);
		}
		else if (alLevel == 6)
		{
			mpMover.SetSpeedState(eGhoulSpeed_Run);
			mpMover.SetWalkAnimName("run");
		}
		else if (alLevel == 7)
		{
			mpMover.SetSpeedState(eGhoulSpeed_FastRun);
			mpMover.SetWalkAnimName("run");
		}
		else if (alLevel == 8)
		{
			mpMover.SetSpeedState(eGhoulSpeed_SlowestWalk);
			mpMover.SetWalkAnimName(gsGhoulAnim_Move_WalkThreatening);
		}
		else if (alLevel == 9)
		{
			mpMover.SetSpeedState(eGhoulSpeed_Walk);
			mpMover.SetWalkAnimName("walk");
		}
	}

	//------------------------------------------------------------

	//} END THREATENING MOVE
		
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: STARE
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvStare_PlayerPos;
	int mlStare_ThreatenCount = 0;
	float mfStare_DistanceCovered = 0.0f;
	
	//------------------------------------------------------------

	void State_Stare_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Stare ------",false,true);
		
		SetEyeColor(gGhoul_EyeColorAlerted);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		
		mvStare_PlayerPos = mBaseObj.GetPlayerPos();
		
		mpStateMachine.AddTimer("TurnToPlayer", 0.0f);
		mpStateMachine.AddTimer("CheckDistance", 1.0f);
	}

	//------------------------------------------------------------

	void State_Stare_Leave()
	{
		SetEyeColor(gGhoul_EyeColorDefault);
		
		Terror_RemoveEnemy(mBaseObj.GetID());
	}

	//------------------------------------------------------------

	void State_Stare_Update(float afTimeStep)
	{
		TryHunt();
		
//		cLux_AddDebugMessage("ASDF " + mlStare_ThreatenCount);
	}
	
	//------------------------------------------------------------

	bool State_Stare_Message(int alMessageId)
	{
		int lProximityState = mpStateMachine.GetCurrentMessageData().mlX;
		
		if(alMessageId == eLuxEntityMessage_EnterProximity)
		{
			if (GetSensesActive() == false) return true;
			if (lProximityState == eGhoulProximity_LowLightVision)
			{
				Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime);
			}
		}
		
		if (alMessageId == eLuxEntityMessage_LeaveProximity)
		{
			if (GetSensesActive() == false || mlStare_ThreatenCount > 2) return true;
			if (lProximityState == eGhoulProximity_LowLightVision)
			{
				Terror_RemoveEnemy(mBaseObj.GetID());
			}
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Stare_TimerUp(uint64 alId)
	{
		if (alId == H64("TurnToPlayer"))
		{
			mpMover.TurnToPos(mBaseObj.GetPlayerPos());
			mpStateMachine.AddTimer("TurnToPlayer", 0.2f);
		}
		
		if (alId == H64("CheckDistance"))
		{
			mpStateMachine.AddTimer("CheckDistance", 1.0f);
			if (mbPlayerIsInLos == false)
			{
				Terror_RemoveEnemy(mBaseObj.GetID());
				return;
			}
			
			float fCurrentDist = (mBaseObj.GetPlayerPos() - mBaseObj.GetPosition()).Length();
			float fPrevDist = (mvStare_PlayerPos - mBaseObj.GetPosition()).Length();
			float fDistanceChange = fPrevDist - fCurrentDist;
			mfStare_DistanceCovered += fDistanceChange;
						
			if (mfStare_DistanceCovered > 2.0f)
			{
				mfStare_DistanceCovered -= 2.0f;
				
				++mlStare_ThreatenCount;
				if(mlStare_ThreatenCount > 2)
				{
					Terror_AddEnemy(mBaseObj.GetID(), gfAlertTime * 3.0f);
				}
				
				cLux_AddTodoMessage("TODO-SOUND: threaten");
				mBaseObj.PlaySound("AngryShout", gsGhoulSound_Threaten, true, true);
				
				cLux_AddTodoMessage("TODO-ANIM: threaten");
				mpMover.PlayAnimation(gsGhoulAnim_Threaten, 0.0f, false, false, "");
			}
			else if (mfStare_DistanceCovered < -2.0f)
			{
				mfStare_DistanceCovered = 0.0f;
				
				if (mlStare_ThreatenCount > 0)
				{
					--mlStare_ThreatenCount;
					Terror_RemoveEnemy(mBaseObj.GetID());
				}
			}
			
			mvStare_PlayerPos = mBaseObj.GetPlayerPos();
		}
	}

	//------------------------------------------------------------

	//} END STARE
	
	//------------------------------------------------------------
    
    ///////////////////////////////////
	// STATE: GUARD
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
    tString msGuard_IdleAnim = "";
    tString msGuard_IdleSound = "";
	tString msGuard_DisturbAnim = "";
	cVector3f mvGuard_StandPos = 0.f;
	cVector3f mvGuard_LookAtPos = 0.f;
    cVector3f mvGuard_SoundPos = 0.f;
	int mlGuard_DisturbanceCount = 0;
	int mlGuard_SpeedState = eGhoulSpeed_FastWalk;
	
	//------------------------------------------------------------

	void State_Guard_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Guard ------",false,true);
		
		mlGuard_DisturbanceCount = 0;
        
        Terror_RemoveHuntingEnemy(mBaseObj.GetID());
        Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
		
		mpPathfinder.StopTrack();
		mpMover.StopTurning();
		mpMover.SetSpeedState(mlGuard_SpeedState);
		
		mpMover.SetDynamicObjectAvoidanceActive(false);
		
		bool bPlayAnimDirectly = true;
		
		if (cMath_Vector3DistSqr(mBaseObj.GetCharBody().GetFeetPosition(), mvGuard_StandPos) > 1.f)
		{
			bPlayAnimDirectly = false;
			mpStateMachine.AddTimer("MoveToPos", cMath_RandRectf(0.4f, 0.8f));
		}
		
		iCharacterBody@ pBody = mBaseObj.GetCharBody();
		cVector3f vDirToLookPos = mvGuard_LookAtPos - pBody.GetFeetPosition();
		vDirToLookPos.y = 0.f;
		
		if (cMath_Vector3Dot(pBody.GetForward(), cMath_Vector3Normalize(vDirToLookPos)) < 0.9f)
		{
			bPlayAnimDirectly = false;
			mpStateMachine.AddTimer("TurnToPos", cMath_RandRectf(0.4f, 0.8f));
		}
		
		if (bPlayAnimDirectly)
			mpStateMachine.AddTimer("PlayAnim", 0.f);
	}

	//------------------------------------------------------------

	void State_Guard_Leave()
	{
		mpMover.SetUseMoveStateAnimations(true);		
		mpMover.SetDynamicObjectAvoidanceActive(true);
        
        if (msGuard_IdleSound != "") 
			Sound_Stop(msGuard_IdleSound, 0.3f);
	}

	//------------------------------------------------------------

	void State_Guard_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Guard_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EnterProximity)
		{
			if (GetSensesActive() == false) return true;
			if (Player_GetHiding()) return true;
			
			int lProximityState = mpStateMachine.GetCurrentMessageData().mlX;
            if (lProximityState == eGhoulProximity_SemiClose)
            {
                mBaseObj.PlaySound("Guard_HearSound", gsGhoulSound_LookAround, true, true);
				
                mpMover.SetUseMoveStateAnimations(true);
                mpMover.TurnToPos(mBaseObj.GetPlayerFeetPos());
				
				mpStateMachine.StopTimer("TurnToPos");
				mpStateMachine.StopTimer("MoveToPos");
				mpStateMachine.StopTimer("PlayAnim");
				
                if (msGuard_IdleSound != "")
					Sound_Stop(msGuard_IdleSound, 0.3f);
            }
            else if (lProximityState == eGhoulProximity_Touching)
            {
                mpStateMachine.ChangeState(eGhoulState_Hunt);
                
                if (msGuard_IdleSound != "")
					Sound_Stop(msGuard_IdleSound, 0.3f);
            }
		}
        else if (alMessageId == eLuxEntityMessage_PlayerDetected ||
				 alMessageId == eLuxEntityMessage_HitByProp)
        {
			return false;
        }
		else if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (cMath_Vector3DistSqr(mBaseObj.GetCharBody().GetFeetPosition(), mvGuard_StandPos) > 1.f)
			{
				mpStateMachine.AddTimer("MoveToPos", cMath_RandRectf(0.4f, 0.8f));
				return true;
			}
			
			if (mpStateMachine.TimerExists("TurnToPos") == false)
				mpStateMachine.AddTimer("TurnToPos", cMath_RandRectf(0.4f, 0.6f));
		}		
		else if (alMessageId == eLuxEntityMessage_SoundHeard ||
				 alMessageId == eCustomEntityMessage_SeeFlashlightGobo ||
				 alMessageId == eCustomEntityMessage_DetectFlashlightGobo ||
				 alMessageId == eCustomEntityMessage_HitByFlashlight)
		{
			if (GetSensesActive() == false) return true;
			if (mpStateMachine.TimerExists("ReactToSound") || mpStateMachine.TimerExists("ReactCD"))
				return true;
			
			if (mlGuard_DisturbanceCount >= 1)
			{
				mlGuard_DisturbanceCount = 0;
				mpMover.SetUseMoveStateAnimations(true);
				return false;
			}
			
            if (mpMover.GetMoveSpeed() > 1.f || 
				cMath_Vector3DistSqr(mBaseObj.GetCharBody().GetFeetPosition(), mvGuard_StandPos) > 1.f)
            {
                mpPathfinder.Stop();
                return false;
            }
            
			mpStateMachine.StopTimer("TurnToPos");
			mpStateMachine.StopTimer("PlayAnim");
			
            mvGuard_SoundPos = mpStateMachine.GetCurrentMessageData().mvX;
            mpStateMachine.AddTimer("ReactToSound", cMath_RandRectf(0.3f, 0.9f));
			mpStateMachine.AddTimer("ReactCD", cMath_RandRectf(3.5f, 4.f));
		}
		
		return true;
	}
	
	//------------------------------------------------------------

	void State_Guard_TimerUp(uint64 alId)
	{
		if (alId == H64("MoveToPos"))
		{
            if (cMath_Vector3DistSqr(mBaseObj.GetCharBody().GetFeetPosition(), mvGuard_StandPos) < 1.f)
			{
				mpPathfinder.Stop();
				mpStateMachine.AddTimer("TurnToPos", cMath_RandRectf(0.4f, 0.6f));
				return;
			}
            
			mpPathfinder.MoveTo(mvGuard_StandPos, 0.1f, true);
		}		
		else if (alId == H64("TurnToPos"))
		{
            mpMover.SetUseMoveStateAnimations(true);
			mpMover.TurnToPos(mvGuard_LookAtPos);
            mpStateMachine.AddTimer("PlayAnim", 1.5f);
		}		
        else if (alId == H64("PlayAnim"))
        {            
            if (cMath_Vector3DistSqr(mBaseObj.GetCharBody().GetFeetPosition(), mvGuard_StandPos) > 1.f)
			{
				if (mpStateMachine.TimerExists("MoveToPos") == false)
					mpStateMachine.AddTimer("MoveToPos", cMath_RandRectf(0.4f, 0.8f));
				return;
			}
			
            mpMover.SetUseMoveStateAnimations(false);
			
			if (mBaseObj.GetMeshEntity().GetAnimationStateFromName(msGuard_IdleAnim).IsActive() == false)
				mpMover.PlayAnimation(msGuard_IdleAnim, 0.3f, true);
            
            if (msGuard_IdleSound != "")
				Sound_Play(msGuard_IdleSound, 0.3f);
        }
        else if (alId == H64("ReactToSound"))
        {			
			if (mpStateMachine.TimerExists("PlayAnim")) 
				return;
			
			mlGuard_DisturbanceCount++;
			
			if (msGuard_IdleSound != "")
				Sound_Stop(msGuard_IdleSound, 0.3f);			
			
			mpMover.PlayAnimation(msGuard_DisturbAnim, 0.3f, false);			
            mBaseObj.PlaySound("Guard_HearSound", gsGhoulSound_LookAround, true, true);

            mpStateMachine.AddTimer("PlayAnim", cMath_RandRectf(3.5f, 4.f));
			mpStateMachine.AddTimer("DecreaseDisturbanceCount", cMath_RandRectf(8.f, 11.f));
        }
		else if (alId == H64("DecreaseDisturbanceCount"))
		{
			if (mlGuard_DisturbanceCount > 0)
				--mlGuard_DisturbanceCount;
		}
	}

	//------------------------------------------------------------

	//} END GUARD
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: TRAPPED
	//{////////////////////////////////
	
	//------------------------------------------------------------

	void State_Trapped_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Trapped ------");
		mpPathfinder.Stop();
		mpStateMachine.AddTimer("CheckIdle", 0.5f);
	}

	//------------------------------------------------------------

	void State_Trapped_Leave()
	{
	}

	//------------------------------------------------------------

	void State_Trapped_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Trapped_Message(int alMessageId)
	{
		return true;
	}
	
	//------------------------------------------------------------

	void State_Trapped_TimerUp(uint64 alId)
	{
		if (alId == H64("CheckIdle"))
		{
			Idle_DecideBehavior();
			mpStateMachine.AddTimer("CheckIdle", 0.5f);
		}
	}

	//------------------------------------------------------------

	//} END TRAPPED
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: BLOCKED
	//{////////////////////////////////

	//------------------------------------------------------------

	cVector3f mvBlocked_BlockagePosition;
	int mlBlocked_PrevState = eGhoulState_Idle;
	int mlBlocked_SameStateCounter = 0;
	
	tString msBlocked_EnterCallback = "";
	bool mbBlocked_EnterCallbackAutoRemove = false;
	
	//------------------------------------------------------------

	void State_Blocked_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Blocked ------",false,true);
		
		mpPathfinder.Stop();
		mBaseObj.ResetPlayerDetectionState();
		
		float fCharRadius = mBaseObj.GetCharBody().GetSize().x * 0.5f;
		float fDist = 2.0f;
		cVector3f vFwd = mBaseObj.GetCharBody().GetForward();
		cVector3f vRayStart = mBaseObj.GetPosition();
		vRayStart += vFwd * fCharRadius;
		
		//////////////////////////////
		// Detect if we're stuck in a blocked loop
		if (mpStateMachine.GetPrevState() == mlBlocked_PrevState)
		{
			++mlBlocked_SameStateCounter;
			mBaseObj.Timer_Remove("Timer_Blocked_ResetSameStateCounter");
			if (mlBlocked_SameStateCounter >= 3)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Getting blocked in a loop, return to idle");
				mlBlocked_SameStateCounter = 0;
				mpStateMachine.ChangeState(eGhoulState_Idle);
				LeaveBlockedState();
				return;
			}
			else
			{
				mBaseObj.Timer_Add("Timer_Blocked_ResetSameStateCounter", 10.0f, "OnTimer_Blocked_ResetSameStateCounter");
			}
		}
		else
		{
			mlBlocked_SameStateCounter = 0;
		}
		
		//////////////////////////////
		// Set state before being blocked
		mlBlocked_PrevState = mpStateMachine.GetPrevState();
		
		//////////////////////////////
		// Failed to reach the attraction
		if (mlBlocked_PrevState == eGhoulState_Attracted)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Could not reach attraction, flag it unreachable");
			cScript_RunGlobalFunc(mBaseObj.GetVarString("CurrentMeatAttraction"), "", "_Global_SetUnreachable");
		}

		//////////////////////////////
		// Check if we are blocked by a prop
		cLuxClosestEntityData data;
		if (cLux_GetClosestEntity(vRayStart, vFwd, fDist, 0, false, data) == false)
		{
			vRayStart.y -= mBaseObj.GetCharBody().GetSize().y * 0.5f - 0.2f;
			cLux_GetClosestEntity(vRayStart, vFwd, fDist, 0, false, data);
		}
		if (data.mpEntity !is null && data.mpEntity.GetEntityType() == eLuxEntityType_Prop)
		{
			m_idBlockedByProp_Entity = data.mpEntity.GetID();
			mpStateMachine.ChangeState(eGhoulState_BlockedByProp);
		}
		else
		{
			cVector3f vPushPos = mBaseObj.GetCharBody().GetFeetPosition() + mBaseObj.GetCharBody().GetForward() * 0.5f;
			float fRadius = 1.0f;
			cVector3f vPushMin = vPushPos - cVector3f_One * fRadius;
			cVector3f vPushMax = vPushPos + cVector3f_One * fRadius;
			
			Debug_DrawSphere(vPushPos, fRadius, cColor_Red, 4);
			Debug_DrawSphere(vPushPos, 0.2, cColor_Red, 4);
			
			array<iPhysicsBody@> vBodies;
			cLux_GetCurrentMap().GetPhysicsWorld().GetBodiesInAABB(vPushMin, vPushMax, vBodies);
			
			int lBlockingObjects = 0;
			for (int i = 0; i < vBodies.size(); ++i)
			{
				iPhysicsBody@ pBody = vBodies[i];
				if (pBody is null) continue;
				iLuxEntity@ pEnt = cLux_GetBodyEntity(pBody);
				if (pEnt is null) continue;
				if (pBody.GetMass() == 0) continue;
				if (pEnt.GetEntityType() != eLuxEntityType_Prop) continue;
				
				cVector3f vToBody = pBody.GetWorldPosition() - vPushPos;
				if (vToBody.Length() > fRadius) continue;
				
				++lBlockingObjects;
			}
			
			if (lBlockingObjects > 0 && mBaseObj.Timer_Exists("BlockagePushCooldown") == false)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Cannot break, push away blockage");
				mbAttackClose_PushBlockage = true;
				mpStateMachine.ChangeState(eGhoulState_AttackClose);
				
				mBaseObj.Timer_Add("BlockagePushCooldown", 20, "");
			}
			else
			{
				SidestepBlockage();
			}
		}
		
		Blocked_ExecuteEnterCallback();
	}

	//------------------------------------------------------------

	void State_Blocked_Leave()
	{
	}

	//------------------------------------------------------------

	void State_Blocked_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_Blocked_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return true;
		if (alMessageId == eLuxEntityMessage_EndOfPath) return false;
		
		return false;
	}

	//------------------------------------------------------------

	void State_Blocked_TimerUp(uint64 alId)
	{
	}
	
	//------------------------------------------------------------
	
	void Blocked_ExecuteEnterCallback()
    {
		if (msBlocked_EnterCallback == "") return;
		
        tString sMethodName = "void " + msBlocked_EnterCallback + "()";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.ScriptExecute();
		}
		
		if (mbBlocked_EnterCallbackAutoRemove) msBlocked_EnterCallback = "";
    }
	
	//------------------------------------------------------------
	
	void OnTimer_Blocked_ResetSameStateCounter(uint64 alID)
	{
		mlBlocked_SameStateCounter = 0;
	}
	
	//------------------------------------------------------------

	//} END BLOCKED

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: BLOCKED BY PROP
	//{////////////////////////////////

	//------------------------------------------------------------
	
	tID m_idBlockedByProp_Entity = tID_Invalid;
	uint mlBlockedByProp_EntityCollGroup = 0;
	
	bool mbBlockedByProp_StepBack = false;
	bool mbBlockedByProp_AvoidingOpenDoor = false;
	tID m_idBlockedByProp_ForcedBreak = tID_Invalid;
	
	array<tID> mvBlockedByProp_EntityHistory;
	
	//------------------------------------------------------------

	void State_BlockedByProp_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BlockedByProp ------");
		cLux_AddDebugMessage("Agent is blocked");
		
		mpPathfinder.Stop();
		
		mbBlockedByProp_StepBack = false;
		
		//////////////////////
		// Get blocked prop info
		cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
		
		tString sPropName = "";
		if (pProp !is null) sPropName = pProp.GetName();
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Blocked by: " + sPropName);
		
		//////////////////////
		// Check if blocked by same entity, or too many times
		bool bBlockedBySameProp = false;
		for (int i = 0; i < mvBlockedByProp_EntityHistory.size(); ++i)
		{
			if (m_idBlockedByProp_Entity == mvBlockedByProp_EntityHistory[i])
			{
                if(!pProp.GetIsDoor()){
                    bBlockedBySameProp = true;
                }
				break;
			}
		}
		
		if (bBlockedBySameProp || mvBlockedByProp_EntityHistory.size() >= 2)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Blocked by same entity or too many times, retreat");
			mbRetreat_CalculatePos = true;
			mpStateMachine.ChangeState(eGhoulState_Retreat);
			return;
		}
		else
		{
			mvBlockedByProp_EntityHistory.push_back(m_idBlockedByProp_Entity);
			mBaseObj.Timer_Add("RemoveHistory", 15.0f, "Timer_BlockedByProp_RemoveHistory");
		}
		
		//////////////////////
		// Deal with blockage
		bool bBreakDoor = false;
		if(pProp.GetIsDoor())
		{
			bBreakDoor = true;
			cLux_AddDebugMessage("Setting to break door");
		}
		
		//////////////////////
		// Push blockage away
		else if (mBaseObj.Timer_Exists("BlockagePushCooldown") == false)
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Cannot break, push away blockage");
			mbAttackClose_PushBlockage = true;
			mpStateMachine.ChangeState(eGhoulState_AttackClose);
			
			mBaseObj.Timer_Add("BlockagePushCooldown", 20, "");
		}
		
		//////////////////////
		// Can't break the blockage
		else if (pProp.GetIsBreakable() == false)
		{
			SidestepBlockage();
			cLux_AddDebugMessage("Agent can't break");
		}
		
		//////////////////////
		// Final fallback, try to break it down
		else
		{
			bBreakDoor = true;
		}
		
		if (bBreakDoor)
		{
			cLux_AddDebugMessage("Trying to break door");
			mBaseObj.PlaySound("AngryShout", gsGhoulSound_AngryShout, true, true);
			mpStateMachine.AddTimer("AttackObstacle", 0.1f);
		}
	}

	//------------------------------------------------------------

	void State_BlockedByProp_Leave()
	{
		if (mlBlockedByProp_EntityCollGroup == 0) return;
		
		cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
		for (int i = 0; i < pProp.GetBodyNum(); ++i)
		{
			iPhysicsBody@ pBody = pProp.GetBody(i);				
			pBody.SetCollideFlags(mlBlockedByProp_EntityCollGroup);
		}
		
		mlBlockedByProp_EntityCollGroup = 0;
	}

	//------------------------------------------------------------

	void State_BlockedByProp_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_BlockedByProp_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mbBlockedByProp_StepBack)
			{
				mbBlockedByProp_StepBack = false;
				mpMover.TurnToPos(mBaseObj.GetPosition() - SwingDoor_GetDoorwayOpenDir(cLux_ID_Prop(m_idBlockedByProp_Entity).GetName()));
				mpStateMachine.AddTimer("TryToOpenDoor", 0.4f);
			}
			else if (mbBlockedByProp_AvoidingOpenDoor)
			{
				mbBlockedByProp_AvoidingOpenDoor = false;
				
				cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
				if (SwingDoor_GetOpenAmount(pProp.GetName()) >= 0.6f)
				{
					mpStateMachine.ChangeState(mlBlocked_PrevState);
					LeaveBlockedState();
				}
				else
				{
					BlockedByProp_StepBack();
				}
			}
			return false;
		}
		
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh)
		{
			mpPathfinder.Stop();
			SidestepBlockage();
			return true;
		}
		
		return false;
	}

	//------------------------------------------------------------

	void State_BlockedByProp_TimerUp(uint64 alId)
	{
		
		if (alId == H64("TryToOpenDoor"))
		{
			/*
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Apply force to door");
			
			cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
			if (SwingDoor_GetDoorBodyID(pProp.GetName()) == tID_Invalid)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Not a swing door, leave blocked state");
				int lNextState = mlBlocked_PrevState;
				if (mlBlocked_PrevState == eGhoulState_BlockedByProp) lNextState = eGhoulState_Idle;
				mpStateMachine.ChangeState(lNextState);
				LeaveBlockedState();
				return;
			}
			
			mlBlockedByProp_EntityCollGroup = cLux_ID_Body(SwingDoor_GetDoorBodyID(pProp.GetName())).GetCollideFlags();				
			for (int i = 0; i < pProp.GetBodyNum(); ++i)
			{
				iPhysicsBody@ pBody = pProp.GetBody(i);				
				pBody.SetCollideFlags(cLux_GetCurrentMap().GetCollideFlag("-agent"));
			}
			
			SwingDoor_PushOpen(cLux_ID_Prop(m_idBlockedByProp_Entity).GetName(), 1.0f, 10, 0.1f);
			mBaseObj.PlaySound("AngryShout", gsGhoulSound_AngryShout, true, true);
			
			float fTime = mbIsInLiquid ? 1.5f : 0.8f;
			mpStateMachine.AddTimer("CheckDoorOpen", fTime);
			*/
			cLux_AddDebugMessage("Changing to break door state1");
			mpStateMachine.ChangeState(eGhoulState_BreakDoor);
		}
		
		if (alId == H64("AttackObstacle"))
		{
			cLux_AddDebugMessage("Changing to break door state2");
			mpStateMachine.ChangeState(eGhoulState_BreakDoor);
		}

		if (alId == H64("CheckDoorOpen"))
		{
			/*
			cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
			for (int i = 0; i < pProp.GetBodyNum(); ++i)
			{
				iPhysicsBody@ pBody = pProp.GetBody(i);
				pBody.SetCollideFlags(mlBlockedByProp_EntityCollGroup);
			}				
			mlBlockedByProp_EntityCollGroup = 0;		
			
			if (SwingDoor_GetOpenAmount(cLux_ID_Prop(m_idBlockedByProp_Entity).GetName()) < 0.7f)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door isn't open, break it down");
				cLux_AddDebugMessage("Door not open, break down");
				mpStateMachine.AddTimer("AttackObstacle", 0.8f);
			}
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door is open, return to previous: " + StateToString(mlBlocked_PrevState));
				int lNextState = mlBlocked_PrevState;
				if (mlBlocked_PrevState == eGhoulState_BlockedByProp) lNextState = eGhoulState_Idle;
				mpStateMachine.ChangeState(lNextState);
				LeaveBlockedState();
			}
			*/
			cLux_AddDebugMessage("Changing to break door state3");
			mpStateMachine.ChangeState(eGhoulState_BreakDoor);
		}
	}

	//------------------------------------------------------------
	
	void BlockedByProp_StepBack()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Door opens towards us, step back then open");
		
		cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
		if (pProp is null) return;
					
		cVector3f vStepBackDir1 = SwingDoor_GetDoorwayOpenDir(pProp.GetName());
		vStepBackDir1.y = 0;
		vStepBackDir1.Normalize();
		
		cVector3f vStepBackDir2 = SwingDoor_GetDoorwayOpenDir(pProp.GetName());
		vStepBackDir2 = cMath_Vector3Cross(vStepBackDir2, cVector3f_Up);
		vStepBackDir2.y = 0;
		vStepBackDir2.Normalize();
		
		mpPathfinder.MoveTo(mBaseObj.GetPosition() + vStepBackDir1 * 1.6f + vStepBackDir2 * 0.5f, 0.5f, false);
		mpMover.SetSpeedState(eGhoulSpeed_FastWalk);
		mbBlockedByProp_StepBack = true;
	}
	
	//------------------------------------------------------------
	
	void Timer_BlockedByProp_RemoveHistory(uint64 alId)
	{
		if (mvBlockedByProp_EntityHistory.size() <= 0) return;
		mvBlockedByProp_EntityHistory.pop_front();
	}
	
	//------------------------------------------------------------

	//} END BLOCKEDBYPROP

	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: ENTER DOOR
	//{////////////////////////////////

	//------------------------------------------------------------
	
	float mfEnterDoor_Yaw;
	bool mbEnterDoor_CanHear = false;

	//------------------------------------------------------------

	void State_EnterDoor_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: EnterDoor ------",false,true);
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Run);
		
		mbEnterDoor_CanHear = false;
		
		mBaseObj.SetFOVMul(2.0f);
		mBaseObj.SetSightRangeMul(2.0f * mfSightMul);
		
		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + mBaseObj.GetCharBody().GetForward() * 4.0f, 0.0f, 3.0f, true, false, true, null);
		if (pNode !is null)
		{
			mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
		}
		else
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
		
//		cVector3f vThroughDir = cMath_Vector3Project(mBaseObj.GetCharBody().GetForward(), SwingDoor_GetDoorwayOpenDir(msBlockedByProp_EntityName));
//		vThroughDir.Normalize();
//		cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() + vThroughDir * 3.0f, 0.0f, 2.0f, true, false, false, null);
//		if (pNode !is null)
//		{
//			mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
//		}
	}

	//------------------------------------------------------------

	void State_EnterDoor_Leave()
	{
	}

	//------------------------------------------------------------

	void State_EnterDoor_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_EnterDoor_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_SoundHeard) return !mbEnterDoor_CanHear;
		
		if (alMessageId == eLuxEntityMessage_PlayerDetected)
		{
			if (GetSensesActive() == false) return true;
			
			mpStateMachine.ChangeState(eGhoulState_Hunt);
			return true;
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mBaseObj.PlaySound("LookAround", gsGhoulSound_LookAround, true, true);
			PlayRandomAnimation(mvGhoulAnim_LookAroundLong, 0.0f);
			return true;
		}
		return true;
	}

	//------------------------------------------------------------

	void State_EnterDoor_TimerUp(uint64 alId)
	{
		if(alId == H64("GiveUp"))
		{
			Terror_RemoveHuntingEnemy(mBaseObj.GetID());
			Blackboard_SetEnemyHunt(mBaseObj.GetID(), false);
			
			mbEnterDoor_CanHear = true;
			
			mpStateMachine.AddTimer("Exit", 1.0f);
		}
		
		if(alId == H64("Exit"))
		{
			mpStateMachine.ChangeState(eGhoulState_TrackSmell);
		}
	}

	//------------------------------------------------------------

	//} END ENTER DOOR
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: RETREAT
	//{////////////////////////////////

	//------------------------------------------------------------
	
	cVector3f mvRetreat_RetreatToPos;
	bool mbRetreat_CalculatePos = true;
	tString msRetreat_CompletedCallback = "";
	
	bool mbRetreat_SensesActive = false;
	
	cVector3f mvRetreat_CommandRetreatToPos;
	bool mbRetreat_CommandCalculatePos;
	
	 bool mbRetreat_ProximityActive = false;
	
	//------------------------------------------------------------

    void State_Retreat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Retreat ------");
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Run);
		
		if (mbRetreat_ProximityActive == false) mbProximityDetectionActive = false;

		if (mbRetreat_CalculatePos)
		{
			////////////////
			// Figure out if we're retreating from the player
//			bool bRetreatFromPlayer = mBaseObj.GetDistanceToPlayer() <= 8.0f ||
//										cLux_CheckLineOfSight(mBaseObj.GetEyePostion(), mBaseObj.GetPlayerPos(), true, false) ||
//										cLux_CheckLineOfSight(mBaseObj.GetPosition(), mBaseObj.GetPlayerPos(), true, false) ||
//										cLux_CheckLineOfSight(GetFeetPosition(), mBaseObj.GetPlayerPos(), true, false);
											
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Calculate player pos");
			cVector3f vRetreatSource = mBaseObj.GetPlayerPos();
			cAINode@ pRetreatNode;
			
			cLuxArea@ pArea = GetClosestRetreatArea();
			if (pArea !is null)
			{
				@pRetreatNode = mpPathfinder.GetNodeAtPos(pArea.GetPosition(), 0.2f, 2.0f, true, false, false, null);
				if (pRetreatNode !is null) cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Retreating to closest retreat area");
			}
			
			if (pRetreatNode is null)
			{
				@pRetreatNode = mpPathfinder.GetNodeOutOfSight(vRetreatSource, 18.0f, 25.0f, mBaseObj.GetPlayerPos(), mBaseObj.GetPlayerDir(), 90.0f, false, false, true, null);
				if (pRetreatNode !is null) cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Retreating to node out of sight");
			}
			
			if (pRetreatNode is null)
			{
				@pRetreatNode = mpPathfinder.GetNodeOutOfSight(vRetreatSource, 25.0f, 40.0f, mBaseObj.GetPlayerPos(), mBaseObj.GetPlayerDir(), 90.0f, false, false, true, null);
				if (pRetreatNode !is null) cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Retreating to node out of sight, big radius");
			}
			
			if (pRetreatNode is null)
			{
				@pRetreatNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPosition() - mBaseObj.GetPlayerDir() * 10.0f, 0.0f, 5.0f, true, false, true, null);
				if (pRetreatNode !is null) cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Couldn't find node out of sight, go away from the player");
			}
			
			if (pRetreatNode is null)
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Couldn't find any node, retreat aborted, check path nodes in the level");
				mpStateMachine.ChangeState(eGhoulState_Idle);
				return;
			}
			
			mvRetreat_RetreatToPos = pRetreatNode.GetPosition();
			
			msAnimState = "RetreatReaction";
			mpMover.TurnToPos(mBaseObj.GetPlayerPos());
			mBaseObj.PlaySound("Scream", gsGhoulSound_Scream, true, true);
			PlayRandomAnimation(mvGhoulAnim_Scream, 0.0f);
		}
		else
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Move to set position");
			mpStateMachine.AddTimer("Move", 0.0f);
		}
	}

	//------------------------------------------------------------

	void State_Retreat_Leave()
	{
		State_Default_Leave();
		mbRetreat_CalculatePos = false;
		mbRetreat_SensesActive = false;
		msRetreat_CompletedCallback = "";
		mbProximityDetectionActive = true;
	}

	//------------------------------------------------------------

	void State_Retreat_Update(float afTimeStep)
	{
		UpdateDoorDetection(afTimeStep);
	}

	//------------------------------------------------------------

	bool State_Retreat_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight) return true;
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msAnimState == "RetreatReaction")
			{
				mpStateMachine.AddTimer("ProximityDetectionOn", 3);
				mpStateMachine.AddTimer("Move", 0.0f);
			}
			else if (msAnimState == "PlayFrustration")
			{
				mpStateMachine.AddTimer("Exit", 0.5f);
			}
			msAnimState = "";
		}
		
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			mbRetreat_SensesActive = true;
			mpStateMachine.AddTimer("PlayFrustration", 1.0f);
			return true;
		}

		if (alMessageId == eLuxEntityMessage_SoundHeard ||
			alMessageId == eLuxEntityMessage_PlayerDetected ||
			alMessageId == eLuxEntityMessage_PlayerUndetected)
		{
			return !mbRetreat_SensesActive;
		}

		return false;
	}

	//------------------------------------------------------------

	void State_Retreat_TimerUp(uint64 alId)
	{
		if (alId == H64("Move"))
		{
			mpPathfinder.MoveTo(mvRetreat_RetreatToPos, 1.0f, false);
		}
		
		else if (alId == H64("PlayFrustration"))
		{
			msAnimState = "PlayFrustration";
			mBaseObj.PlaySound("Frustration", gsGhoulSound_Frustration, true, true);	
			mpMover.PlayAnimation(gsGhoulAnim_Frustration, 0.0f, false, false, "");
		}
		
		else if (alId == H64("ProximityDetectionOn"))
		{
			mbProximityDetectionActive = true;
		}
		
		else if (alId == H64("Exit"))
		{
			if (mCommand == eGhoulCommand_Retreat)
			{
				ExecuteRetreatCompletedCallback(msCommandCompletedCallback);
				mCommand = eGhoulCommand_None;
			}
			ExecuteRetreatCompletedCallback(msRetreat_CompletedCallback);
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}
	
	//------------------------------------------------------------
	
	void ExecuteRetreatCompletedCallback(const tString &in asFunc)
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ExecuteRetreatCompletedCallback function: " + asFunc);
		if (asFunc == "") return;
		
		tString sMethodName = "void " + asFunc + "()";
		cLuxMap@ pMap = mBaseObj.GetMap();
		if (pMap.ScriptMethodExists(sMethodName) && pMap.ScriptPrepare(sMethodName))
		{
			pMap.ScriptExecute();
		}
	}
	
	//------------------------------------------------------------
	
	//} END RETREAT
	
	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: POST RETREAT
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	cVector3f mvPostRetreat_StartPos;
	cVector3f mvPostRetreat_RetreatFromPos;
	bool mbPostRetreat_DoneWandering;
	
	//------------------------------------------------------------

    void State_PostRetreat_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: PostRetreat ------",false,true);
		
		mvPostRetreat_StartPos = mBaseObj.GetPosition();
		mbPostRetreat_DoneWandering = false;
		
		mpPathfinder.Stop();
		mpMover.SetSpeedState(eGhoulSpeed_Walk);
		
		////////////////
		// Only check the pos we retreated from if we retreated from the player
//		if (mbRetreat_FromPlayer)
//		{
//			mpStateMachine.AddTimer("WanderAround", cMath_RandRectf(0.4f, 1.0f));
//			mpStateMachine.AddTimer("CheckRetreatFromPos", cMath_RandRectf(15.0f, 20.0f));
//		}
//		else
//		{
//			mpStateMachine.AddTimer("ExitState", cMath_RandRectf(1.0f, 2.0f));	
//		}
	}

	//------------------------------------------------------------

	void State_PostRetreat_Leave()
	{
//		mbRetreat_FromPlayer = false;
	}

	//------------------------------------------------------------

	void State_PostRetreat_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_PostRetreat_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_EndOfPath)
		{
			if (mbPostRetreat_DoneWandering == false)
			{
				mpStateMachine.AddTimer("WanderAround", cMath_RandRectf(0.4f, 1.0f));			
			}
			else
			{
//				mpMover.TurnToPos(mvRetreat_SourcePos);
				mpStateMachine.AddTimer("ExitState", cMath_RandRectf(2.0f, 4.0f));	
			}
			return true;
		}
		return false;
	}

	//------------------------------------------------------------

	void State_PostRetreat_TimerUp(uint64 alId)
	{
		if(alId == H64("WanderAround"))
		{
			if (cMath_RandRectf(0.0f, 1.0f) <= 0.6f)
			{
				mBaseObj.PlaySound("Searching", gsGhoulSound_Searching, true, true);
			}
			
			cAINode@ pNode = mpPathfinder.GetNodeAtPos(mvPostRetreat_StartPos, 0.0f, 6.0f, false, false, false, null);
			if (pNode !is null)
			{
				mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
			}
			else
			{
				mpStateMachine.ChangeState(eGhoulState_Idle);
			}
		}
		
		if(alId == H64("CheckRetreatFromPos"))
		{
			mbPostRetreat_DoneWandering = true;
			mpStateMachine.StopTimer("WanderAround");
			
//			if (cMath_Vector3Dist(mBaseObj.GetPlayerPos(), mvRetreat_PlayerPos) >= 4.0f)
//			{
//				cAINode@ pNode = mpPathfinder.GetNodeAtPos(mBaseObj.GetPlayerFeetPos(), 0.0f, 5.0f, true, false, false, null);
//				if (pNode is null || pNode !is null && cMath_Vector3Dist(pNode.GetPosition(), mBaseObj.GetPlayerFeetPos()) <= 2.5f)
//				{
//					cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Check retreat from position");
//					@pNode = mpPathfinder.GetNodeAtPos(mvPostRetreat_RetreatFromPos, 0.0f, 2.0f, true, false, false, null);
//					if (pNode !is null)
//					{
//						mpPathfinder.MoveTo(pNode.GetPosition(), 1.0f, false);
//						return;
//					}
//				}
//			}
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Player hasn't moved from unreachable position, go to idle");
			mpStateMachine.AddTimer("ExitState", cMath_RandRectf(1.0f, 2.0f));
		}
		
		if(alId == H64("ExitState"))
		{
			cLux_AddTodoMessage("TODO-SOUND: give up");
			mBaseObj.PlaySound("GiveUpSound", gsGhoulSound_GiveUp, true, true);
			
			mpStateMachine.ChangeState(eGhoulState_Idle);
		}
	}
	
	//------------------------------------------------------------
	
	//} END POST RETREAT

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: BREAK DOOR
	//{////////////////////////////////

	//------------------------------------------------------------

	bool mbCurrentlyAttackingDoor = false;
	bool mbBreakDoor_SniffedLastTime = false;
	float mfBreakDoor_Health = 0.0f;
	int mlBreakDoor_Hits = 0; //Current number of hits on the door
    int mlBreakDoor_MaxAttempts = 2; //Max number of hits allowed on the door
    float mlBreakDoor_Damage = 1.0/mlBreakDoor_MaxAttempts; //Damage done to doors
    float mlBreakDoor_Limit = 2.0f; //The highest health a door can have where the agent will still try to break down the door
	tString msBreakDoor_AttackAnim = "";
	tString msBreakDoor_AnimState = "";

	//------------------------------------------------------------

    void State_BreakDoor_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: BreakDoor ------",false,true);
		cLux_AddDebugMessage("Enter break door state");
		
		mfBreakDoor_Health = mlBreakDoor_Limit;
		mlBreakDoor_Hits = 0;
		
		mpMover.SetUseMoveStateAnimations(false);
		mpMover.TurnToPos(cLux_ID_Prop(m_idBlockedByProp_Entity).GetPosition());
		mpStateMachine.AddTimer("DecideOnDoorAction", 0.1f);
	}

	//------------------------------------------------------------

	void State_BreakDoor_Leave()
	{
		cLux_AddDebugMessage("Leave break door state");
		mpMover.SetUseMoveStateAnimations(true);
		mbCurrentlyAttackingDoor = false;
	}

	//------------------------------------------------------------

	void State_BreakDoor_Update(float afTimeStep)
	{
	}

	//------------------------------------------------------------

	bool State_BreakDoor_Message(int alMessageId)
	{
		if (alMessageId == eCustomEntityMessage_StuckCounterHigh) return true;

		if (alMessageId == eLuxEntityMessage_AnimationMessageEvent)
		{
			if (msBreakDoor_AnimState == "BreakDoor")
			{
				cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
				float fDamage = mlBreakDoor_Damage;
				if (pProp.GetIsDoor() == false) fDamage = 1.0f;
				pProp.SetHealth(pProp.GetHealth() - fDamage);
                cLux_AddDebugMessage("Dealing " + cString_ToString(fDamage) + " to door");
			}
		}
		
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			if (msBreakDoor_AnimState == "BreakDoor")
			{
                msBreakDoor_AnimState = "";
				mpStateMachine.AddTimer("DecideOnDoorAction", 0.1f);
			}
            else msBreakDoor_AnimState = "";
		}

		// Ignore sounds while we're engaged with a door - target fixation? :)
		if (alMessageId == eLuxEntityMessage_SoundHeard)
		{
			if (GetSensesActive() == false) return true;
			
			cVector3f vNewGoal = mpStateMachine.GetCurrentMessageData().mvX;
			if (mbCurrentlyAttackingDoor) return true;
			if (mBaseObj.GetPointIsInFront(vNewGoal)) return true;
			return false;
		}
		
		if (alMessageId == eCustomEntityMessage_AttractAgent)
		{
			if (mBaseObj.GetPointIsInFront(mpStateMachine.GetCurrentMessageData().mvX)) return true;
			return false;
		}
		
		if (alMessageId == eCustomEntityMessage_DetectFlashlightGobo) return true;
		if (alMessageId == eCustomEntityMessage_HitByFlashlight && mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos())) return true;
		if (alMessageId == eLuxEntityMessage_PlayerDetected && mBaseObj.GetPointIsInFront(mBaseObj.GetPlayerPos())) return true;

		return false;
	}

	//------------------------------------------------------------

	void State_BreakDoor_TimerUp(uint64 alId)
	{
		if(alId == H64("BreakDoor"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Break door");
			cLux_AddDebugMessage("BreakDoor timer execute");
			
			///////////////////////////
			// When attacking door we try to open it, so if the player pushes the door closed we get feedback on the door
			mbCurrentlyAttackingDoor = true;
			++mlBreakDoor_Hits;
			
			msBreakDoor_AttackAnim = GetRandomCloseAttack();
			mBaseObj.PlaySound("Attack", gsGhoulSound_Attack, true, true);
			
			msBreakDoor_AnimState = "BreakDoor";
			
			cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
			if (pProp.GetIsDoor() == false){
                cLux_AddDebugMessage("Hit Obstacle");
                PlayRandomAnimation(mvGhoulAnim_HitObstacle);
            }
			//else if (pProp.GetHealth() <= mlBreakDoor_Damage) PlayRandomAnimation(mvGhoulAnim_HitDoor);
			else{
                cLux_AddDebugMessage("Hit door");
                PlayRandomAnimation(mvGhoulAnim_HitDoor);
            }
			
//			mpMover.PlayAnimation(msBreakDoor_AttackAnim, 0.2f, false, true, "");
			
			//SwingDoor_PushOpen(cLux_ID_Prop(m_idBlockedByProp_Entity).GetName(), 1.5f, 10, 0.1f);
		}

		if (alId == H64("DecideOnDoorAction"))
		{
			mbCurrentlyAttackingDoor = false;
			mpAttackDamage.Stop(0);
			
			cLuxProp@ pProp = cLux_ID_Prop(m_idBlockedByProp_Entity);
			if (pProp !is null)
			{
				float fHealth = Prop_GetHealth(cLux_ID_Prop(m_idBlockedByProp_Entity).GetName());
                
				bool bTriedUnbreakable = mlBreakDoor_Hits >= mlBreakDoor_MaxAttempts && SwingDoor_IsBreakable(cLux_ID_Prop(m_idBlockedByProp_Entity).GetName()) == false;
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Post attack: prop hp: " + fHealth + " previously: " + mfBreakDoor_Health);
				cLux_AddDebugMessage("Health: " + cString_ToString(fHealth) + "mfBreakDoor_Health:" + cString_ToString(mfBreakDoor_Health));
				if (fHealth > 0 && fHealth < mfBreakDoor_Health && bTriedUnbreakable == false)
				{
					cLux_AddDebugMessage("Start the breakdoor timer");
					//mfBreakDoor_Health = fHealth;
					mpStateMachine.AddTimer("BreakDoor", 0.1f);
				}
				else
				{
					cLux_AddDebugMessage("Unbreakable");
                    cLux_AddDebugMessage("Health: " + cString_ToString(fHealth) + "mfBreakDoor_Health:" + cString_ToString(mfBreakDoor_Health));
                    if (bTriedUnbreakable) { cLux_AddDebugMessage("true"); }
                    else { cLux_AddDebugMessage("false"); }
					mpStateMachine.AddTimer("ExitUnbreakable", 0.5f);
				}
			}
			else
			{
				mpStateMachine.AddTimer("Exit", 0.5f);
			}
		}

		if(alId == H64("Exit"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Exit");
			mpStateMachine.ChangeState(mlBlocked_PrevState);
			LeaveBlockedState();
		}
		
		if(alId == H64("ExitUnbreakable"))
		{
			cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ExitUnbreakable");
			if (mAlertState == eGhoulAlertState_Investigating)
			{
				TrackSmell_Disable(15.0f);
				mpStateMachine.ChangeState(eGhoulState_Idle);
			}
			else
			{
				cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") Can't break door, abandoning investigation");
				mpStateMachine.ChangeState(mlBlocked_PrevState);
			}
			LeaveBlockedState();
		}
	}

	//------------------------------------------------------------

	//} END BREAK DOOR

	//------------------------------------------------------------

	///////////////////////////////////
	// STATE: STUCK
	//{////////////////////////////////

	//------------------------------------------------------------

    void State_Stuck_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Stuck ------",false,true);
	}
	
	//------------------------------------------------------------

	void State_Stuck_Leave()
	{
	}
	
	//------------------------------------------------------------

	void State_Stuck_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_Stuck_Message(int alMessageId)
	{
		return false;
	}
	
	//------------------------------------------------------------

	void State_Stuck_TimerUp(uint64 alId)
	{
	}
	
	//------------------------------------------------------------

	//} END STUCK
	
	//------------------------------------------------------------
	
	///////////////////////////////////
	// STATE: WAKEUP
	//{////////////////////////////////
	
	//------------------------------------------------------------
	
	tString msWakeUp_Anim = "";
	
	//------------------------------------------------------------

	void State_WakeUp_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: WakeUp ------",false,true);
	
		mpMover.SetUseMoveStateAnimations(false);
		mBaseObj.PlayAnimation(msWakeUp_Anim, 0.f, false, false);
		
		mpStateMachine.AddTimer("SetEyeColor", 1.1f);
	}

	//------------------------------------------------------------

	void State_WakeUp_Leave()
	{
		mBaseObj.GetCharBody().SetTestCollision(true);
		mBaseObj.GetCharBody().SetPhysicsBodyActive(true);
		mpMover.SetUseMoveStateAnimations(true);
	}

	//------------------------------------------------------------

	void State_WakeUp_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------

	bool State_WakeUp_Message(int alMessageId)
	{
		if (alMessageId == eLuxEntityMessage_AnimationOver)
		{
			mpStateMachine.ChangeState(eGhoulState_Idle);
			
			if (mCommand == eGhoulCommand_WakeUp)
			{
				mCommand = eGhoulCommand_None;
				ExecuteEntityCallback(msCommandCompletedCallback);
			}
		}			
		return true;
	}
	
	//------------------------------------------------------------

	void State_WakeUp_TimerUp(uint64 alId)
	{
		if (alId == H64("SetEyeColor"))
			SetEyeColor(gGhoul_EyeColorAlerted);
	}

	//------------------------------------------------------------

	//} END WAKEUP
	
	//------------------------------------------------------------

	/////////////////////////////////////////
	// STATE: DEBUG
	//{//////////////////////////////////////

	// THIS IS NOT A REAL STATE AND SHOULD NOT BE USED IN GAME FOR ANY PURPOSES OTHER THAN
	// QUICKLY TRANSITIONING YOU IN TO A STATE THAT YOU NEED TO DEBUG. CALLS SHOULD NEVER
	// BE MADE TO THIS STATE IN RELEASED GAME!!!

	//------------------------------------------------------------

	void _Global_ForceDebugState()
	{
		mpStateMachine.ChangeState(eGhoulState_Debug);
	}
	
	//------------------------------------------------------------

    void State_Debug_Enter()
	{
		cLux_AddAIDebugMessage("(" + mBaseObj.GetName() + ") ------ ENTER STATE: Debug ------",false,true);
		//mBaseObj.RevealPlayerPos();
		//mpStateMachine.ChangeState(eGhoulState_Retreat);

		mbSeekHolesDuringRandomWander = !mbSeekHolesDuringRandomWander;
		cLux_AddDebugMessage("Seekholes = " + mbSeekHolesDuringRandomWander);
		mpStateMachine.ChangeState(mpStateMachine.GetPrevState());
	}
	
	//------------------------------------------------------------
	
	void State_Debug_Leave()
	{
	}
	
	//------------------------------------------------------------
	
	void State_Debug_Update(float afTimeStep)
	{
	}
	
	//------------------------------------------------------------
	
	bool State_Debug_Message(int alMessageId)
	{
		return true;
	}
	
	//------------------------------------------------------------
	
	void State_Debug_TimerUp(uint64 alId)
	{
	}

	//------------------------------------------------------------
	
	//} END DEBUG
	
	//------------------------------------------------------------
	
	//} END GHOUL SPECIFIC CODE

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// PROPERTIES
	//{//////////////////////////////////////

	//------------------------------------------------------------
	
	////////////////
	// Components
	cLuxStateMachine@ mpStateMachine;
	cLuxSoundListener@ mpSoundListener;
	cLuxBarkMachine@ mpBarkMachine;
	cLuxHeadTracker@ mpHeadTracker;
	cLuxLightSensor@ mpLightSensor;
	cLuxEdgeGlow@ mpEdgeGlow;
	cLuxProximitySensor@ mpProximitySensor;
	cLuxAttackDamage@ mpAttackDamage;
	cLuxFootPlacement@ mpFootPlacement;
	[volatile] iScrAIMeatSensor_Interface@ mpMeatSensor = null;
	[volatile] iScrAIPlayerNotify_Interface@ mpPlayerNotify = null;
	
	bool mbStarted = false;
		
	////////////////
	// General states
	eGhoulMode mMode = eGhoulMode_Idle;
	eGhoulCommand mCommand = eGhoulCommand_None;
	eGhoulAlertState mAlertState = eGhoulAlertState_None;
	tString msAnimState = "";
	tString msCommandCompletedCallback = "";
	bool mbModeOverrideSenses = false;
	bool mbModeSensesActive = true;
	bool mbIsInLiquid = false;
	bool mbAllowPlayerThrow = false;
	
	////////////////
	// Move anims
	tString msIdleAnim;
	tString msWalkAnim;
	tString msOrigWalkAnim;
	
	////////////////
	// Senses
	float mfSightMul = 1.0f;
	float mfHearingMul = 1.0f;
	float mfHearRadius = 1.0f;
	bool mbCurrentlyDeaf = false;
	bool mbPlayerSubmerged = false;
	
	////////////////
	// Flashlight detection
	bool mbDetectFlashlight = true;
	cVector3f mvGoboPos;
	float mfGoboCounter = 0.0f;
	float mfHitByFlashlightCounter = 0.0f;
	
	////////////////
	// Eyes
	[nosave] tID m_idEyeLeft;
	[nosave] tID m_idEyeRight;
	
	////////////////
	// Pathfinding
	float mfDirectPathMaxDistanceMul = 0.25f;
	
	////////////////
	// Eating
	float mfMinEatTime = 5.0f;
	float mfMaxEatTime = 5.0f;
	float mfCannotBeAttractedTimer = 0.0f;
	bool mbAngryWhileEating = false;
	
	////////////////
	// Attacks
	tString msAttackAnimName = "Attack";
	int mlNumAttackAnims = 1;
	tString msAttackLungeAnimName = "AttackLunge";
	int mlNumAttackLungeAnims = 1;
	bool mbAttack_InstantKill = false;
	bool mbCanAttack = true;
	
	bool mbCollisionCourseDetection = true;
	
	////////////////
	// Spawning system
	tString msHoleNetwork = "";
	tString msPlayerPath = "";
	tString msHoleConnections = "";
	
	int mlGhoulHoleNetworkId = -1;
	cLuxArea@ mSpawnHole;
	cLuxArea@ mExitHole;
	tID mlIDExitHoleArea;

	float mfSniffRange = 9.75f;
	float mfSniffRangeMul = 1.0f;
    float mfTimeSinceLastSniff = 0.f;

	float mfMovedTimeout = 0.0f;
	float mfMovedDistance = 0.0f;
	cVector3f mvLastTrackedPosition;

	int mlAttackCurrentShape = 0;
	int mlAttackAnimPhase = 0;
	bool mbIsGeneratingTerror = false;
	bool mbSeekHolesDuringRandomWander = false;
	float mfPermafailInvulnerabilityTimer = 0;
	
	bool mbAvoidingDeadEndPlayer = false;
	bool mbFootstepSoundsActive = false;
	
	cVector3f mvLastHitByPropPos;
	
	////////////////
	// Callbacks
	tString msCallback_EndOfPatrol;
	tString msPostAttackCallback;
	tString msAlertedCallback;
	array<cDistanceCallback> mDistanceCallbacks;
	
	
	////////////////
	// Sound counter
	float mfSoundCounter;
	
	////////////////
	// Pre alert
	bool mbPreAlert = false;
	
	////////////////
	// Events
	float mfTimeSinceLastEvent = 10.0f;
	float mfEventCooldown = 20.0f;
	
	////////////////
	// Proximity events
	array<cAgentEvent> mvProximityEvents;
	int mlProximityEventType;
	bool mbProximityEventFirstAgent;
	tID m_idProximityEventOtherAgent;

	////////////////
	// Environment events
	int mlEnvironmentEventType;
	tID m_idEnvironmentEventEntity;
	
	////////////////
	// Voice
	bool mbUseVoice = true;
	
	tString msVoiceCharacter;
	tString msAlertSubject;
	tString msRetreatSubject;
	tString msEmergeSubject;
	tString msSmellSubject;
	tString msEndSearchSubject;
	tString msCheckLastKnownPositionSubject;
	tString msHitByObjectSubject;
	
	////////////////
	// Fear management
	float mfFearDefault = 0.5f;
	float mfFearSpotted = 0.7f;
	float mfFearHunted = 1.0f;
	cFearThreatParams mFearParams;
	
	////////////////
	// Retreat
	array<tID> mvRetreatAreas;
	tString msRetreatAreaName = "";
	
	//------------------------------------------------------------

	//} END PROPERTIES

	//------------------------------------------------------------

	/////////////////////////////////////////
	// DEBUG
	//{//////////////////////////////////////

	//------------------------------------------------------------
	
	array<cVector3f> mvTestPoints;
	array<cVector3f> mvTestRaysA;
	array<cVector3f> mvTestRaysB;
	array<float> mvTestPointTimes;
	array<float> mvTestRayTimes;
	
	//------------------------------------------------------------
	
	void DrawTestPoint(const cVector3f &in avPoint, float afTime = 2)
	{
		mvTestPoints.push_back(avPoint);
		mvTestPointTimes.push_back(afTime);
	}
	
	//------------------------------------------------------------
	
	void DrawTestRay(const cVector3f &in avFrom, const cVector3f &in avTo, float afTime = 2)
	{
		mvTestRaysA.push_back(avFrom);
		mvTestRaysB.push_back(avTo);
		mvTestRayTimes.push_back(afTime);
	}
	
	//------------------------------------------------------------
	
	void UpdateTestPoints(float afTimeStep)
	{
		for (int i = 0; i < mvTestPointTimes.size(); ++i)
		{
			mvTestPointTimes[i] -= afTimeStep;
			if (mvTestPointTimes[i] <= 0)
			{
				mvTestPoints.removeAt(i);
				mvTestPointTimes.removeAt(i);
				--i;
			}
		}
	}
	
	//------------------------------------------------------------
	
	void UpdateTestRays(float afTimeStep)
	{
		for (int i = 0; i < mvTestRayTimes.size(); ++i)
		{
			if (mvTestRayTimes[i] < 0) continue;
			
			mvTestRayTimes[i] -= afTimeStep;
			if (mvTestRayTimes[i] <= 0)
			{
				mvTestRaysA.removeAt(i);
				mvTestRaysB.removeAt(i);
				mvTestRayTimes.removeAt(i);
				--i;
			}
		}
	}
	
	//------------------------------------------------------------

	float DrawDebugOutput(cGuiSet @apSet,iFontData @apFont,float afStartY)
	{
		if (Blackboard_GetAgentCount() > 4) return afStartY;
		
		afStartY += 10.0f;
//		tString startPoint = mSpawnHole is null ? ""+cVector3f_Zero : "" + mSpawnHole.GetPosition();
//		afStartY = cLux_DrawDebugText("start point : " + startPoint, afStartY);
//		tString endPoint = mExitHole is null ? ""+cVector3f_Zero : "" + mExitHole.GetPosition();
//		afStartY = cLux_DrawDebugText("end point : " + endPoint, afStartY);
//		afStartY = cLux_DrawDebugText("wander goal : " + mvWanderToExitHole_Goal, afStartY);
//		afStartY = cLux_DrawDebugText("wanders remaining : " + mlWanderToExitHole_WandersToDo, afStartY);
		afStartY = cLux_DrawDebugText("player distance : " + mBaseObj.GetDistanceToPlayer(), afStartY);
		afStartY = cLux_DrawDebugText("player speed : " + cLux_GetPlayer().GetAverageMoveSpeed(), afStartY);
//		afStartY = cLux_DrawDebugText("timeout : " + mfMovedTimeout, afStartY);
		afStartY = cLux_DrawDebugText("stuck : " + mpMover.GetStuckCounter(), afStartY);
		afStartY = cLux_DrawDebugText("super hunt : " + mfHunt_SuperHuntCounter + " " + mbHunt_SuperHunt, afStartY);
		afStartY = cLux_DrawDebugText("sound counter : " + mfSoundCounter, afStartY);
		afStartY = cLux_DrawDebugText("smelling : " + mbTrackSmell_Enabled, afStartY);
		afStartY = cLux_DrawDebugText("senses active : " + GetSensesActive(), afStartY);
		afStartY = cLux_DrawDebugText("speed state : " + SpeedStateToString(mpMover.GetSpeedState()), afStartY);
		afStartY = cLux_DrawDebugText("alert state: " + AlertStateToString(mAlertState), afStartY);
		afStartY = cLux_DrawDebugText("mode : " + ModeToString(mMode), afStartY);
		afStartY = cLux_DrawDebugText("command : " + CommandToString(mCommand), afStartY);

		//afStartY = cLux_DrawDebugText("movement towards entity : "+mBaseObj.GetPlayerMovementTowardEntity(), afStartY);
		//afStartY = cLux_DrawDebugText("mfAlertRunTowardCount : " + mfAlertRunTowardCount, afStartY);
		//afStartY = cLux_DrawDebugText("Terror : " + Terror_GetAmount(), afStartY);
		//afStartY = cLux_DrawDebugText("CurrentAttraction : " + mBaseObj.GetVarString("CurrentMeatAttraction"), afStartY);
		//afStartY = cLux_DrawDebugText("Breakable Object : " + msBlockedByProp_EntityName, afStartY);

		return afStartY;
	}

	//------------------------------------------------------------
	
	int counter = 0;
	
	cVector3f vTestPos;
	int lTestPosCounter = 0;;
	cVector3f vTestPos2 = cVector3f_Zero;
	
	void OnRenderSolid(cRendererCallbackFunctions@ apFunctions)
	{
		if(false)
		{
			int lId = -1;

			float fDist = 0.f;
			cVector3f vEnd = 0.f;
			cVector3f vNrm = 0;
			iCharacterBody@ pBody = mBaseObj.GetCharBody();
			//pBody.GetFeetPosition()
			cVector3f vStart = pBody.GetPosition() + pBody.GetForward() * 1.25f;
			
			///////////////////
			// Find best throw dir
			
			array<cVector3f> vDirs;
			for (int i = 0; i < 8; i++)
				vDirs.push_back(cMath_MatrixMul(cMath_MatrixRotateY(cMath_PiDiv4 * i), pBody.GetForward()));	
			
			array<int> vCandidates;
			array<float> vCandidatesDistances;
			
			float fMaxDist = 0.f;
							
			for (int i = 0; i < vDirs.size(); i += 2)
			{
				if(cLux_GetClosestBody(vStart, vDirs[i], gfMaxThrowDistance, fDist, vNrm) is null)
						fDist = gfMaxThrowDistance;
				
				if (fDist >= gfMinThrowDistance && fDist >= fMaxDist)
				{
					fMaxDist = fDist;
					vCandidates.push_back(i);
					vCandidatesDistances.push_back(fDist);
				}
				
				apFunctions.GetLowLevelGfx().DrawLine(vStart, vStart + vDirs[i] * fDist, cColor_Green * 10.f);
				apFunctions.GetLowLevelGfx().DrawSphere(vStart + vDirs[i] * fDist, 0.25f, cColor_Green * 10.f);
			}
			
			// Few suitable dirs found, try the other directions!
			//if (vCandidates.size() == 0)
			{			
				for (int i = 1; i < vDirs.size(); i += 2)
				{
					if(cLux_GetClosestBody(vStart, vDirs[i], gfMaxThrowDistance, fDist, vNrm) is null)
						fDist = gfMaxThrowDistance;
				
				
					if (fDist >= gfMinThrowDistance && fDist >= fMaxDist)
					{
						fMaxDist = fDist;					
						vCandidates.push_back(i);
						vCandidatesDistances.push_back(fDist);
					}
					
					apFunctions.GetLowLevelGfx().DrawLine(vStart, vStart + vDirs[i] * fDist, cColor_Green * 10.f);
					apFunctions.GetLowLevelGfx().DrawSphere(vStart + vDirs[i] * fDist, 0.25f, cColor_Green * 10.f);
				}
			}
			
			if (vCandidates.size() == 0) return;

			for (int i = 0; i < vCandidates.size(); i++)
			{
				float fCandidateDistance = vCandidatesDistances[i] - 1.f;
				// Make sure there's something for the player to land on!
				vEnd = vStart + cVector3f(0.f, 0.f, 0.f) + vDirs[vCandidates[i]] * fCandidateDistance;
			
				if (cLux_GetClosestBody(vEnd, cVector3f_Down, 20.f, fDist, vNrm) is null)
					continue;
				
				
				apFunctions.GetLowLevelGfx().DrawLine(vEnd, vEnd + cVector3f_Down * fDist, cColor_Blue * 10.f);
				apFunctions.GetLowLevelGfx().DrawSphere(vEnd + cVector3f_Down * fDist, 0.25f, cColor_Blue * 10.f);
				
				
				cVector3f vEndStart = cMath_Vector3Normalize((vStart - (vEnd + cVector3f_Down * fDist)) * cVector3f(1, 0, 1));
				vEndStart = (vEnd + cVector3f_Down * fDist) + vEndStart * 3.f;

				apFunctions.GetLowLevelGfx().DrawSphere(vEndStart, 0.25f, cColor_Red * 10.f);

				lId = vCandidates[i];
			}		
		return;
		}
		
		cVector3f exitPos = mExitHole is null ? cVector3f_Zero : mExitHole.GetPosition();
		apFunctions.GetLowLevelGfx().DrawSphere(exitPos, 1, cColor(0,1,0,1));
		
		cVector3f spawnPos = mSpawnHole is null ? cVector3f_Zero : mSpawnHole.GetPosition();
		apFunctions.GetLowLevelGfx().DrawSphere(spawnPos, 1, cColor(1,1,0,1));
		
		apFunctions.GetLowLevelGfx().DrawSphere(mvWanderToExitHole_Goal, 1, cColor(0,0,1,1));

		apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetLastKnownPlayerPos(), 1, cColor(0,1,1,1));
		
		apFunctions.GetLowLevelGfx().DrawSphere(mvWallMoveSegmentEnd, 1, cColor(0,1,0,1));
		apFunctions.GetLowLevelGfx().DrawSphere(mvWallMoveGoal, 0.5, cColor(0,10,0,1));
		
		if (mpStateMachine.GetCurrentState() == eGhoulState_HideInHole)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), 6, cColor(10,0,0,1));
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), 3, cColor(10,0,0,1));
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), 1, cColor(10,0,0,1));
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), 0.2, cColor(10,0,0,1));
		}
	
		for (int i = 0; i < mvTestPoints.size(); ++i)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(mvTestPoints[i], 0.5f, cColor(5,5,20));
		}
		
		for (int i = 0; i < mvTestRaysA.size(); ++i)
		{
			apFunctions.GetLowLevelGfx().DrawLine(mvTestRaysA[i], mvTestRaysB[i], cColor(5,5,20));
		}
		
//		apFunctions.GetLowLevelGfx().DrawSphere(mpPathfinder.GetGoalPos(), 1, cColor(10,10,10,1));
		
		if (lTestNodesCountdown > 0)
		{
			for (int i = 0; i < vTestNodes.length(); ++i)
			{
				apFunctions.GetLowLevelGfx().DrawSphere(vTestNodes[i], 1, cColor(0.5,1,0.5,1));
			}
			
			if (cLux_GetGamePaused() == false)
			{
				--lTestNodesCountdown;
			}
		}
		
		if (vTestPos2 != cVector3f_Zero)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(vTestPos2, 1, cColor(10,0,0,1));
		}
		
		if (lTestPosCounter > 0)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(vTestPos, 2, cColor(15, 1,1,1));
			if (cLux_GetGamePaused() == false)
			{
				--lTestPosCounter;
			}
		}
		
		if (mpStateMachine.GetCurrentState() == eGhoulState_TrackSmell)
		{
			apFunctions.GetLowLevelGfx().DrawSphere(mBaseObj.GetPosition(), mfTrackSmell_SmellRadius, cColor(10,10,5));
		}

		//apFunctions.GetLowLevelGfx().DrawSphere(mvBuildPathDebugMidpoint, 0.2, cColor(1,1,0,1));
		/*apFunctions.GetLowLevelGfx().DrawSphere(mvInvestigateSound_Goal, 0.3, cColor(1,1,0,1));

		float fCharRadius = mBaseObj.GetCharBody().GetSize().x * 0.5f;
		float fDist = 2.0f;
		cVector3f vFwd = mBaseObj.GetCharBody().GetForward();
		cVector3f vRayStart = mBaseObj.GetPosition();
		vRayStart+=vFwd*fCharRadius;
		cVector3f vRayEnd = vRayStart + (vFwd*fDist);

		apFunctions.GetLowLevelGfx().DrawLine(vRayStart,vRayEnd,cColor(1.0f,1.0f,1.0f,1.0f));*/

	}
    
	//------------------------------------------------------------

	//} END DEBUG
}
